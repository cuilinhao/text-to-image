
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Sora Image Demo</title>
    <style>
        body {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* 标签页样式 */
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-buttons {
            display: flex;
            gap: 0;
        }
        .tab-button {
            padding: 12px 20px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
        }
        .tab-button.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
            color: #1890ff;
        }
        .tab-button:hover {
            background-color: #e6f7ff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="text"], input[type="password"], input[type="number"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            width: 100px;
        }
        button {
            padding: 10px 20px;
            background-color: #1890ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
        }
        button.secondary {
            background-color: #52c41a;
        }
        button.secondary:disabled {
            background-color: #ccc;
        }
        button.download {
            background-color: #722ed1;
            margin-left: 10px;
        }
        .result {
            margin-top: 20px;
        }
        img {
            max-width: 100%;
            margin-top: 10px;
        }
        .debug {
            margin-top: 20px;
            padding: 15px;
            background-color: #1e1e1e;
            color: #f0f0f0;
            border-radius: 8px;
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #333;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        .debug::-webkit-scrollbar {
            width: 8px;
        }
        .debug::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        .debug::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        .debug::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        .image-preview {
            max-width: 200px;
            margin: 5px;
            border: 1px solid #ddd;
            padding: 5px;
            display: inline-block;
        }
        .upload-area {
            border: 2px dashed #ddd;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .upload-area:hover {
            border-color: #1890ff;
        }
        .example-images {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        .example-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .example-image:hover {
            border-color: #1890ff;
            transform: scale(1.05);
        }
        .example-image.selected {
            border-color: #52c41a;
            border-width: 3px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .prompt-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
        }
        .prompt-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .prompt-item img {
            max-width: 100px;
            max-height: 100px;
        }
        .prompt-item textarea {
            flex: 1;
            height: 60px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .image-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background-color: white;
        }
        .image-item img {
            width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .image-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .image-controls button {
            flex: 1;
            padding: 5px 10px;
            font-size: 12px;
        }
        .btn-download {
            background-color: #52c41a;
        }
        .btn-copy {
            background-color: #1890ff;
        }
        .btn-retry {
            background-color: #fa8c16;
        }
        .inline-control {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .inline-control label {
            white-space: nowrap;
        }
        
        /* 故事提示词特有样式 */
        .story-item {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: white;
            align-items: flex-start;
        }
        .story-index {
            min-width: 50px;
            font-weight: bold;
            color: #666;
            text-align: center;
            padding-top: 10px;
        }
        .story-prompt {
            flex: 1;
        }
        .story-prompt textarea {
            height: 80px;
            margin-bottom: 10px;
        }
        .story-ref-images {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .story-ref-images img {
            max-width: 60px;
            max-height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .story-ref-images img.selected {
            border-color: #1890ff;
            border-width: 2px;
        }
        .story-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            min-width: 200px;
            flex-direction: column;
        }
        .story-controls .button-group {
            width: 100%;
        }
        .file-input-button {
            background-color: #fa8c16;
            cursor: pointer;
        }
        .csv-preview {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sora Image Demo - 批量图片生成器</h1>
        
        <!-- 标签页 -->
        <div class="tab-container">
            <div class="tab-buttons">
                <div class="tab-button active" onclick="switchTab('imageToPrompt', this)">图转提示词</div>
                <div class="tab-button" onclick="switchTab('storyPrompt', this)">故事提示词</div>
            </div>
        </div>
        
        <!-- 图转提示词标签页 -->
        <div id="imageToPrompt" class="tab-content active">
            <!-- 使用提示 -->
            <div style="background-color: #e6f7ff; border: 1px solid #91d5ff; border-radius: 6px; padding: 16px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1890ff;">💡 使用提示</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li><strong>图片要求</strong>：建议上传清晰的角色图片，避免过于暴露或敏感的内容</li>
                    <li><strong>模型选择</strong>：可以手动选择不同的模型，如Claude-3 Sonnet对内容限制较为宽松</li>
                    <li><strong>图片压缩</strong>：系统会自动将图片压缩到1024px以内，提高处理成功率</li>
                    <li><strong>批量处理</strong>：可一次上传多张图片，系统会依次为每张图片生成时尚T台提示词</li>
                </ul>
            </div>
            
            <!-- OpenRouter 提示词生成组 -->
            <div class="control-group">
                <h3>🤖 AI 提示词生成器</h3>
                
                <div class="input-group">
                    <label for="openrouterKey">OpenRouter API Key:</label>
                    <div class="button-group">
                        <input type="password" id="openrouterKey" placeholder="输入你的 OpenRouter API Key" style="flex: 1;" value="">
                        <button onclick="testOpenRouterConnection()" id="testBtn" style="width: auto; padding: 8px 16px;">测试连接</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="modelSelect">选择模型:</label>
                    <select id="modelSelect">
                        <option value="openai/gpt-4o-mini" selected>GPT-4o Mini</option>
                        <option value="openai/gpt-4.1-mini">GPT-4.1 Mini</option>
                        <option value="openai/gpt-4-vision-preview">GPT-4 Vision</option>
                        <option value="openai/gpt-4o">GPT-4o</option>
                        <option value="anthropic/claude-3-opus">Claude-3 Opus</option>
                        <option value="anthropic/claude-3-sonnet">Claude-3 Sonnet</option>
                        <option value="google/gemini-pro-vision">Gemini Pro Vision</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>参考图片目录 (可选择多张图片):</label>
                    <div class="upload-area" onclick="document.getElementById('refImageInput').click()">
                        点击选择多张图片或拖拽图片到这里
                        <input type="file" id="refImageInput" accept="image/*" multiple style="display: none" onchange="handleRefImageUpload(event)">
                        
                        <!-- 示例图片展示 -->
                        <div style="margin-top: 15px; font-size: 14px; color: #666;">
                            💡 或点击下方示例图片快速选择：
                        </div>
                        <div class="example-images">
                            <img src="./public/咖啡杯宝宝.jpg" alt="咖啡杯宝宝" class="example-image" onclick="selectExampleImage(this, './public/咖啡杯宝宝.jpg')" title="咖啡杯宝宝">
                            <img src="./public/咖啡杯妈妈.png" alt="咖啡杯妈妈" class="example-image" onclick="selectExampleImage(this, './public/咖啡杯妈妈.png')" title="咖啡杯妈妈">
                            <img src="./public/卡布奇诺.png" alt="卡布奇诺" class="example-image" onclick="selectExampleImage(this, './public/卡布奇诺.png')" title="卡布奇诺">
                            <img src="./public/卡布奇诺01.jpg" alt="卡布奇诺01" class="example-image" onclick="selectExampleImage(this, './public/卡布奇诺01.jpg')" title="卡布奇诺01">
                            <img src="./public/橙子小孩.png" alt="橙子小孩" class="example-image" onclick="selectExampleImage(this, './public/橙子小孩.png')" title="橙子小孩">
                            <img src="./public/橘子肌肉男.png" alt="橘子肌肉男" class="example-image" onclick="selectExampleImage(this, './public/橘子肌肉男.png')" title="橘子肌肉男">
                            <img src="./public/木棍人2.png" alt="木棍人2" class="example-image" onclick="selectExampleImage(this, './public/木棍人2.png')" title="木棍人2">
                            <img src="./public/木棍人tuntun.png" alt="木棍人tuntun" class="example-image" onclick="selectExampleImage(this, './public/木棍人tuntun.png')" title="木棍人tuntun">
                        </div>
                    </div>
                    <div id="refImagePreview"></div>
                </div>

                <div class="input-group">
                    <label for="metaPrompt">元提示词:</label>
                    <textarea id="metaPrompt" placeholder="请根据上传的图片，生成一个详细的AI绘画提示词，要求包含画面构图、色彩、风格、细节等描述...">你是一位AI图像提示词造型师，专攻将任意角色形象在完美保留其核心识别特征的前提下，精准转化为'萌系婴儿/幼童超模'，并为其定制简洁、高冲击力、极具视觉美感的T台走秀造型提示词。我会提供一张拟人化角色的图片。
你的任务是：
深度分析并牢记提供的参考图角色的核心面部特征、五官风格及神韵。
基于此，将角色重塑为一个五官精致、脸颊肉嘟嘟、表情生动可爱的婴儿/幼童版本，确保其一眼就能被认出是原角色的婴儿形态。
为这个'保留了原角色神韵的婴儿超模'生成一段高度凝练、关键词驱动、避免冗余描述的文本到图像提示词。使其穿着成人高级时尚/潮流服饰的迷你精华版（严禁使用普通日常婴儿服装概念，如连体衣、尿布裤、传统婴儿帽等，除非被极度时尚化解构重塑），在明确无误的T台秀舞台环境中自信走秀。
【重要！生成的文生图提示词结构与内容核心要求】
开篇指令（绝对精炼）： 你生成的具体文生图提示词，开篇必须用最简短、最强势的指令直接点明核心画面：
格式示例： 主题：[例如，咖啡杯娃娃]婴儿超模T台秀，完美复刻原版五官神韵，甜美微笑，100%正脸直视镜头，迎面走来，神采奕奕。 (此处的"[例如，咖啡杯娃娃]"需要你根据我提供的图片动态替换)
服装描述（关键词驱动，拒绝平庸）：
风格定位： 明确一种或几种融合的成人时尚风格（如：迷你哥特朋克、宝宝高定街头、软萌赛博机能、复古奢华Y2K等）。
核心单品： 用精准的关键词描述1-3件最具代表性的**"成人时尚迷你版"核心服饰单品** (例如：微缩版解构主义风衣、超迷你亮片飞行员夹克、层叠薄纱蛋糕短裙配迷你马丁靴)。
色彩与材质： 简述主色调和突出材质（例如：暗黑撞色霓虹、马卡龙色系丝绒、金属质感皮革）。
点睛配饰： 提及1-2个时尚感强、符合整体风格的迷你配饰 (例如：超小号链条包、趣味墨镜、造型夸张的迷你头饰)。
绝对避免： 普通的婴儿服装描述，如"可爱的连体衣"、"柔软的毛线帽"等，除非它们被赋予了极强的时尚设计感和解构元素。目标是"穿着缩小版高定时装的婴儿"，而不是"穿着婴儿服的婴儿"。
T台场景与氛围（一句话点明，强制T台）：
环境风格： 必须明确指定为T台秀舞台环境，例如：场景：未来科技感光影T台，背景动态粒子特效。 或 场景：梦幻糖果城堡主题T台，柔和景深。 或 场景：简约几何线条T台，聚焦灯光。 严禁使用非T台的日常或自然场景。
灯光氛围： 例如：灯光：专业T台聚焦顶光，氛围迷幻。
画质与构图（固定指令）：
画质：超精细3D渲染，电影级质感，细节爆棚。
末尾必须添加： ratio 9:16
【对我（AI造型师）生成提示词的额外约束】
极度简洁： 你生成的每一段描述（服装、场景等）都应力求用最少的词语表达最核心的视觉信息。避免使用过多形容词和重复性描述。
冲击力与记忆点： 优先使用能产生强烈视觉联想和独特记忆点的关键词。
忠于原角色神韵： 在婴儿化的同时，必须通过对面部特征的强调，确保角色的可识别度。
时尚感优先： 在"萌"的基础上，服装和整体造型的"时尚感"和"设计感"是更高优先级。
场景强制T台： 无论服装风格如何，背景环境必须始终是T台秀的舞台。
请严格按照此V5.1元提示词的指导思想和结构要求，为我生成具体角色的文生图提示词。</textarea>
                </div>

                <button onclick="generatePrompts()" id="generatePromptBtn" class="secondary">批量生成 Prompts</button>
            </div>

            <!-- 生成的提示词列表 -->
            <div class="control-group" id="promptListGroup" style="display: none;">
                <h3>📝 生成的提示词列表</h3>
                <div class="prompt-list" id="promptList"></div>
            </div>

            <!-- 云雾平台图片生成组 -->
            <div class="control-group">
                <h3>🎨 图片生成</h3>
                
                <div class="input-group">
                    <label for="apiKey">云雾 API Key:</label>
                    <div class="button-group">
                        <input type="password" id="apiKey" placeholder="输入你的云雾API Key" value="" style="flex: 1;">
                        <button onclick="testYunwuConnection()" id="testYunwuBtn" style="width: auto; padding: 8px 16px;">测试连接</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="apicoreApiKey">APICore API Key (备用平台):</label>
                    <div class="button-group">
                        <input type="password" id="apicoreApiKey" placeholder="输入你的APICore API Key (可选)" value="sk-U1KUgGJjGdIPXhq6Lfpo9U7Zp7SkjIYis7gIN2m76YDI4sqh" style="flex: 1;">
                        <button onclick="testAPICoreConnection()" id="testAPICoreBtn" style="width: auto; padding: 8px 16px;">测试连接</button>
                    </div>
                    <small style="color: #666; margin-top: 5px;">💡 APICore作为备用平台，当云雾API不可用时自动切换</small>
                </div>

                <div class="input-group" id="apicoreAdvancedSettings" style="display: none;">
                    <label>APICore 高级设置:</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div style="flex: 1;">
                            <label for="apicoreSize" style="font-size: 12px;">图片尺寸:</label>
                            <select id="apicoreSize" style="width: 100%; padding: 4px;">
                                <option value="256x256">256x256</option>
                                <option value="512x512">512x512</option>
                                <option value="1024x1024" selected>1024x1024</option>
                            </select>
                        </div>
                        <div style="flex: 1;">
                            <label for="apicoreQuality" style="font-size: 12px;">图片质量:</label>
                            <select id="apicoreQuality" style="width: 100%; padding: 4px;">
                                <option value="standard">标准</option>
                                <option value="hd" selected>高清</option>
                            </select>
                        </div>
                        <button onclick="toggleAPICoreSettings()" style="background-color: #fa8c16; padding: 4px 8px; font-size: 12px;">隐藏设置</button>
                    </div>
                </div>

                <div style="text-align: center; margin: 10px 0;">
                    <button onclick="toggleAPICoreSettings()" id="showAPICoreSettingsBtn" style="background-color: #52c41a; padding: 6px 12px; font-size: 12px;">显示APICore高级设置</button>
                </div>

                <div class="inline-control">
                    <label for="imageCount">生成数量:</label>
                    <input type="number" id="imageCount" min="1" max="10" value="1">
                    <span>张图片 (每个提示词)</span>
                </div>

                <div class="button-group">
                    <button onclick="generateAllImagesMultiPlatform()" id="generateBtn">批量生成图片 (多平台)</button>
                    <button onclick="downloadAllImages()" id="downloadBtn" class="download" style="display: none;">保存所有图片</button>
                    <button onclick="diagnoseNetwork()" id="diagnoseBtn" style="background-color: #fa8c16;">网络诊断</button>
                </div>
            </div>
        </div>
        
        <!-- 故事提示词标签页 -->
        <div id="storyPrompt" class="tab-content">
            <!-- 使用提示 -->
            <div style="background-color: #fff2e8; border: 1px solid #ffbb96; border-radius: 6px; padding: 16px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #fa8c16;">📖 故事提示词功能说明</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li><strong>AI生成故事</strong>：通过元提示词+目录图片自动生成故事分镜脚本</li>
                    <li><strong>CSV导入</strong>：支持导入现有的故事脚本文件，包含分镜序号和文生图prompt</li>
                    <li><strong>参考图片</strong>：为每个分镜指定参考图片，系统会自动匹配或手动选择</li>
                    <li><strong>批量生成</strong>：一键生成整个故事的所有分镜图片</li>
                    <li><strong>🔑 API配置</strong>：图片生成使用"图转提示词"页面的API配置（支持云雾API + APICore双平台）</li>
                </ul>
            </div>
            
            <!-- AI 故事生成器 -->
            <div class="control-group">
                <h3>🤖 AI 故事生成器</h3>
                
                <div class="input-group">
                    <label for="storyMetaPrompt">故事元提示词:</label>
                    <textarea id="storyMetaPrompt" placeholder="描述你想要生成的故事类型、风格、主题等...">请根据提供的目录图片，为我生成一个10-15个分镜的故事脚本。每个分镜应该包含详细的文生图prompt，描述画面构图、角色、动作、环境、色彩、风格等。故事应该有明确的起承转合，情节生动有趣。

要求：
1. 每个分镜的prompt应该详细具体，包含画面的所有重要元素
2. 故事情节要连贯，有起伏和转折
3. 画面描述要生动，富有视觉冲击力
4. 风格保持一致，适合AI图像生成

请按照以下格式输出：
分镜1：[详细的文生图prompt]
分镜2：[详细的文生图prompt] 
...

开始生成故事分镜脚本：</textarea>
    </div>

    <div class="input-group">
                    <label>故事目录图片 (可选择多张图片作为故事参考):</label>
                    <div class="upload-area" onclick="document.getElementById('storyRefImageInput').click()">
            点击选择多张图片或拖拽图片到这里
                        <input type="file" id="storyRefImageInput" accept="image/*" multiple style="display: none" onchange="handleStoryRefImageUpload(event)">
                        
                        <!-- 示例图片展示 -->
                        <div style="margin-top: 15px; font-size: 14px; color: #666;">
                            💡 或点击下方示例图片快速选择：
                        </div>
                        <div class="example-images">
                            <img src="./public/咖啡杯宝宝.jpg" alt="咖啡杯宝宝" class="example-image" onclick="selectStoryExampleImage(this, './public/咖啡杯宝宝.jpg')" title="咖啡杯宝宝">
                            <img src="./public/咖啡杯妈妈.png" alt="咖啡杯妈妈" class="example-image" onclick="selectStoryExampleImage(this, './public/咖啡杯妈妈.png')" title="咖啡杯妈妈">
                            <img src="./public/卡布奇诺.png" alt="卡布奇诺" class="example-image" onclick="selectStoryExampleImage(this, './public/卡布奇诺.png')" title="卡布奇诺">
                            <img src="./public/卡布奇诺01.jpg" alt="卡布奇诺01" class="example-image" onclick="selectStoryExampleImage(this, './public/卡布奇诺01.jpg')" title="卡布奇诺01">
                            <img src="./public/橙子小孩.png" alt="橙子小孩" class="example-image" onclick="selectStoryExampleImage(this, './public/橙子小孩.png')" title="橙子小孩">
                            <img src="./public/橘子肌肉男.png" alt="橘子肌肉男" class="example-image" onclick="selectStoryExampleImage(this, './public/橘子肌肉男.png')" title="橘子肌肉男">
                            <img src="./public/木棍人2.png" alt="木棍人2" class="example-image" onclick="selectStoryExampleImage(this, './public/木棍人2.png')" title="木棍人2">
                            <img src="./public/木棍人tuntun.png" alt="木棍人tuntun" class="example-image" onclick="selectStoryExampleImage(this, './public/木棍人tuntun.png')" title="木棍人tuntun">
                        </div>
        </div>
        <div id="storyRefImagePreview"></div>
    </div>

                <button onclick="generateStoryScript()" id="generateStoryBtn" class="secondary">生成故事脚本</button>
            </div>
            
            <!-- CSV 导入功能 -->
            <div class="control-group">
                <h3>📁 CSV 故事脚本导入</h3>
                
                <div class="input-group">
                    <label>选择CSV文件 (包含分镜序号和文生图prompt):</label>
    <div class="button-group">
                        <input type="file" id="csvFileInput" accept=".csv" style="display: none" onchange="handleCsvImport(event)">
                        <button onclick="document.getElementById('csvFileInput').click()" class="file-input-button">选择CSV文件</button>
                        <span id="csvFileName">未选择文件</span>
    </div>
                    <div id="csvPreview" class="csv-preview" style="display: none;"></div>
</div>
</div>

            <!-- 故事脚本编辑器 -->
            <div class="control-group" id="storyEditorGroup" style="display: none;">
                <h3>📝 故事分镜脚本编辑器</h3>
                
                <div class="inline-control" style="margin-bottom: 15px;">
                    <label for="batchImageCount">批量生成数量:</label>
                    <input type="number" id="batchImageCount" min="1" max="10" value="2">
                    <span>张图片 (每个分镜)</span>
                    <button onclick="setBatchImageCount()" style="margin-left: 10px; background-color: #52c41a; color: white;">📋 应用到所有分镜</button>
                    <small style="color: #666; margin-left: 10px;">💡 设置每个分镜生成的图片数量</small>
    </div>

                <div class="button-group" style="margin-bottom: 15px;">
                    <button onclick="generateAllStoryImagesMultiPlatform()" id="generateAllStoryBtn" class="secondary">🎬 一键生成整个故事 (多平台)</button>
                    <button onclick="downloadAllStoryImages()" id="downloadAllStoryBtn" class="download" style="display: none;">保存所有图片</button>
                    <button onclick="clearStoryHistory()" id="clearHistoryBtn" style="background-color: #ff4d4f; color: white;">🗑️ 清空历史</button>
                    <button onclick="exportStoryToCsv()" id="exportStoryBtn" style="background-color: #722ed1; color: white;">📄 导出CSV</button>
    </div>

                <div id="storyScriptEditor"></div>
    </div>
</div>

        <div class="result" id="result"></div>
        
        <!-- 调试日志区域 -->
        <div style="margin-top: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #333;">🔍 调试日志</h3>
                <div>
                    <button onclick="clearDebugLog()" style="background-color: #ff4d4f; color: white; padding: 5px 10px; font-size: 12px;">清空日志</button>
                    <button onclick="copyDebugLog()" style="background-color: #52c41a; color: white; padding: 5px 10px; font-size: 12px; margin-left: 5px;">复制日志</button>
                </div>
            </div>
            <div class="debug" id="debug">等待操作...</div>
        </div>
</div>

<script>
        // 原有变量
        let refImages = [];
        let promptsData = [];
        let generatedImages = [];
        
        // 故事相关变量
        let storyRefImages = [];
        let storyScript = [];
        let storyGeneratedImages = [];
        
        // 标签页切换功能
        function switchTab(tabName, clickedElement) {
            console.log('🔄 switchTab called with:', tabName, clickedElement);
            
            // 隐藏所有标签页内容
            const tabContents = document.querySelectorAll('.tab-content');
            console.log('📋 Found tab contents:', tabContents.length);
            tabContents.forEach(content => {
                console.log('🔄 Removing active from:', content.id);
                content.classList.remove('active');
            });
            
            // 移除所有标签按钮的active状态
            const tabButtons = document.querySelectorAll('.tab-button');
            console.log('🔘 Found tab buttons:', tabButtons.length);
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // 显示选中的标签页内容
            const targetTab = document.getElementById(tabName);
            console.log('🎯 Target tab:', targetTab);
            if (targetTab) {
                targetTab.classList.add('active');
                console.log('✅ Added active to:', tabName);
            } else {
                console.error('❌ Target tab not found:', tabName);
            }
            
            // 设置对应按钮为active状态
            if (clickedElement) {
                clickedElement.classList.add('active');
                console.log('✅ Added active to clicked element');
            } else {
                // 如果没有传入元素，通过tabName找到对应的按钮
                const targetButton = document.querySelector(`[onclick*="${tabName}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                    console.log('✅ Added active to target button');
                } else {
                    console.error('❌ Target button not found for:', tabName);
                }
            }
        }
        
        // 调试日志管理函数
        function clearDebugLog() {
            const debug = document.getElementById('debug');
            debug.textContent = '日志已清空，等待新的操作...';
            console.log('🧹 Debug log cleared');
        }
        
        function copyDebugLog() {
            const debug = document.getElementById('debug');
            const logContent = debug.textContent;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(logContent).then(() => {
                    alert('调试日志已复制到剪贴板');
                }).catch(err => {
                    console.error('复制失败:', err);
                    fallbackCopyTextToClipboard(logContent);
                });
            } else {
                fallbackCopyTextToClipboard(logContent);
            }
        }
        
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                alert('调试日志已复制到剪贴板');
            } catch (err) {
                alert('复制失败，请手动选择日志内容复制');
            }
            
            document.body.removeChild(textArea);
        }
        
        // 增强的错误日志格式化函数
        function logError(requestId, errorType, errorMessage, additionalInfo = {}) {
            const debug = document.getElementById('debug');
            const timestamp = new Date().toLocaleTimeString();
            
            debug.textContent += `\n\n🚨 [${timestamp}] [${requestId}] ${errorType}`;
            debug.textContent += `\n❌ 错误信息: ${errorMessage}`;
            
            if (additionalInfo.apiResponse) {
                debug.textContent += `\n📄 API响应: ${JSON.stringify(additionalInfo.apiResponse, null, 2)}`;
            }
            
            if (additionalInfo.requestData) {
                debug.textContent += `\n📤 请求数据: ${JSON.stringify(additionalInfo.requestData, null, 2)}`;
            }
            
            if (additionalInfo.refImageInfo) {
                debug.textContent += `\n🖼️ 垫图信息: ${additionalInfo.refImageInfo}`;
            }
            
            if (additionalInfo.stack) {
                debug.textContent += `\n📚 错误堆栈: ${additionalInfo.stack}`;
            }
            
            debug.textContent += `\n${'='.repeat(80)}`;
            
            // 自动滚动到底部
            debug.scrollTop = debug.scrollHeight;
        }
        
        // 增强的成功日志格式化函数
        function logSuccess(requestId, message, additionalInfo = {}) {
            const debug = document.getElementById('debug');
            const timestamp = new Date().toLocaleTimeString();
            
            debug.textContent += `\n\n✅ [${timestamp}] [${requestId}] ${message}`;
            
            if (additionalInfo.imageUrl) {
                debug.textContent += `\n🔗 图片URL: ${additionalInfo.imageUrl.substring(0, 100)}...`;
            }
            
            if (additionalInfo.refImageUsed) {
                debug.textContent += `\n🖼️ 垫图状态: ✅ 已使用`;
            } else {
                debug.textContent += `\n🖼️ 垫图状态: ❌ 未使用`;
            }
            
            debug.textContent += `\n${'='.repeat(80)}`;
            
            // 自动滚动到底部
            debug.scrollTop = debug.scrollHeight;
        }
        
        // 选择故事示例图片的函数
        function selectStoryExampleImage(imgElement, imagePath) {
            // 移除其他图片的选中状态
            document.querySelectorAll('.example-image').forEach(img => {
                img.classList.remove('selected');
            });
            
            // 添加选中状态
            imgElement.classList.add('selected');
            
            // 将示例图片转换为base64并添加到storyRefImages
            fetch(imagePath)
                .then(response => response.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const imageName = imagePath.split('/').pop();
                        
                        // 压缩图片
                        compressImage(blob, (compressedDataUrl) => {
                            storyRefImages.push({
                                data: compressedDataUrl,
                                name: imageName
                            });
                            displayStoryRefImages();
                        });
                    };
                    reader.readAsDataURL(blob);
                })
                .catch(error => {
                    console.error('加载故事示例图片失败:', error);
                    alert('加载示例图片失败，请尝试上传本地图片');
                });
        }

        // 故事参考图片上传处理
        function handleStoryRefImageUpload(event) {
            const files = Array.from(event.target.files);
            storyRefImages = [];
            
            files.forEach((file, index) => {
                compressImage(file, (compressedDataUrl) => {
                    storyRefImages.push({
                        data: compressedDataUrl,
                        name: file.name
                    });
                    
                    if (index === files.length - 1) {
                        displayStoryRefImages();
                    }
                });
            });
        }
        
        function displayStoryRefImages() {
            const preview = document.getElementById('storyRefImagePreview');
            preview.innerHTML = storyRefImages.map((img, index) => 
                `<img src="${img.data}" alt="Story Reference ${index + 1}" class="image-preview" title="${img.name}">`
            ).join('');
        }
        
        // CSV文件导入处理
        function handleCsvImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('csvFileName').textContent = file.name;
            
            // 尝试检测编码并读取文件
            tryReadCsvWithEncoding(file);
        }
        
        function tryReadCsvWithEncoding(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                
                // 检查是否包含乱码或无效字符
                if (isValidUTF8Text(csvText)) {
                    console.log('使用UTF-8编码成功读取CSV文件');
                    parseCsvAndDisplayPreview(csvText);
                } else {
                    console.log('UTF-8编码读取异常，尝试ANSI编码...');
                    // UTF-8失败，尝试GBK编码 (常用于ANSI中文)
                    tryReadWithGBK(file);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }
        
        function parseCsvAndDisplayPreview(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const preview = document.getElementById('csvPreview');
            const storyEditorGroup = document.getElementById('storyEditorGroup');
            
            // 解析CSV
            storyScript = [];
            const headers = lines[0].split(',');
            
            // 找到分镜序号和文生图prompt的列索引
            const indexCol = headers.findIndex(h => h.includes('分镜序号') || h.includes('序号'));
            const promptCol = headers.findIndex(h => h.includes('文生图prompt') || h.includes('prompt'));
            
            if (indexCol === -1 || promptCol === -1) {
                alert('CSV文件格式不正确，请确保包含"分镜序号"和"文生图prompt"列');
                return;
            }
            
            // 解析数据行
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length > Math.max(indexCol, promptCol)) {
                    storyScript.push({
                        index: values[indexCol]?.trim() || (i).toString(),
                        prompt: values[promptCol]?.trim() || '',
                        refImages: [], // 初始为空，用户可以手动指定
                        imageCount: 1
                    });
                }
            }
            
            // 显示预览
            preview.style.display = 'block';
            preview.innerHTML = `
                <h4>CSV预览 (共${storyScript.length}个分镜):</h4>
                <div style="max-height: 150px; overflow-y: auto;">
                    ${storyScript.slice(0, 5).map(item => 
                        `<div><strong>分镜${item.index}:</strong> ${item.prompt.substring(0, 100)}${item.prompt.length > 100 ? '...' : ''}</div>`
                    ).join('')}
                    ${storyScript.length > 5 ? '<div><em>... 还有更多分镜</em></div>' : ''}
                </div>
            `;
            
            // 显示编辑器
            displayStoryEditor();
            storyEditorGroup.style.display = 'block';
        }
        
        // 生成AI故事脚本
        async function generateStoryScript() {
        const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const metaPrompt = document.getElementById('storyMetaPrompt').value;
            const generateStoryBtn = document.getElementById('generateStoryBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey || !metaPrompt) {
                alert('请输入 OpenRouter API Key 和故事元提示词');
                return;
            }

            generateStoryBtn.disabled = true;
            generateStoryBtn.textContent = '生成中...';
            debug.textContent = '正在生成故事脚本...\n';

            try {
                const messages = [
                    {
                        role: "user",
                        content: metaPrompt
                    }
                ];
                
                // 如果有参考图片，添加到消息中
                if (storyRefImages.length > 0) {
                    messages[0].content = [
                        {
                            type: "text",
                            text: metaPrompt
                        },
                        ...storyRefImages.map(img => ({
                            type: "image_url",
                            image_url: {
                                url: img.data
                            }
                        }))
                    ];
                }

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Sora Image Demo'
                },
                body: JSON.stringify({
                        model: model,
                        messages: messages,
                        max_tokens: 2000
                })
            });

                const data = await response.json();
                debug.textContent += `API 响应状态: ${response.status}\n`;
                
                if (response.ok && data.choices && data.choices.length > 0) {
                    const storyText = data.choices[0]?.message?.content;
                    parseStoryScript(storyText);
                    debug.textContent += `✅ 故事脚本生成成功！`;
            } else {
                    debug.textContent += `❌ API 请求失败: ${data.error?.message || '未知错误'}`;
                    alert('故事生成失败，请查看调试信息');
            }
                
        } catch (error) {
                debug.textContent += `❌ 发生错误: ${error.message}`;
                alert(`发生错误：${error.message}`);
        } finally {
                generateStoryBtn.disabled = false;
                generateStoryBtn.textContent = '生成故事脚本';
            }
        }
        
        function parseStoryScript(storyText) {
            // 解析AI生成的故事文本
            const lines = storyText.split('\n').filter(line => line.trim());
            storyScript = [];
            
            let currentIndex = 1;
            for (const line of lines) {
                // 匹配类似 "分镜1："、"分镜 1："、"1."、"第1个分镜" 等格式
                const match = line.match(/(?:分镜|第)?\s*(\d+)(?:个分镜)?[：:\.]\s*(.+)/);
                if (match) {
                    storyScript.push({
                        index: match[1],
                        prompt: match[2].trim(),
                        refImages: [],
                        imageCount: 1
                    });
                } else if (line.trim() && !line.includes('分镜') && storyScript.length > 0) {
                    // 可能是续行的描述
                    storyScript[storyScript.length - 1].prompt += ' ' + line.trim();
                }
            }
            
            // 如果解析失败，尝试按段落分割
            if (storyScript.length === 0) {
                const paragraphs = storyText.split('\n\n').filter(p => p.trim());
                paragraphs.forEach((paragraph, index) => {
                    if (paragraph.trim()) {
                        storyScript.push({
                            index: (index + 1).toString(),
                            prompt: paragraph.trim(),
                            refImages: [],
                            imageCount: 1
                        });
                    }
                });
            }
            
            displayStoryEditor();
            document.getElementById('storyEditorGroup').style.display = 'block';
        }
        
        // 显示故事编辑器
        function displayStoryEditor() {
            const editor = document.getElementById('storyScriptEditor');
            editor.innerHTML = storyScript.map((item, index) => `
                <div class="story-item" id="storyItem_${index}">
                    <div class="story-index">分镜<br>${item.index}</div>
                    <div class="story-prompt">
                        <textarea id="storyPrompt_${index}" placeholder="分镜提示词...">${item.prompt}</textarea>
                        <div class="story-ref-images" id="storyRefImages_${index}">
                            ${item.refImages.map((img, imgIndex) => 
                                `<img src="${img.data}" title="${img.name}" onclick="removeStoryRefImage(${index}, ${imgIndex})" class="selected">`
                            ).join('')}
                            <div style="padding: 20px; border: 1px dashed #ddd; cursor: pointer; font-size: 12px; text-align: center; min-width: 60px;" 
                                 onclick="selectStoryRefImage(${index})">
                                点击选择<br>参考图片
                            </div>
                        </div>
                    </div>
                    <div class="story-controls">
                        <div class="inline-control">
                            <label>数量:</label>
                            <input type="number" id="storyImageCount_${index}" min="1" max="10" value="${item.imageCount}" 
                                   onchange="updateStoryImageCount(${index})">
                        </div>
                        <div class="button-group">
                            <button onclick="generateSingleStoryImage(${index})" class="secondary">生成图片</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        // 选择故事参考图片
        function selectStoryRefImage(storyIndex) {
            if (storyRefImages.length === 0) {
                alert('请先在上方上传故事参考图片');
                return;
            }
            
            // 创建图片选择弹窗
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 1000; display: flex; 
                justify-content: center; align-items: center;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 8px; max-width: 98%; max-height: 90%; overflow-y: auto; min-height: 70vh;">
                    <h3>选择参考图片 (单击多选，双击快速确认)</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        ${storyRefImages.map((img, index) => `
                            <div style="text-align: center; cursor: pointer; border: 2px solid transparent; padding: 5px;" 
                                 onclick="toggleImageSelection(this, ${index})" 
                                 ondblclick="quickSelectImage(${storyIndex}, ${index})" 
                                 id="selectImg_${index}">
                                <img src="${img.data}" style="width: 140px; height: 140px; object-fit: cover; border-radius: 4px;">
                                <div style="font-size: 12px; margin-top: 5px; word-wrap: break-word; max-width: 140px;">${img.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="text-align: center; gap: 10px; display: flex; justify-content: center;">
                        <button onclick="confirmImageSelection(${storyIndex})" class="secondary">确认选择</button>
                        <button onclick="closeImageSelection()">取消</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            window.currentModal = modal;
            window.selectedImages = [];
        }
        
        function toggleImageSelection(element, imageIndex) {
            if (element.style.borderColor === 'rgb(24, 144, 255)') {
                element.style.borderColor = 'transparent';
                window.selectedImages = window.selectedImages.filter(i => i !== imageIndex);
            } else {
                element.style.borderColor = '#1890ff';
                window.selectedImages.push(imageIndex);
            }
        }
        
        // 双击快速选择图片并确认
        function quickSelectImage(storyIndex, imageIndex) {
            // 清除当前所有选择
            window.selectedImages = [];
            // 清除所有图片的选中状态
            document.querySelectorAll('[id^="selectImg_"]').forEach(el => {
                el.style.borderColor = 'transparent';
            });
            
            // 选中当前双击的图片
            window.selectedImages = [imageIndex];
            const element = document.getElementById(`selectImg_${imageIndex}`);
            if (element) {
                element.style.borderColor = '#1890ff';
            }
            
            // 直接确认选择
            confirmImageSelection(storyIndex);
        }
        
        function confirmImageSelection(storyIndex) {
            if (window.selectedImages.length === 0) {
                alert('请选择至少一张参考图片');
                return;
            }
            
            storyScript[storyIndex].refImages = window.selectedImages.map(i => storyRefImages[i]);
            displayStoryEditor();
            closeImageSelection();
        }
        
        function closeImageSelection() {
            if (window.currentModal) {
                document.body.removeChild(window.currentModal);
                window.currentModal = null;
                window.selectedImages = [];
            }
        }
        
        function removeStoryRefImage(storyIndex, imgIndex) {
            storyScript[storyIndex].refImages.splice(imgIndex, 1);
            displayStoryEditor();
        }
        
        function updateStoryImageCount(storyIndex) {
            const count = parseInt(document.getElementById(`storyImageCount_${storyIndex}`).value);
            storyScript[storyIndex].imageCount = count;
        }
        
        function setBatchImageCount() {
            const batchCount = parseInt(document.getElementById('batchImageCount').value);
            storyScript.forEach((item, index) => {
                item.imageCount = batchCount;
                document.getElementById(`storyImageCount_${index}`).value = batchCount;
            });
        }
        
        // 生成单个故事分镜图片
        async function generateSingleStoryImage(storyIndex) {
            const apiKey = document.getElementById('apiKey').value;
            const item = storyScript[storyIndex];
            const promptText = document.getElementById(`storyPrompt_${storyIndex}`).value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('请输入云雾 API Key');
                return;
            }
            
            if (!promptText.trim()) {
                alert('请输入提示词');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '生成中...';
            button.disabled = true;
            
            try {
                debug.textContent += `\n正在生成分镜${item.index}的图片...`;
                debug.textContent += `\n📝 提示词: ${promptText.substring(0, 100)}...`;
                debug.textContent += `\n🖼️ 垫图数量: ${item.refImages ? item.refImages.length : 0}`;
                
                // 为每个数量生成图片
                const promises = [];
                for (let i = 0; i < item.imageCount; i++) {
                    // 🔧 修复：使用所有配置的垫图，而不是只用第一张
                    const refImageDataArray = item.refImages && item.refImages.length > 0 
                        ? item.refImages.map(refImg => refImg.data) 
                        : [];
                    
                    if (refImageDataArray.length > 0) {
                        const refImageNames = item.refImages.map(img => img.name).join(', ');
                        debug.textContent += `\n🖼️ 第${i + 1}张将使用垫图: ${refImageNames} (共${refImageDataArray.length}张)`;
                    } else {
                        debug.textContent += `\n📝 第${i + 1}张将纯文本生成`;
                    }
                    
                    promises.push(generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, storyIndex, i));
                }
                
                const results = await Promise.allSettled(promises);
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        storyGeneratedImages.push(result.value);
                        debug.textContent += `\n✅ 分镜${item.index}第${index + 1}张图片生成成功`;
                    } else {
                        debug.textContent += `\n❌ 分镜${item.index}第${index + 1}张图片生成失败: ${result.reason}`;
                    }
                });
                
                updateStoryResult();
                
            } catch (error) {
                debug.textContent += `\n❌ 生成错误: ${error.message}`;
                alert(`生成失败：${error.message}`);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // 单个故事图片生成请求
        async function generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, storyIndex, imageIndex) {
            const debug = document.getElementById('debug');
            
            // 获取垫图文件名用于日志
            const storyItem = storyScript[storyIndex];
            const refImageNames = (storyItem.refImages && storyItem.refImages.length > 0) 
                ? storyItem.refImages.map(img => img.name).join(', ')
                : '无垫图';
            const refImageCount = storyItem.refImages ? storyItem.refImages.length : 0;
            const requestId = `故事${storyItem.index}-${imageIndex + 1}`;
            
            debug.textContent += `\n\n🔍 [${requestId}] 开始处理故事图片生成请求`;
            debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageNames} (共${refImageCount}张)`;
            
            // 🔧 修复：检查多张垫图数据状态
            debug.textContent += `\n🔍 [${requestId}] 垫图数据检查:`;
            debug.textContent += `\n   - refImageDataArray类型: ${typeof refImageDataArray}`;
            debug.textContent += `\n   - refImageDataArray是否为数组: ${Array.isArray(refImageDataArray)}`;
            debug.textContent += `\n   - 垫图数量: ${refImageDataArray.length}`;
            
            // 验证所有垫图数据
            const validRefImages = [];
            if (refImageDataArray && refImageDataArray.length > 0) {
                for (let i = 0; i < refImageDataArray.length; i++) {
                    const refImageData = refImageDataArray[i];
                    debug.textContent += `\n   - 垫图${i + 1}数据长度: ${refImageData ? refImageData.length : 0} 字符`;
                    
                    if (refImageData) {
                        debug.textContent += `\n   - 垫图${i + 1}数据开头: ${refImageData.substring(0, 30)}...`;
                        debug.textContent += `\n   - 垫图${i + 1}是否为data:image格式: ${refImageData.startsWith('data:image/')}`;
                        
                        // 检查base64部分
                        const parts = refImageData.split(',');
                        if (parts.length === 2) {
                            const base64Part = parts[1];
                            debug.textContent += `\n   - 垫图${i + 1} base64部分长度: ${base64Part.length} 字符`;
                            debug.textContent += `\n   - 垫图${i + 1} 估算图片大小: ${Math.round(base64Part.length * 0.75 / 1024)}KB`;
                        }
                        
                        // 验证当前垫图
                        if (validateRefImageData(refImageData, `[${requestId}] 垫图${i + 1}`)) {
                            validRefImages.push(refImageData);
                        }
                    }
                }
            }
            
            debug.textContent += `\n✅ [${requestId}] 有效垫图数量: ${validRefImages.length}/${refImageDataArray.length}`;
            
            // 构建消息内容
            let messageContent;
            if (validRefImages.length > 0) {
                // 🔧 修复：支持多张垫图的情况
                const imageUrlItems = validRefImages.map(imgData => ({
                    "type": "image_url",
                    "image_url": {
                        "url": imgData
                    }
                }));
                
                messageContent = [
                    {
                        "type": "text",
                        "text": promptText
                    },
                    ...imageUrlItems
                ];
                
                debug.textContent += `\n🖼️ [${requestId}] 使用垫图生成模式 (${validRefImages.length}张垫图)`;
                debug.textContent += `\n📋 [${requestId}] 消息内容包含: 文本 + ${validRefImages.length}张图片URL`;
                debug.textContent += `\n🎯 [${requestId}] 垫图文件: ${refImageNames}`;
            } else {
                // 没有垫图或垫图无效的情况
                messageContent = promptText;
                debug.textContent += `\n📝 [${requestId}] 纯文本生成模式 (垫图无效或缺失)`;
                debug.textContent += `\n📋 [${requestId}] 消息内容: 仅文本`;
                debug.textContent += `\n⚠️ [${requestId}] 垫图文件: ${refImageNames} (未使用)`;
            }
            
            const messages = [
                {
                    role: "system",
                    content: "You are a helpful assistant."
                },
                {
                    role: "user",
                    content: messageContent
                }
            ];

            debug.textContent += `\n🚀 [${requestId}] 准备发送API请求...`;
            debug.textContent += `\n📦 [${requestId}] 请求体大小: ${JSON.stringify(messages).length} 字符`;
            
            // 记录请求详情（不包含完整的base64数据，避免日志过长）
            if (validRefImages.length > 0) {
                debug.textContent += `\n📷 [${requestId}] 请求包含图片: ${refImageNames}`;
                debug.textContent += `\n🔗 [${requestId}] 图片URL类型: ${validRefImages[0].substring(0, 20)}... (等${validRefImages.length}张)`;
            }
            
            try {
                const response = await fetch('https://yunwu.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "sora_image",
                        messages: messages
                    })
                });

                debug.textContent += `\n📊 [${requestId}] API响应状态: ${response.status}`;

                if (!response.ok) {
                    const errorText = await response.text();
                    debug.textContent += `\n❌ [${requestId}] API响应错误: ${response.status} ${response.statusText}`;
                    debug.textContent += `\n❌ [${requestId}] 错误详情: ${errorText}`;
                    debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${validRefImages.length > 0 ? '已使用' : '未使用'}`;
                    debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageNames}`;
                    throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                debug.textContent += `\n✅ [${requestId}] API调用成功`;
                debug.textContent += `\n📄 [${requestId}] 完整响应内容: \`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``;
                
                // 进行API响应格式诊断
                const responseFormat = diagnoseApiResponse(data, requestId);
                
                // 适应新的响应格式处理逻辑
                let imageUrl = null;
                
                // 方法1：检查传统格式 (choices[0].message.content)
                const content = data.choices?.[0]?.message?.content;
                if (content) {
                    imageUrl = extractImageUrl(content);
                    if (imageUrl) {
                        debug.textContent += `\n✅ [${requestId}] 从传统格式提取到图片URL`;
                    }
                }
                
                // 方法2：检查新格式 - 直接在响应中查找图片URL
                if (!imageUrl) {
                    // 检查响应中是否直接包含图片URL字段
                    if (data.image_url) {
                        imageUrl = data.image_url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(image_url字段)提取到图片URL`;
                    } else if (data.url) {
                        imageUrl = data.url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(url字段)提取到图片URL`;
                    } else if (data.result && data.result.url) {
                        imageUrl = data.result.url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(result.url字段)提取到图片URL`;
                    }
                }
                
                // 方法3：检查是否为异步响应格式
                if (!imageUrl) {
                    // 检查是否有任务ID或其他异步标识
                    if (data.task_id || data.id || data.prompt) {
                        debug.textContent += `\n⏳ [${requestId}] 检测到异步响应格式`;
                        debug.textContent += `\n📋 [${requestId}] 响应参数确认: ${JSON.stringify(data)}`;
                        
                        // 显示格式变化提示
                        if (responseFormat === 'async_params') {
                            showApiFormatChangeNotice();
                        }
                        
                        // 对于异步API，我们需要等待并轮询结果
                        debug.textContent += `\n⏳ [${requestId}] 检测到云雾API异步模式，开始轮询结果`;
                        
                        // 获取任务ID
                        const taskId = data.task_id || data.id || data.prompt;
                        debug.textContent += `\n🔑 [${requestId}] 任务ID: ${taskId}`;
                        
                        // 轮询任务结果
                        try {
                            const pollResult = await pollTaskResult(apiKey, taskId, requestId);
                            if (pollResult && pollResult.imageUrl) {
                                imageUrl = pollResult.imageUrl;
                                debug.textContent += `\n✅ [${requestId}] 异步轮询成功获取图片URL`;
                            } else {
                                throw new Error('轮询任务结果失败');
                            }
                        } catch (pollError) {
                            debug.textContent += `\n❌ [${requestId}] 轮询任务失败: ${pollError.message}`;
                            throw new Error(`异步API轮询失败: ${pollError.message}`);
                        }
                    }
                }
                
                // 方法4：尝试在响应文本中查找任何HTTP URL
                if (!imageUrl) {
                    const responseText = JSON.stringify(data);
                    const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                    const urls = responseText.match(urlRegex);
                    if (urls && urls.length > 0) {
                        imageUrl = urls[0];
                        debug.textContent += `\n✅ [${requestId}] 通过正则表达式在响应中找到图片URL`;
                    }
                }
                
                if (!imageUrl) {
                    debug.textContent += `\n❌ [${requestId}] 所有方法都无法提取图片URL`;
                    debug.textContent += `\n📄 [${requestId}] 响应数据结构: ${Object.keys(data).join(', ')}`;
                    debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${hasValidRefImage ? '已使用' : '未使用'}`;
                    debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageNames}`;
                    
                    // 提供更详细的错误信息
                    const errorDetails = {
                        responseStructure: Object.keys(data),
                        hasChoices: !!data.choices,
                        hasContent: !!(data.choices?.[0]?.message?.content),
                        responseData: data
                    };
                    
                    throw new Error(`未能从响应中提取图片URL。响应格式可能已变化。详情: ${JSON.stringify(errorDetails, null, 2)}`);
                }

                debug.textContent += `\n🎉 [${requestId}] 故事图片生成成功!`;
                debug.textContent += `\n🔗 [${requestId}] 图片URL: ${imageUrl.substring(0, 50)}...`;
                debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${validRefImages.length > 0 ? '✅ 已使用' : '❌ 未使用'}`;
                debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageNames}`;
                
                return {
                    url: imageUrl,
                    prompt: promptText,
                    storyIndex: storyIndex,
                    imageIndex: imageIndex,
                    storyItemIndex: storyItem.index,
                    usedRefImage: validRefImages.length > 0,
                    refImageFile: refImageNames
                };
            } catch (error) {
                debug.textContent += `\n💥 [${requestId}] 故事生成过程出错: ${error.message}`;
                debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${validRefImages.length > 0 ? '已配置但失败' : '未使用'}`;
                debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageNames}`;
                throw error;
            }
        }
        
        // 生成所有故事图片
        async function generateAllStoryImages() {
            const apiKey = document.getElementById('apiKey').value;
            const generateAllStoryBtn = document.getElementById('generateAllStoryBtn');
            const debug = document.getElementById('debug');

            if (!apiKey) {
                alert('请输入云雾 API Key');
                return;
            }

            if (storyScript.length === 0) {
                alert('请先生成或导入故事脚本');
                return;
            }

            // 🔧 自动检查并应用批量图片数量设置
            const batchImageCount = parseInt(document.getElementById('batchImageCount').value) || 1;
            const currentImageCounts = storyScript.map(item => item.imageCount);
            const allSameCount = currentImageCounts.every(count => count === currentImageCounts[0]);
            
            // 如果用户设置的批量数量与当前分镜设置不同，自动应用
            if (!allSameCount || currentImageCounts[0] !== batchImageCount) {
                debug.textContent += `\n🔧 检测到批量设置(${batchImageCount}张)与分镜设置不一致，自动应用批量设置...`;
                setBatchImageCount();
                debug.textContent += `\n✅ 已将所有分镜的图片数量设置为: ${batchImageCount} 张`;
            }

            generateAllStoryBtn.disabled = true;
            generateAllStoryBtn.textContent = '生成中...';
            // 🔧 修复：不再重置数组，改为累积保存所有生成的图片  
            // storyGeneratedImages = [];
            
            // 记录本次生成开始前的图片数量
            const initialImageCount = storyGeneratedImages.length;

            try {
                debug.textContent += `\n\n开始批量生成故事图片，共${storyScript.length}个分镜...`;
                if (initialImageCount > 0) {
                    debug.textContent += `\n📊 已有历史图片: ${initialImageCount} 张，本次生成将累积保存`;
                }
                
                // 🔍 调用调试函数检查数据状态
                debugStoryDataState();
                
                // 统计垫图使用情况
                let totalWithRefImages = 0;
                let totalWithoutRefImages = 0;
                
                // 创建所有并发请求
                const allRequests = [];
                
                for (let i = 0; i < storyScript.length; i++) {
                    const item = storyScript[i];
                    const promptText = document.getElementById(`storyPrompt_${i}`).value;
                    
                    if (!promptText.trim()) {
                        debug.textContent += `\n⚠️ 跳过分镜${item.index}: 提示词为空`;
                        continue;
                    }
                    
                    const hasRefImages = item.refImages && item.refImages.length > 0;
                    const refImageCount = item.refImages ? item.refImages.length : 0;
                    debug.textContent += `\n📋 分镜${item.index}: ${hasRefImages ? `使用垫图 (${refImageCount}张垫图)` : '纯文本'} - 生成${item.imageCount}张图片`;
                    
                    for (let j = 0; j < item.imageCount; j++) {
                        // 🔧 修复：使用所有配置的垫图，而不是只用第一张
                        const refImageDataArray = hasRefImages 
                            ? item.refImages.map(img => img.data) 
                            : [];
                        
                        if (refImageDataArray.length > 0) {
                            totalWithRefImages++;
                        } else {
                            totalWithoutRefImages++;
                        }
                        
                        const requestPromise = generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, i, j);
                        allRequests.push(requestPromise);
                    }
                }

                debug.textContent += `\n📊 生成统计: 垫图生成${totalWithRefImages}张, 纯文本生成${totalWithoutRefImages}张`;
                debug.textContent += `\n开始并发生成 ${allRequests.length} 张图片...`;
                
                // 🔍 调试Promise.allSettled执行前状态
                debug.textContent += `\n🔍 准备执行Promise.allSettled，请求数量: ${allRequests.length}`;
                debug.textContent += `\n🔍 检查所有请求是否为Promise: ${allRequests.every(req => req && typeof req.then === 'function')}`;
                if (allRequests.length > 0) {
                    debug.textContent += `\n🔍 第一个请求类型: ${typeof allRequests[0]}`;
                    debug.textContent += `\n🔍 第一个请求有then方法: ${typeof allRequests[0].then === 'function'}`;
                }
                
                // 🔧 添加进度监控
                let completedCount = 0;
                const progressPromises = allRequests.map((promise, index) => {
                    return promise.then(
                        result => {
                            completedCount++;
                            debug.textContent += `\n📈 进度: ${completedCount}/${allRequests.length} 完成`;
                            return result;
                        },
                        error => {
                            completedCount++;
                            debug.textContent += `\n📈 进度: ${completedCount}/${allRequests.length} 完成 (第${index + 1}个失败: ${error.message})`;
                            throw error;
                        }
                    );
                });
                
                // 并发执行所有请求
                try {
                    debug.textContent += `\n🔍 开始执行Promise.allSettled...`;
                    
                    // 🔧 调整总体超时机制（10分钟）
                    const allSettledTimeout = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('批量操作超时 (10分钟)')), 10 * 60 * 1000);
                    });
                    
                    let results;
                    try {
                        results = await Promise.race([
                            Promise.allSettled(progressPromises),
                            allSettledTimeout
                        ]);
                    } catch (timeoutError) {
                        debug.textContent += `\n⚠️ 操作超时，但继续处理已完成的请求...`;
                        debug.textContent += `\n🔍 等待剩余请求完成...`;
                        
                        // 即使超时，也给一些额外时间让更多请求完成
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                        // 检查已完成的请求
                        const partialResults = [];
                        for (let i = 0; i < progressPromises.length; i++) {
                            try {
                                // 使用Promise.race快速检查是否已完成
                                const quickCheck = await Promise.race([
                                    progressPromises[i],
                                    Promise.resolve({ status: 'pending' })
                                ]);
                                if (quickCheck.status !== 'pending') {
                                    partialResults.push({ status: 'fulfilled', value: quickCheck });
                                } else {
                                    partialResults.push({ status: 'rejected', reason: '超时未完成' });
                                }
                            } catch (error) {
                                partialResults.push({ status: 'rejected', reason: error.message });
                            }
                        }
                        results = partialResults;
                        debug.textContent += `\n🔍 部分结果收集完成，共 ${results.length} 个结果`;
                    }
                    
                    debug.textContent += `\n🔍 Promise.allSettled执行完成，结果数量: ${results ? results.length : 'null'}`;
                    
                    if (!results) {
                        debug.textContent += `\n❌ 错误：Promise.allSettled返回null或undefined`;
                        return;
                    }
                    
                    // 🔍 检查results结构
                    debug.textContent += `\n🔍 results类型: ${typeof results}`;
                    debug.textContent += `\n🔍 results是否为数组: ${Array.isArray(results)}`;
                    
                    // 🔧 将结果处理移到try块内，解决作用域问题
                    // 处理结果
                    let successCount = 0;
                    let failCount = 0;
                    
                    // 🔧 修复：在循环开始前计算正确的批次编号
                    const currentBatchIndex = Math.floor(storyGeneratedImages.length / 10) + 1;
                    
                    // 🔍 添加调试信息
                    debug.textContent += `\n\n🔍 === 结果处理调试 ===`;
                    debug.textContent += `\n📊 总共收到 ${results.length} 个结果`;
                    
                    results.forEach((result, index) => {
                        // 🔍 详细调试每个结果
                        debug.textContent += `\n🔍 [结果${index + 1}] status: ${result.status}`;
                        if (result.status === 'fulfilled') {
                            debug.textContent += `\n🔍 [结果${index + 1}] value: ${result.value ? 'object' : 'null/undefined'}`;
                            if (result.value) {
                                debug.textContent += `\n🔍 [结果${index + 1}] value.url: ${result.value.url ? 'exists' : 'missing'}`;
                                debug.textContent += `\n🔍 [结果${index + 1}] value keys: ${Object.keys(result.value).join(', ')}`;
                            }
                        } else {
                            debug.textContent += `\n🔍 [结果${index + 1}] reason: ${result.reason}`;
                        }
                        
                        if (result.status === 'fulfilled' && result.value && result.value.url) {
                            // 添加批次信息和生成时间
                            const imageWithBatch = {
                                ...result.value,
                                batchIndex: currentBatchIndex, // 使用固定的批次编号
                                generateTime: new Date().toLocaleString() // 生成时间
                            };
                            storyGeneratedImages.push(imageWithBatch);
                            successCount++;
                            debug.textContent += `\n✅ 第 ${index + 1} 张图片生成成功`;
                        } else {
                            failCount++;
                            debug.textContent += `\n❌ 第 ${index + 1} 张图片生成失败: ${result.reason || '未知错误'}`;
                        }
                    });

                    debug.textContent += `\n🔍 === 结果处理完成 ===`;
                    debug.textContent += `\n📊 成功处理: ${successCount}张, 失败: ${failCount}张`;

                    updateStoryResult();
                    document.getElementById('downloadAllStoryBtn').style.display = 'inline-block';
                    
                    debug.textContent += `\n\n🎉 故事图片批量生成完成！`;
                    debug.textContent += `\n📊 本次统计: 成功${successCount}张, 失败${failCount}张`;
                    debug.textContent += `\n📊 累计总数: ${storyGeneratedImages.length}张图片 (含历史${initialImageCount}张)`;
                    debug.textContent += `\n🖼️ 其中垫图生成: ${Math.min(successCount, totalWithRefImages)}张`;
                    debug.textContent += `\n📝 其中纯文本生成: ${Math.max(0, successCount - totalWithRefImages)}张`;
                    
                } catch (promiseError) {
                    debug.textContent += `\n❌ Promise.allSettled执行出错: ${promiseError.message}`;
                    // 不要直接抛出错误，而是继续尝试处理
                    debug.textContent += `\n⚠️ 继续尝试更新界面...`;
                    updateStoryResult();
                    document.getElementById('downloadAllStoryBtn').style.display = 'inline-block';
                }
        } catch (error) {
                debug.textContent += `\n❌ 发生错误: ${error.message}`;
                alert(`发生错误：${error.message}`);
            } finally {
                generateAllStoryBtn.disabled = false;
                generateAllStoryBtn.textContent = '🎬 一键生成整个故事';
            }
        }
        
        // 更新故事结果显示
        function updateStoryResult() {
            const result = document.getElementById('result');
            const withRefImageCount = storyGeneratedImages.filter(img => img.usedRefImage).length;
            const withoutRefImageCount = storyGeneratedImages.length - withRefImageCount;
            
            // 按批次分组显示
            const groupedImages = {};
            storyGeneratedImages.forEach((img, index) => {
                const batchKey = img.batchIndex || 1;
                if (!groupedImages[batchKey]) {
                    groupedImages[batchKey] = [];
                }
                groupedImages[batchKey].push({...img, originalIndex: index});
            });
            
            result.innerHTML = `
                <h3>故事图片生成结果 (共 ${storyGeneratedImages.length} 张图片)：</h3>
                <div style="background-color: #f6ffed; border: 1px solid #b7eb8f; border-radius: 6px; padding: 10px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 8px 0; color: #52c41a;">📊 垫图使用统计</h4>
                    <p style="margin: 0;">
                        🖼️ 使用垫图生成: <strong>${withRefImageCount}</strong> 张 | 
                        📝 纯文本生成: <strong>${withoutRefImageCount}</strong> 张
                    </p>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666;">
                        💡 提示：所有历史生成的图片都会保留，可以随时下载
                    </p>
                </div>
                ${Object.keys(groupedImages).sort((a, b) => Number(b) - Number(a)).map(batchKey => `
                    <div style="border: 1px solid #d9d9d9; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: #1890ff;">
                            📦 批次 ${batchKey} (${groupedImages[batchKey].length} 张图片)
                            ${groupedImages[batchKey][0].generateTime ? `<span style="font-size: 12px; color: #666; font-weight: normal;"> - ${groupedImages[batchKey][0].generateTime}</span>` : ''}
                        </h4>
                        <div class="image-grid">
                            ${groupedImages[batchKey].map(img => `
                                <div class="image-item">
                                    <img src="${img.url}" alt="Story Image ${img.originalIndex + 1}">
                                    <div style="background-color: ${img.usedRefImage ? '#e6f7ff' : '#fff7e6'}; border: 1px solid ${img.usedRefImage ? '#91d5ff' : '#ffd591'}; border-radius: 4px; padding: 8px; margin: 8px 0;">
                                        <div style="font-size: 12px; color: ${img.usedRefImage ? '#1890ff' : '#fa8c16'}; font-weight: bold;">
                                            ${img.usedRefImage ? '🖼️ 垫图生成' : '📝 纯文本生成'}
                                        </div>
                                        <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                            分镜${img.storyItemIndex} - 第${img.imageIndex + 1}张
                                        </div>
                                    </div>
                                    <p><strong>分镜${img.storyItemIndex}:</strong> ${img.prompt.substring(0, 100)}...</p>
                                    <div class="image-controls">
                                        <button class="btn-download" onclick="downloadSingleStoryImage(${img.originalIndex}, this)">下载</button>
                                        <button class="btn-copy" onclick="copyStoryImageUrl(${img.originalIndex}, this)">复制URL</button>
                                        <button class="btn-retry" onclick="retrySingleStoryImage(${img.originalIndex}, this)">重试</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
            `;
        }
        
        // 下载单张故事图片
        async function downloadSingleStoryImage(index, buttonElement) {
            const img = storyGeneratedImages[index];
            const filename = `story_${img.storyItemIndex}_${img.imageIndex + 1}.jpg`;
            const debug = document.getElementById('debug');

            // 安全获取按钮元素
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // 如果无法获取event.target，尝试其他方式
                    button = document.querySelector(`[onclick*="downloadSingleStoryImage(${index})"]`);
                }
            }

            try {
                debug.textContent += `\n正在下载: ${filename}`;
                const success = await downloadImageWithRetry(img.url, filename, 3);
                
                if (success) {
                    debug.textContent += ` ✅ 下载成功`;
                    // 安全更新按钮状态
                    if (button) {
                        button.textContent = '已下载';
                        button.style.backgroundColor = '#95de64';
                        button.disabled = true;
                        setTimeout(() => {
                            button.textContent = '下载';
                            button.style.backgroundColor = '#52c41a';
                            button.disabled = false;
                        }, 2000);
                    }
                } else {
                    debug.textContent += ` ❌ 下载失败`;
                    alert('下载失败，请检查网络连接或尝试复制URL手动下载');
                }
            } catch (error) {
                debug.textContent += ` ❌ 下载错误: ${error.message}`;
                alert(`下载失败：${error.message}`);
            }
        }
        
        // 复制故事图片URL
        async function copyStoryImageUrl(index, buttonElement) {
            const img = storyGeneratedImages[index];
            const debug = document.getElementById('debug');
            
            // 安全获取按钮元素
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // 如果无法获取event.target，尝试其他方式
                    button = document.querySelector(`[onclick*="copyStoryImageUrl(${index})"]`);
                }
            }
            
            try {
                await navigator.clipboard.writeText(img.url);
                debug.textContent += `\n已复制分镜${img.storyItemIndex}第${img.imageIndex + 1}张图片的URL到剪贴板`;
                
                // 安全更新按钮状态
                if (button) {
                    button.textContent = '已复制';
                    button.style.backgroundColor = '#95de64';
                    setTimeout(() => {
                        button.textContent = '复制URL';
                        button.style.backgroundColor = '#1890ff';
                    }, 1500);
                }
            } catch (error) {
                // 如果clipboard API不可用，使用备用方法
                const textArea = document.createElement('textarea');
                textArea.value = img.url;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    debug.textContent += `\n已复制分镜${img.storyItemIndex}第${img.imageIndex + 1}张图片的URL到剪贴板`;
                    alert('URL已复制到剪贴板！');
                } catch (err) {
                    debug.textContent += `\n复制失败: ${err.message}`;
                    alert(`复制失败，请手动复制：${img.url}`);
                }
                document.body.removeChild(textArea);
            }
        }
        
        // 重新生成单张故事图片
        async function retrySingleStoryImage(index, buttonElement = null) {
            const img = storyGeneratedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('请输入云雾 API Key');
                return;
            }
            
            // 安全获取按钮元素 - 优先使用传入的buttonElement
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // 如果无法获取event.target，尝试其他方式
                    const buttons = document.querySelectorAll(`[onclick*="retrySingleStoryImage(${index})"]`);
                    button = buttons[0] || null;
                }
            }
            
            if (!button) {
                debug.textContent += ` ❌ 无法找到重试按钮`;
                alert('无法找到按钮元素，请刷新页面重试');
                return;
            }
            
            const originalText = button.textContent;
            button.textContent = '重试中...';
            button.disabled = true;
            
            try {
                debug.textContent += `\n重新生成分镜${img.storyItemIndex}第${img.imageIndex + 1}张图片...`;
                
                const item = storyScript[img.storyIndex];
                // 🔧 修复：使用所有配置的垫图，而不是只用第一张
                const refImageDataArray = item.refImages && item.refImages.length > 0 
                    ? item.refImages.map(refImg => refImg.data) 
                    : [];
                
                const newImage = await generateSingleStoryImageRequest(
                    apiKey, 
                    img.prompt, 
                    refImageDataArray, 
                    img.storyIndex, 
                    img.imageIndex
                );
                
                if (newImage) {
                    // 更新图片数据
                    storyGeneratedImages[index] = newImage;
                    
                    // 重新渲染整个结果区域而不是只更新单个图片元素
                    updateStoryResult();
                    
                    debug.textContent += ` ✅ 重新生成成功`;
                    
                    // 显示成功反馈
                    button.textContent = '生成成功';
                        button.style.backgroundColor = '#95de64';
                    
                    // 延迟恢复按钮状态
                        setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                            button.disabled = false;
                        }, 2000);
                    
                } else {
                    debug.textContent += ` ❌ 重新生成失败`;
                    button.textContent = originalText;
                    button.disabled = false;
                    throw new Error('生成失败');
                }
                
            } catch (error) {
                debug.textContent += ` ❌ 重新生成错误: ${error.message}`;
                alert(`重新生成失败：${error.message}`);
                
                // 错误时立即恢复按钮状态
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // 下载所有故事图片
        async function downloadAllStoryImages() {
            const downloadBtn = document.getElementById('downloadAllStoryBtn');
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = '下载中...';

            let successCount = 0;
            let failedDownloads = [];

            try {
                debug.textContent += '\n\n开始批量下载所有故事图片...';
                
                // 分批下载，每批3张图片
                const batchSize = 3;
                const totalBatches = Math.ceil(storyGeneratedImages.length / batchSize);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIndex = batchIndex * batchSize;
                    const endIndex = Math.min(startIndex + batchSize, storyGeneratedImages.length);
                    const currentBatch = storyGeneratedImages.slice(startIndex, endIndex);
                    
                    debug.textContent += `\n\n📦 第 ${batchIndex + 1}/${totalBatches} 批下载 (${currentBatch.length} 张图片)`;
                    downloadBtn.textContent = `下载中... 第${batchIndex + 1}/${totalBatches}批`;
                    
                    // 并发下载当前批次
                    const batchPromises = currentBatch.map(async (img, localIndex) => {
                        const globalIndex = startIndex + localIndex;
                        const filename = `story_${img.storyItemIndex}_${img.imageIndex + 1}.jpg`;
                        
                        try {
                            debug.textContent += `\n正在下载第 ${globalIndex + 1} 张: ${filename}`;
                            const success = await downloadImageWithRetry(img.url, filename, 2);
                            
                            if (success) {
                                successCount++;
                                debug.textContent += ` ✅`;
                                return { success: true, index: globalIndex + 1, filename };
                            } else {
                                failedDownloads.push({ index: globalIndex + 1, filename, url: img.url });
                                debug.textContent += ` ❌`;
                                return { success: false, index: globalIndex + 1, filename };
                            }
                        } catch (error) {
                            failedDownloads.push({ index: globalIndex + 1, filename, url: img.url, error: error.message });
                            debug.textContent += ` ❌ ${error.message}`;
                            return { success: false, index: globalIndex + 1, filename, error: error.message };
                        }
                    });
                    
                    // 等待当前批次完成
                    await Promise.allSettled(batchPromises);
                    
                    // 批次间延迟
                    if (batchIndex < totalBatches - 1) {
                        debug.textContent += `\n⏳ 等待 2 秒后开始下一批...`;
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                // 显示最终结果
                debug.textContent += `\n\n📊 故事图片批量下载完成统计:`;
                debug.textContent += `\n✅ 成功下载: ${successCount} 张`;
                debug.textContent += `\n❌ 下载失败: ${failedDownloads.length} 张`;
                
                if (failedDownloads.length > 0) {
                    debug.textContent += `\n\n失败列表:`;
                    failedDownloads.forEach(failed => {
                        debug.textContent += `\n- 第 ${failed.index} 张: ${failed.filename}`;
                    });
                    
                    const retryChoice = confirm(`✅ 成功下载 ${successCount} 张图片\n❌ ${failedDownloads.length} 张失败\n\n💡 提示：失败的图片可以点击单独的"下载"按钮重试\n\n是否现在重新尝试下载失败的图片？`);
                    
                    if (retryChoice) {
                        await retryFailedStoryDownloads(failedDownloads);
                    }
                } else {
                    debug.textContent += `\n\n🎉 所有故事图片下载成功！`;
                    alert(`🎉 恭喜！成功下载所有 ${successCount} 张故事图片！`);
                }
                
            } catch (error) {
                debug.textContent += `\n\n❌ 批量下载过程中发生错误: ${error.message}`;
                alert(`下载失败：${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = '保存所有图片';
            }
        }
        
        // 重新下载失败的故事图片
        async function retryFailedStoryDownloads(failedDownloads) {
            const debug = document.getElementById('debug');
            const downloadBtn = document.getElementById('downloadAllStoryBtn');
            
            downloadBtn.textContent = '重试下载中...';
            debug.textContent += `\n\n🔄 开始重试下载 ${failedDownloads.length} 张失败的故事图片...`;
            
            let retrySuccessCount = 0;
            
            for (let i = 0; i < failedDownloads.length; i++) {
                const failed = failedDownloads[i];
                
                try {
                    debug.textContent += `\n重试下载第 ${failed.index} 张: ${failed.filename}`;
                    downloadBtn.textContent = `重试中... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` ✅ 重试成功`;
                    } else {
                        debug.textContent += ` ❌ 重试仍然失败`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    debug.textContent += ` ❌ 重试失败: ${error.message}`;
                }
            }
            
            debug.textContent += `\n\n🔄 重试完成: ${retrySuccessCount}/${failedDownloads.length} 张成功`;
            
            if (retrySuccessCount === failedDownloads.length) {
                alert(`🎉 重试成功！所有故事图片都已下载完成！`);
            } else {
                alert(`重试完成: ${retrySuccessCount} 张成功，${failedDownloads.length - retrySuccessCount} 张仍然失败。\n请检查网络连接或手动保存失败的图片。`);
            }
            
            downloadBtn.textContent = '保存所有图片';
        }

        // 选择示例图片的函数
        function selectExampleImage(imgElement, imagePath) {
            // 移除其他图片的选中状态
            document.querySelectorAll('.example-image').forEach(img => {
                img.classList.remove('selected');
            });
            
            // 添加选中状态
            imgElement.classList.add('selected');
            
            // 将示例图片转换为base64并添加到refImages
            fetch(imagePath)
                .then(response => response.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const imageName = imagePath.split('/').pop();
                        
                        // 压缩图片
                        compressImage(blob, (compressedDataUrl) => {
                            refImages.push({
                                data: compressedDataUrl,
                                name: imageName
                            });
                            displayRefImages();
                        });
                    };
                    reader.readAsDataURL(blob);
                })
                .catch(error => {
                    console.error('加载示例图片失败:', error);
                    alert('加载示例图片失败，请尝试上传本地图片');
                });
        }

        // 原有的处理参考图片上传 (支持多张)
        function handleRefImageUpload(event) {
            const files = Array.from(event.target.files);
            refImages = [];
            
            files.forEach((file, index) => {
                compressImage(file, (compressedDataUrl) => {
                    refImages.push({
                        data: compressedDataUrl,
                        name: file.name
                    });
                    
                    if (index === files.length - 1) {
                        displayRefImages();
                    }
                });
            });
        }

        // 图片压缩函数
        function compressImage(file, callback) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                // 计算新尺寸，最大边不超过1024像素
                const maxSize = 1024;
                let { width, height } = img;
                
                if (width > height && width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                } else if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // 绘制压缩后的图片
                ctx.drawImage(img, 0, 0, width, height);
                
                // 转换为base64，质量设为0.8
                const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                callback(compressedDataUrl);
            };
            
            const reader = new FileReader();
            reader.onload = function(e) {
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayRefImages() {
            const preview = document.getElementById('refImagePreview');
            preview.innerHTML = refImages.map((img, index) => 
                `<img src="${img.data}" alt="Reference ${index + 1}" class="image-preview" title="${img.name}">`
            ).join('');
        }

        // 处理拖拽上传
        const refUploadArea = document.querySelector('#refImageInput').parentElement;
        refUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#1890ff';
        });

        refUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#ddd';
        });

        refUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#ddd';
            const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
            
            if (files.length > 0) {
                refImages = [];
                files.forEach((file, index) => {
                    compressImage(file, (compressedDataUrl) => {
                        refImages.push({
                            data: compressedDataUrl,
                            name: file.name
                        });
                        
                        if (index === files.length - 1) {
                            displayRefImages();
                        }
                    });
                });
            }
        });

        // 测试云雾API连接
        async function testYunwuConnection() {
            const apiKey = document.getElementById('apiKey').value;
            const testBtn = document.getElementById('testYunwuBtn');
            const debug = document.getElementById('debug');

            if (!apiKey) {
                alert('请先输入云雾API Key');
                return;
            }

            testBtn.disabled = true;
            testBtn.textContent = '测试中...';
            debug.textContent = '🔍 开始测试云雾API连接...\n';

            try {
                debug.textContent += `🔑 API Key长度: ${apiKey.length} 字符\n`;
                debug.textContent += `🔗 测试URL: https://yunwu.ai/v1/chat/completions\n`;
                debug.textContent += `📋 测试请求: 简单文本生成\n`;

                const testMessage = {
                    model: "sora_image",
                    messages: [
                        {
                            role: "system",
                            content: "You are a helpful assistant."
                        },
                        {
                            role: "user",
                            content: "测试连接"
                        }
                    ]
                };

                debug.textContent += `📦 请求体: ${JSON.stringify(testMessage, null, 2)}\n`;
                debug.textContent += `🚀 发送测试请求...\n`;

                // 尝试不同的API端点进行测试
                const testEndpoints = [
                    'https://yunwu.ai/v1/images/generations',
                    'https://yunwu.ai/api/v1/images/generations', 
                    'https://yunwu.ai/v1/generate',
                    'https://yunwu.ai/api/generate',
                    'https://yunwu.ai/generate'
                ];
                
                let response = null;
                let workingEndpoint = null;
                
                for (const endpoint of testEndpoints) {
                    try {
                        debug.textContent += `🔍 测试端点: ${endpoint}\n`;
                        
                        response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`,
                                'User-Agent': 'Sora-Image-Demo/1.0'
                            },
                            body: JSON.stringify(testMessage)
                        });
                        
                        debug.textContent += `📊 ${endpoint} 响应: ${response.status}\n`;
                        
                        if (response.ok || response.status === 400) { // 400可能是参数错误但端点存在
                            workingEndpoint = endpoint;
                            debug.textContent += `✅ 找到可用端点: ${endpoint}\n`;
                            break;
                        }
                    } catch (error) {
                        debug.textContent += `❌ ${endpoint} 错误: ${error.message}\n`;
                        continue;
                    }
                }
                
                if (!workingEndpoint) {
                    throw new Error('未找到可用的API端点');
                }

                debug.textContent += `📊 响应状态: ${response.status} ${response.statusText}\n`;
                debug.textContent += `📋 响应头: ${JSON.stringify([...response.headers.entries()], null, 2)}\n`;

                if (response.ok) {
                    const data = await response.json();
                    debug.textContent += `✅ 连接成功！\n`;
                    debug.textContent += `📄 响应数据: ${JSON.stringify(data, null, 2)}\n`;
                    alert('✅ 云雾API连接测试成功！');
                } else {
                    const errorText = await response.text();
                    debug.textContent += `❌ 连接失败: ${response.status} ${response.statusText}\n`;
                    debug.textContent += `❌ 错误详情: ${errorText}\n`;
                    
                    let errorMessage = `连接失败: ${response.status} ${response.statusText}`;
                    if (response.status === 401) {
                        errorMessage += '\n💡 建议: 请检查API Key是否正确';
                    } else if (response.status === 403) {
                        errorMessage += '\n💡 建议: API Key可能没有权限或账户余额不足';
                    } else if (response.status === 404) {
                        errorMessage += '\n💡 建议: API端点可能不存在';
                    }
                    
                    alert(`❌ ${errorMessage}`);
                }

            } catch (error) {
                debug.textContent += `❌ 连接测试出错: ${error.message}\n`;
                debug.textContent += `📋 错误详情: ${error.stack || error.toString()}\n`;
                
                let errorMessage = `连接测试失败: ${error.message}`;
                if (error.message.includes('ERR_SSL_PROTOCOL_ERROR')) {
                    errorMessage += '\n💡 SSL协议错误，可能是网络或服务器问题';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage += '\n💡 网络请求失败，请检查网络连接';
                } else if (error.message.includes('CORS')) {
                    errorMessage += '\n💡 跨域问题，可能需要服务器支持';
                }
                
                alert(`❌ ${errorMessage}`);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = '测试连接';
            }
        }

        // 测试OpenRouter连接
        async function testOpenRouterConnection() {
            const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const testBtn = document.getElementById('testBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey) {
                alert('请先输入 OpenRouter API Key');
                return;
            }

            testBtn.disabled = true;
            testBtn.textContent = '测试中...';
            debug.textContent = '正在测试 OpenRouter 连接...\n';

            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Sora Image Demo'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: "user",
                                content: "Hello, this is a test message."
                            }
                        ],
                        max_tokens: 10
                    })
                });

                const data = await response.json();
                
                debug.textContent += `API 响应状态: ${response.status}\n`;
                debug.textContent += `API 响应内容: ${JSON.stringify(data, null, 2)}\n`;
                
                if (response.ok && data.choices && data.choices.length > 0) {
                    debug.textContent += '✅ OpenRouter 连接测试成功！';
                    alert('✅ API Key 有效，连接测试成功！');
                } else {
                    debug.textContent += `❌ 连接测试失败: ${data.error?.message || '未知错误'}`;
                    alert(`❌ 连接测试失败: ${data.error?.message || '未知错误'}`);
                }
                
            } catch (error) {
                debug.textContent += `❌ 连接测试出错: ${error.message}`;
                alert(`连接测试出错：${error.message}`);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = '测试连接';
            }
        }

        // 批量生成提示词
        async function generatePrompts() {
            const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const metaPrompt = document.getElementById('metaPrompt').value;
            const generatePromptBtn = document.getElementById('generatePromptBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey || !metaPrompt || refImages.length === 0) {
                alert('请输入 OpenRouter API Key、元提示词并选择参考图片');
                return;
            }

            generatePromptBtn.disabled = true;
            generatePromptBtn.textContent = '生成中...';
            debug.textContent = '正在批量生成提示词...\n';
            promptsData = [];

            try {
                for (let i = 0; i < refImages.length; i++) {
                    const refImage = refImages[i];
                    debug.textContent += `\n正在处理第 ${i + 1} 张图片: ${refImage.name}`;

                    const messages = [
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: metaPrompt
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: refImage.data
                                    }
                                }
                            ]
                        }
                    ];

                    debug.textContent += `\n发送请求到 ${model}...`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openrouterKey}`,
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Sora Image Demo'
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            max_tokens: 1000
                        })
                    });

                    const data = await response.json();
                    
                    // 显示详细的API响应信息
                    debug.textContent += `\nAPI 响应状态: ${response.status}`;
                    debug.textContent += `\nAPI 响应内容: ${JSON.stringify(data, null, 2)}`;
                    
                    if (response.ok && data.choices && data.choices.length > 0) {
                        const generatedPrompt = data.choices[0]?.message?.content;
                        if (generatedPrompt && generatedPrompt.trim() && 
                            !generatedPrompt.includes('抱歉，我无法') && 
                            !generatedPrompt.includes('I cannot') &&
                            !generatedPrompt.includes('I\'m unable to')) {
                            promptsData.push({
                                prompt: generatedPrompt.trim(),
                                refImage: refImage,
                                index: i
                            });
                            debug.textContent += `\n✅ 提示词生成成功: ${generatedPrompt.substring(0, 50)}...`;
                        } else {
                            debug.textContent += `\n❌ 模型拒绝处理此图片，可能触发了内容安全过滤`;
                        }
                    } else {
                        debug.textContent += `\n❌ API 请求失败: ${data.error?.message || '未知错误'}`;
                        // 即使失败也继续处理下一张图片
                    }
                    
                    // 添加延迟避免API限制
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }

                if (promptsData.length > 0) {
                    displayPromptList();
                    debug.textContent += `\n\n✅ 成功生成 ${promptsData.length} 个提示词！`;
                } else {
                    debug.textContent += `\n\n❌ 没有成功生成任何提示词，请检查API Key或网络连接`;
                    alert('提示词生成失败，请查看调试信息');
                }
                
            } catch (error) {
                debug.textContent += `\n\n❌ 发生错误: ${error.message}`;
                debug.textContent += `\n错误堆栈: ${error.stack}`;
                alert(`发生错误：${error.message}`);
            } finally {
                generatePromptBtn.disabled = false;
                generatePromptBtn.textContent = '批量生成 Prompts';
            }
        }

        function displayPromptList() {
            const promptListGroup = document.getElementById('promptListGroup');
            const promptList = document.getElementById('promptList');

        promptListGroup.style.display = 'block';
            promptList.innerHTML = promptsData.map((item, index) => `
                <div class="prompt-item">
                    <img src="${item.refImage.data}" alt="Reference ${index + 1}">
                    <textarea id="prompt_${index}" placeholder="生成的提示词...">${item.prompt}</textarea>
                </div>
            `).join('');
        }

        // 从Markdown格式的字符串中提取图片URL (增强版)
        function extractImageUrl(content) {
            if (!content || typeof content !== 'string') {
                return null;
            }
            
            // 方法1: 传统Markdown格式 [图片](URL)
            let match = content.match(/\[图片\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('✅ 通过Markdown格式提取到URL:', match[1]);
                return match[1];
            }
            
            // 方法2: 英文Markdown格式 [image](URL) 或 [Image](URL)
            match = content.match(/\[(?:image|Image)\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('✅ 通过英文Markdown格式提取到URL:', match[1]);
                return match[1];
            }
            
            // 方法3: 其他Markdown格式 ![alt](URL)
            match = content.match(/!\[.*?\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('✅ 通过标准Markdown图片格式提取到URL:', match[1]);
                return match[1];
            }
            
            // 方法4: 直接的HTTP/HTTPS URL
            match = content.match(/(https?:\/\/[^\s<>"'\[\]{}|\\^`]+(?:\.(?:png|jpg|jpeg|gif|webp|bmp|svg))?)/i);
            if (match && match[1]) {
                console.log('✅ 通过正则表达式提取到直接URL:', match[1]);
                return match[1];
            }
            
            // 方法5: 查找任何看起来像图片URL的内容
            match = content.match(/(?:url|src|href)["']?\s*:\s*["']?(https?:\/\/[^"'\s,}]+)/i);
            if (match && match[1]) {
                console.log('✅ 通过属性格式提取到URL:', match[1]);
                return match[1];
            }
            
            // 方法6: 查找被引号包围的URL
            match = content.match(/["'](https?:\/\/[^"'\s]+\.(?:png|jpg|jpeg|gif|webp|bmp|svg))["']/i);
            if (match && match[1]) {
                console.log('✅ 通过引号包围格式提取到URL:', match[1]);
                return match[1];
            }
            
            console.log('❌ 无法从内容中提取图片URL:', content);
            return null;
        }

        // 网络诊断功能
        async function diagnoseNetwork() {
            const debug = document.getElementById('debug');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            diagnoseBtn.disabled = true;
            diagnoseBtn.textContent = '诊断中...';
            debug.textContent = '🔍 开始网络诊断...\n';

            try {
                // 1. 检查基本网络连接
                debug.textContent += '1️⃣ 检查基本网络连接...\n';
                try {
                    const response = await fetch('https://www.google.com/favicon.ico', { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache'
                    });
                    debug.textContent += '✅ 基本网络连接正常\n';
                } catch (e) {
                    debug.textContent += '❌ 基本网络连接异常\n';
                }

                // 2. 检查DNS解析
                debug.textContent += '\n2️⃣ 检查DNS解析...\n';
                try {
                    const start = Date.now();
                    await fetch('https://yunwu.ai', { method: 'HEAD', mode: 'no-cors' });
                    const time = Date.now() - start;
                    debug.textContent += `✅ yunwu.ai DNS解析正常 (${time}ms)\n`;
                } catch (e) {
                    debug.textContent += `❌ yunwu.ai DNS解析失败: ${e.message}\n`;
                }

                // 3. 检查HTTPS连接
                debug.textContent += '\n3️⃣ 检查HTTPS连接...\n';
                try {
                    const start = Date.now();
                    const response = await fetch('https://yunwu.ai', { 
                        method: 'HEAD',
                        mode: 'cors'
                    });
                    const time = Date.now() - start;
                    debug.textContent += `✅ HTTPS连接正常 (${time}ms, 状态: ${response.status})\n`;
                } catch (e) {
                    debug.textContent += `❌ HTTPS连接失败: ${e.message}\n`;
                    if (e.message.includes('ERR_SSL_PROTOCOL_ERROR')) {
                        debug.textContent += '💡 SSL协议错误，可能是服务器SSL配置问题\n';
                    }
                }

                // 4. 检查API端点
                debug.textContent += '\n4️⃣ 检查API端点可达性...\n';
                try {
                    const start = Date.now();
                    const response = await fetch('https://yunwu.ai/v1/chat/completions', { 
                        method: 'OPTIONS',
                        mode: 'cors'
                    });
                    const time = Date.now() - start;
                    debug.textContent += `✅ API端点可达 (${time}ms, 状态: ${response.status})\n`;
                } catch (e) {
                    debug.textContent += `❌ API端点不可达: ${e.message}\n`;
                }

                // 5. 检查浏览器环境
                debug.textContent += '\n5️⃣ 检查浏览器环境...\n';
                debug.textContent += `🌐 浏览器: ${navigator.userAgent}\n`;
                debug.textContent += `🔒 HTTPS: ${location.protocol === 'https:' ? '是' : '否'}\n`;
                debug.textContent += `🌍 语言: ${navigator.language}\n`;
                debug.textContent += `📱 平台: ${navigator.platform}\n`;
                debug.textContent += `🔌 在线状态: ${navigator.onLine ? '在线' : '离线'}\n`;

                // 6. 检查本地存储
                debug.textContent += '\n6️⃣ 检查本地存储...\n';
                try {
                    localStorage.setItem('test', 'test');
                    localStorage.removeItem('test');
                    debug.textContent += '✅ localStorage 可用\n';
                } catch (e) {
                    debug.textContent += '❌ localStorage 不可用\n';
                }

                debug.textContent += '\n🎯 诊断完成！\n';
                debug.textContent += '\n💡 如果仍有问题，请：\n';
                debug.textContent += '   - 检查API Key是否正确\n';
                debug.textContent += '   - 确认账户余额充足\n';
                debug.textContent += '   - 尝试关闭VPN或代理\n';
                debug.textContent += '   - 联系API服务商确认服务状态\n';

            } catch (error) {
                debug.textContent += `\n❌ 诊断过程出错: ${error.message}\n`;
            } finally {
                diagnoseBtn.disabled = false;
                diagnoseBtn.textContent = '网络诊断';
            }
        }

        // 批量生成所有图片
    async function generateAllImages() {
        const apiKey = document.getElementById('apiKey').value;
        const imageCount = parseInt(document.getElementById('imageCount').value);
        const generateBtn = document.getElementById('generateBtn');
            const result = document.getElementById('result');
        const debug = document.getElementById('debug');

            if (!apiKey || promptsData.length === 0) {
                alert('请输入云雾 API Key 并先生成提示词');
                return;
            }

        generateBtn.disabled = true;
        generateBtn.textContent = '生成中...';
            result.innerHTML = '正在批量生成图片，请稍候...';
            generatedImages = [];

            try {
                debug.textContent += `\n\n开始批量生成图片...`;
                debug.textContent += `\n📊 生成配置: ${promptsData.length}个提示词 x ${imageCount}张图片 = ${promptsData.length * imageCount}张总计`;
                
                // 检查垫图情况
                let totalWithRefImages = 0;
                let totalWithoutRefImages = 0;
                
                // 创建所有并发请求
                const allRequests = [];
                
                for (let i = 0; i < promptsData.length; i++) {
                    const promptText = document.getElementById(`prompt_${i}`).value;
                    const refImageData = promptsData[i].refImage.data;
                    
                    if (!promptText.trim()) {
                        debug.textContent += `\n⚠️ 跳过组${i + 1}: 提示词为空`;
                        continue;
                    }
                    
                    debug.textContent += `\n📋 组${i + 1}: 使用垫图 ${promptsData[i].refImage.name} (${imageCount}张)`;
                    
                    // 详细检查当前组的垫图数据
                    debug.textContent += `\n🔍 组${i + 1} 垫图数据源检查:`;
                    debug.textContent += `\n   - promptsData[${i}]存在: ${!!promptsData[i]}`;
                    debug.textContent += `\n   - refImage对象存在: ${!!promptsData[i]?.refImage}`;
                    debug.textContent += `\n   - 垫图文件名: ${promptsData[i]?.refImage?.name || '未知'}`;
                    debug.textContent += `\n   - data字段存在: ${!!promptsData[i]?.refImage?.data}`;
                    debug.textContent += `\n   - data字段类型: ${typeof promptsData[i]?.refImage?.data}`;
                    debug.textContent += `\n   - data字段长度: ${promptsData[i]?.refImage?.data?.length || 0} 字符`;
                    
                    for (let j = 0; j < imageCount; j++) {
                        if (refImageData && refImageData.trim()) {
                            totalWithRefImages++;
                            debug.textContent += `\n   ✅ 第${j + 1}张将使用垫图: ${promptsData[i].refImage.name}`;
                        } else {
                            totalWithoutRefImages++;
                            debug.textContent += `\n   ❌ 第${j + 1}张无有效垫图数据`;
                        }
                        
                        const requestPromise = generateSingleImage(apiKey, promptText, refImageData, i, j);
                        allRequests.push(requestPromise);
                    }
                }

                debug.textContent += `\n📊 生成统计: 垫图生成${totalWithRefImages}张, 纯文本生成${totalWithoutRefImages}张`;
                debug.textContent += `\n开始并发生成 ${allRequests.length} 张图片...`;
                
                // 并发执行所有请求
                const results = await Promise.allSettled(allRequests);
                
                // 处理结果
                let successCount = 0;
                let failCount = 0;
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        generatedImages.push(result.value);
                        successCount++;
                        debug.textContent += `\n✅ 第 ${index + 1} 张图片生成成功`;
                    } else {
                        failCount++;
                        debug.textContent += `\n❌ 第 ${index + 1} 张图片生成失败: ${result.reason || '未知错误'}`;
                    }
                });

                displayGeneratedImages();
                document.getElementById('downloadBtn').style.display = 'inline-block';
                
                debug.textContent += `\n\n🎉 批量生成完成！`;
                debug.textContent += `\n📊 最终统计: 成功${successCount}张, 失败${failCount}张`;
                debug.textContent += `\n🖼️ 垫图生成成功: ${successCount}张 (所有图片都使用了垫图)`;
                
            } catch (error) {
                result.innerHTML = `发生错误：${error.message}`;
                debug.textContent += '\n\nError:\n' + error.stack;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = '批量生成图片';
            }
        }

        // 单个图片生成函数 (增强版)
        async function generateSingleImage(apiKey, promptText, refImageData, groupIndex, imageIndex) {
            const debug = document.getElementById('debug');
            
            // 获取垫图文件名用于日志
            const refImageName = promptsData[groupIndex]?.refImage?.name || '未知文件';
            const requestId = `${groupIndex + 1}-${imageIndex + 1}`;
            
            debug.textContent += `\n\n🔍 [${requestId}] 开始处理图片生成请求`;
            debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageName}`;
            
            // 详细检查垫图数据状态
            debug.textContent += `\n🔍 [${requestId}] 垫图数据检查:`;
            debug.textContent += `\n   - refImageData类型: ${typeof refImageData}`;
            debug.textContent += `\n   - refImageData是否存在: ${!!refImageData}`;
            debug.textContent += `\n   - refImageData长度: ${refImageData ? refImageData.length : 0} 字符`;
            
            if (refImageData) {
                debug.textContent += `\n   - 数据开头: ${refImageData.substring(0, 30)}...`;
                debug.textContent += `\n   - 是否为data:image格式: ${refImageData.startsWith('data:image/')}`;
                
                // 检查base64部分
                const parts = refImageData.split(',');
                if (parts.length === 2) {
                    const base64Part = parts[1];
                    debug.textContent += `\n   - base64部分长度: ${base64Part.length} 字符`;
                    debug.textContent += `\n   - 估算图片大小: ${Math.round(base64Part.length * 0.75 / 1024)}KB`;
                } else {
                    debug.textContent += `\n   - ❌ base64格式错误，分割后长度: ${parts.length}`;
                }
            }
            
            // 验证垫图数据
            const hasValidRefImage = validateRefImageData(refImageData, `[${requestId}]`);
            
            // 构建消息内容
            let messageContent;
            if (hasValidRefImage) {
                // 有有效垫图的情况
                messageContent = [
                    {
                        "type": "text",
                        "text": promptText
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": refImageData
                        }
                    }
                ];
                debug.textContent += `\n🖼️ [${requestId}] 使用垫图生成模式`;
                debug.textContent += `\n📋 [${requestId}] 消息内容包含: 文本 + 图片URL`;
                debug.textContent += `\n🎯 [${requestId}] 垫图文件: ${refImageName}`;
            } else {
                // 没有垫图或垫图无效的情况
                messageContent = promptText;
                debug.textContent += `\n📝 [${requestId}] 纯文本生成模式 (垫图无效或缺失)`;
                debug.textContent += `\n📋 [${requestId}] 消息内容: 仅文本`;
                debug.textContent += `\n⚠️ [${requestId}] 垫图文件: ${refImageName} (未使用)`;
            }
            
            const messages = [
                {
                    role: "system",
                    content: "You are a helpful assistant."
                },
                {
                    role: "user",
                    content: messageContent
                }
            ];

            debug.textContent += `\n🚀 [${requestId}] 准备发送API请求...`;
            debug.textContent += `\n📦 [${requestId}] 请求体大小: ${JSON.stringify(messages).length} 字符`;
            
            // 记录请求详情（不包含完整的base64数据，避免日志过长）
            if (hasValidRefImage) {
                debug.textContent += `\n📷 [${requestId}] 请求包含图片: ${refImageName}`;
                debug.textContent += `\n🔗 [${requestId}] 图片URL类型: ${refImageData.substring(0, 20)}...`;
            }
            
            try {
                // 🔧 添加60秒超时机制
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('请求超时 (60秒)')), 60000);
                });
                
                debug.textContent += `\n🔗 [${requestId}] 请求URL: https://yunwu.ai/v1/chat/completions`;
                debug.textContent += `\n🔑 [${requestId}] API Key长度: ${apiKey ? apiKey.length : 0} 字符`;
                debug.textContent += `\n📋 [${requestId}] 请求模型: sora_image`;
                
                // 基于测试结果，使用成功的请求格式（按成功率排序）
                const requestFormats = [
                    // 格式1: 聊天完成风格 (成功率最高)
                    {
                        model: "sora_image",
                        messages: messages
                    },
                    // 格式2: OpenAI风格的图像生成 (备用)
                    {
                        prompt: promptText,
                        model: "sora_image",
                        n: 1,
                        size: "1024x1024"
                    }
                ];
                
                let requestBody = requestFormats[0]; // 默认使用第一种格式
                
                debug.textContent += `\n📦 [${requestId}] 请求体: ${JSON.stringify(requestBody, null, 2)}`;
                
                // 基于测试结果，使用可用的API端点（按成功率排序）
                const apiEndpoints = [
                    'https://yunwu.ai/v1/chat/completions', // 成功率最高
                    'https://yunwu.ai/v1/images/generations' // 备用选项
                ];
                
                let response = null;
                let lastError = null;
                let workingConfig = null;
                
                for (const endpoint of apiEndpoints) {
                    for (let formatIndex = 0; formatIndex < requestFormats.length; formatIndex++) {
                        const currentFormat = requestFormats[formatIndex];
                        
                        try {
                            debug.textContent += `\n🔍 [${requestId}] 尝试: ${endpoint} + 格式${formatIndex + 1}`;
                            
                            response = await fetch(endpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`,
                                    'User-Agent': 'Sora-Image-Demo/1.0'
                                },
                                body: JSON.stringify(currentFormat)
                            });
                            
                            if (response.ok) {
                                debug.textContent += `\n✅ [${requestId}] 成功组合: ${endpoint} + 格式${formatIndex + 1}`;
                                workingConfig = { endpoint, format: currentFormat, formatIndex };
                                break;
                            } else {
                                const errorText = await response.text();
                                debug.textContent += `\n❌ [${requestId}] 失败: ${response.status} - ${errorText.substring(0, 100)}`;
                                lastError = new Error(`${response.status} ${response.statusText}: ${errorText}`);
                            }
                        } catch (error) {
                            debug.textContent += `\n❌ [${requestId}] 错误: ${error.message}`;
                            lastError = error;
                            continue;
                        }
                    }
                    
                    if (workingConfig) break;
                }
                
                if (!response || !response.ok) {
                    debug.textContent += `\n💥 [${requestId}] 所有端点和格式组合都失败了`;
                    debug.textContent += `\n📋 [${requestId}] 尝试的端点: ${apiEndpoints.join(', ')}`;
                    debug.textContent += `\n📋 [${requestId}] 尝试的格式数: ${requestFormats.length}`;
                    throw lastError || new Error('所有API端点和请求格式都无法访问');
                }
                
                debug.textContent += `\n🎯 [${requestId}] 使用配置: ${workingConfig.endpoint} + 格式${workingConfig.formatIndex + 1}`;
                
                const fetchPromise = Promise.resolve(response);
                
                const finalResponse = await Promise.race([fetchPromise, timeoutPromise]);

                debug.textContent += `\n📊 [${requestId}] API响应状态: ${finalResponse.status}`;

                if (!finalResponse.ok) {
                    let errorText = '';
                    let errorJson = null;
                    
                    try {
                        errorText = await finalResponse.text();
                        // 尝试解析为JSON
                        if (errorText.trim().startsWith('{')) {
                            errorJson = JSON.parse(errorText);
                        }
                    } catch (e) {
                        debug.textContent += `\n⚠️ [${requestId}] 无法解析错误响应: ${e.message}`;
                    }
                    
                    debug.textContent += `\n❌ [${requestId}] API响应错误: ${finalResponse.status} ${finalResponse.statusText}`;
                    debug.textContent += `\n❌ [${requestId}] 响应头信息: ${JSON.stringify([...finalResponse.headers.entries()])}`;
                    debug.textContent += `\n❌ [${requestId}] 错误详情: ${errorText}`;
                    
                    if (errorJson) {
                        debug.textContent += `\n❌ [${requestId}] 结构化错误信息: ${JSON.stringify(errorJson, null, 2)}`;
                        if (errorJson.error) {
                            debug.textContent += `\n❌ [${requestId}] 错误类型: ${errorJson.error.type || '未知'}`;
                            debug.textContent += `\n❌ [${requestId}] 错误消息: ${errorJson.error.message || '无详细信息'}`;
                        }
                    }
                    
                    debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${hasValidRefImage ? '已使用' : '未使用'}`;
                    debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageName}`;
                    
                    // 根据错误状态码提供具体建议
                    if (finalResponse.status === 401) {
                        debug.textContent += `\n💡 [${requestId}] 建议: 请检查API Key是否正确`;
                    } else if (finalResponse.status === 403) {
                        debug.textContent += `\n💡 [${requestId}] 建议: API Key可能没有权限或账户余额不足`;
                    } else if (finalResponse.status === 404) {
                        debug.textContent += `\n💡 [${requestId}] 建议: API端点可能不存在，请检查URL是否正确`;
                    } else if (finalResponse.status === 429) {
                        debug.textContent += `\n💡 [${requestId}] 建议: 请求过于频繁，请稍后重试`;
                    } else if (finalResponse.status >= 500) {
                        debug.textContent += `\n💡 [${requestId}] 建议: 服务器内部错误，请稍后重试`;
                    }
                    
                    throw new Error(`API请求失败: ${finalResponse.status} ${finalResponse.statusText} - ${errorText}`);
                }

                const data = await finalResponse.json();
                debug.textContent += `\n✅ [${requestId}] API调用成功`;
                debug.textContent += `\n📄 [${requestId}] 完整响应内容: \`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``;
                
                // 进行API响应格式诊断
                const responseFormat = diagnoseApiResponse(data, requestId);
                
                // 适应新的响应格式处理逻辑
                let imageUrl = null;
                
                // 方法1：检查传统格式 (choices[0].message.content)
                const content = data.choices?.[0]?.message?.content;
                if (content) {
                    imageUrl = extractImageUrl(content);
                    if (imageUrl) {
                        debug.textContent += `\n✅ [${requestId}] 从传统格式提取到图片URL`;
                    }
                }
                
                // 方法2：检查新格式 - 直接在响应中查找图片URL
                if (!imageUrl) {
                    // 检查响应中是否直接包含图片URL字段
                    if (data.image_url) {
                        imageUrl = data.image_url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(image_url字段)提取到图片URL`;
                    } else if (data.url) {
                        imageUrl = data.url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(url字段)提取到图片URL`;
                    } else if (data.result && data.result.url) {
                        imageUrl = data.result.url;
                        debug.textContent += `\n✅ [${requestId}] 从新格式(result.url字段)提取到图片URL`;
                    }
                }
                
                // 方法3：检查是否为异步响应格式
                if (!imageUrl) {
                    // 检查是否有任务ID或其他异步标识
                    if (data.task_id || data.id || data.prompt) {
                        debug.textContent += `\n⏳ [${requestId}] 检测到异步响应格式`;
                        debug.textContent += `\n📋 [${requestId}] 响应参数确认: ${JSON.stringify(data)}`;
                        
                        // 显示格式变化提示
                        if (responseFormat === 'async_params') {
                            showApiFormatChangeNotice();
                        }
                        
                        // 对于异步API，我们需要等待并轮询结果
                        debug.textContent += `\n⏳ [${requestId}] 检测到云雾API异步模式，开始轮询结果`;
                        
                        // 获取任务ID
                        const taskId = data.task_id || data.id || data.prompt;
                        debug.textContent += `\n🔑 [${requestId}] 任务ID: ${taskId}`;
                        
                        // 轮询任务结果
                        try {
                            const pollResult = await pollTaskResult(apiKey, taskId, requestId);
                            if (pollResult && pollResult.imageUrl) {
                                imageUrl = pollResult.imageUrl;
                                debug.textContent += `\n✅ [${requestId}] 异步轮询成功获取图片URL`;
                            } else {
                                throw new Error('轮询任务结果失败');
                            }
                        } catch (pollError) {
                            debug.textContent += `\n❌ [${requestId}] 轮询任务失败: ${pollError.message}`;
                            throw new Error(`异步API轮询失败: ${pollError.message}`);
                        }
                    }
                }
                
                // 方法4：尝试在响应文本中查找任何HTTP URL
                if (!imageUrl) {
                    const responseText = JSON.stringify(data);
                    const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                    const urls = responseText.match(urlRegex);
                    if (urls && urls.length > 0) {
                        imageUrl = urls[0];
                        debug.textContent += `\n✅ [${requestId}] 通过正则表达式在响应中找到图片URL`;
                    }
                }
                
                if (!imageUrl) {
                    debug.textContent += `\n❌ [${requestId}] 所有方法都无法提取图片URL`;
                    debug.textContent += `\n📄 [${requestId}] 响应数据结构: ${Object.keys(data).join(', ')}`;
                    debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${hasValidRefImage ? '已使用' : '未使用'}`;
                    debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageName}`;
                    
                    // 提供更详细的错误信息
                    const errorDetails = {
                        responseStructure: Object.keys(data),
                        hasChoices: !!data.choices,
                        hasContent: !!(data.choices?.[0]?.message?.content),
                        responseData: data
                    };
                    
                    throw new Error(`未能从响应中提取图片URL。响应格式可能已变化。详情: ${JSON.stringify(errorDetails, null, 2)}`);
                }

                debug.textContent += `\n🎉 [${requestId}] 图片生成成功!`;
                debug.textContent += `\n🔗 [${requestId}] 图片URL: ${imageUrl.substring(0, 50)}...`;
                debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${hasValidRefImage ? '✅ 已使用' : '❌ 未使用'}`;
                debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageName}`;
                
                return {
                    url: imageUrl,
                    prompt: promptText,
                    refImage: refImageName,
                    groupIndex: groupIndex,
                    imageIndex: imageIndex,
                    usedRefImage: hasValidRefImage,
                    refImageFile: refImageName
                };
            } catch (error) {
                debug.textContent += `\n💥 [${requestId}] 生成过程出错: ${error.message}`;
                debug.textContent += `\n🖼️ [${requestId}] 垫图使用状态: ${hasValidRefImage ? '已配置但失败' : '未使用'}`;
                debug.textContent += `\n📂 [${requestId}] 垫图文件: ${refImageName}`;
                
                // 详细的错误类型分析
                if (error.message.includes('ERR_SSL_PROTOCOL_ERROR')) {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: SSL协议错误`;
                    debug.textContent += `\n💡 [${requestId}] 可能原因: `;
                    debug.textContent += `\n   - API服务器SSL配置问题`;
                    debug.textContent += `\n   - 网络代理或防火墙阻止HTTPS连接`;
                    debug.textContent += `\n   - DNS解析问题`;
                    debug.textContent += `\n🔧 [${requestId}] 建议解决方案: `;
                    debug.textContent += `\n   - 检查网络连接是否正常`;
                    debug.textContent += `\n   - 尝试关闭VPN或代理`;
                    debug.textContent += `\n   - 联系API服务商确认服务状态`;
                } else if (error.message.includes('Failed to fetch')) {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: 网络请求失败`;
                    debug.textContent += `\n💡 [${requestId}] 可能原因: `;
                    debug.textContent += `\n   - 网络连接中断`;
                    debug.textContent += `\n   - API服务器不可达`;
                    debug.textContent += `\n   - CORS跨域问题`;
                    debug.textContent += `\n🔧 [${requestId}] 建议解决方案: `;
                    debug.textContent += `\n   - 检查网络连接`;
                    debug.textContent += `\n   - 确认API地址是否正确`;
                    debug.textContent += `\n   - 稍后重试`;
                } else if (error.message.includes('请求超时')) {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: 请求超时`;
                    debug.textContent += `\n💡 [${requestId}] 可能原因: `;
                    debug.textContent += `\n   - 网络速度较慢`;
                    debug.textContent += `\n   - API服务器响应缓慢`;
                    debug.textContent += `\n   - 图片处理时间过长`;
                    debug.textContent += `\n🔧 [${requestId}] 建议解决方案: `;
                    debug.textContent += `\n   - 稍后重试`;
                    debug.textContent += `\n   - 检查网络连接质量`;
                    debug.textContent += `\n   - 尝试减少图片大小`;
                } else if (error.message.includes('401')) {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: 认证失败`;
                    debug.textContent += `\n💡 [${requestId}] 可能原因: API Key无效或过期`;
                    debug.textContent += `\n🔧 [${requestId}] 建议解决方案: 检查并更新API Key`;
                } else if (error.message.includes('403')) {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: 权限不足`;
                    debug.textContent += `\n💡 [${requestId}] 可能原因: API Key权限不足或余额不足`;
                    debug.textContent += `\n🔧 [${requestId}] 建议解决方案: 检查账户余额和权限`;
                } else {
                    debug.textContent += `\n🔍 [${requestId}] 错误类型: 未知错误`;
                    debug.textContent += `\n📋 [${requestId}] 完整错误信息: ${error.stack || error.toString()}`;
                }
                
                throw error;
            }
        }

        function displayGeneratedImages() {
            const result = document.getElementById('result');
            const withRefImageCount = generatedImages.filter(img => img.usedRefImage).length;
            const withoutRefImageCount = generatedImages.length - withRefImageCount;
            
            result.innerHTML = `
                <h3>生成结果 (共 ${generatedImages.length} 张图片)：</h3>
                <div style="background-color: #f0f8ff; border: 1px solid #91d5ff; border-radius: 6px; padding: 10px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 8px 0; color: #1890ff;">📊 垫图使用统计</h4>
                    <p style="margin: 0;">
                        🖼️ 使用垫图生成: <strong>${withRefImageCount}</strong> 张 | 
                        📝 纯文本生成: <strong>${withoutRefImageCount}</strong> 张
                    </p>
                </div>
                <div class="image-grid">
                    ${generatedImages.map((img, index) => `
                        <div class="image-item">
                            <img src="${img.url}" alt="Generated Image ${index + 1}">
                            <div style="background-color: ${img.usedRefImage ? '#e6f7ff' : '#fff7e6'}; border: 1px solid ${img.usedRefImage ? '#91d5ff' : '#ffd591'}; border-radius: 4px; padding: 8px; margin: 8px 0;">
                                <div style="font-size: 12px; color: ${img.usedRefImage ? '#1890ff' : '#fa8c16'}; font-weight: bold;">
                                    ${img.usedRefImage ? '🖼️ 垫图生成' : '📝 纯文本生成'}
                                </div>
                                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                    参考图: ${img.refImage}
                                </div>
                            </div>
                            <p><strong>提示词:</strong> ${img.prompt.substring(0, 100)}...</p>
                            <div class="image-controls">
                                <button class="btn-download" onclick="downloadSingleImage(${index})">下载</button>
                                <button class="btn-copy" onclick="copyImageUrl(${index})">复制URL</button>
                                <button class="btn-retry" onclick="retrySingleImage(${index})">重试</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // 下载单张图片
        async function downloadSingleImage(index) {
            const img = generatedImages[index];
            const filename = `generated_${img.groupIndex + 1}_${img.imageIndex + 1}_${img.refImage.split('.')[0]}.jpg`;
            const debug = document.getElementById('debug');
            
            try {
                debug.textContent += `\n正在下载: ${filename}`;
                const success = await downloadImageWithRetry(img.url, filename, 3);
                
                if (success) {
                    debug.textContent += ` ✅ 下载成功`;
                    // 更新按钮状态
                    event.target.textContent = '已下载';
                    event.target.style.backgroundColor = '#95de64';
                    event.target.disabled = true;
                    setTimeout(() => {
                        event.target.textContent = '下载';
                        event.target.style.backgroundColor = '#52c41a';
                        event.target.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` ❌ 下载失败`;
                    alert('下载失败，请检查网络连接或尝试复制URL手动下载');
                }
            } catch (error) {
                debug.textContent += ` ❌ 下载错误: ${error.message}`;
                alert(`下载失败：${error.message}`);
            }
        }
        
        // 复制图片URL
        async function copyImageUrl(index) {
            const img = generatedImages[index];
            const debug = document.getElementById('debug');
            
            try {
                await navigator.clipboard.writeText(img.url);
                debug.textContent += `\n已复制第 ${index + 1} 张图片的URL到剪贴板`;
                
                // 更新按钮状态
                event.target.textContent = '已复制';
                event.target.style.backgroundColor = '#95de64';
                setTimeout(() => {
                    event.target.textContent = '复制URL';
                    event.target.style.backgroundColor = '#1890ff';
                }, 1500);
                
            } catch (error) {
                // 如果clipboard API不可用，使用备用方法
                const textArea = document.createElement('textarea');
                textArea.value = img.url;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    debug.textContent += `\n已复制第 ${index + 1} 张图片的URL到剪贴板`;
                    alert('URL已复制到剪贴板！');
                } catch (err) {
                    debug.textContent += `\n复制失败: ${err.message}`;
                    alert(`复制失败，请手动复制：${img.url}`);
                }
                document.body.removeChild(textArea);
            }
        }

        // 重新生成单张图片
        async function retrySingleImage(index) {
            const img = generatedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('请输入云雾 API Key');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '重试中...';
            button.disabled = true;
            
            try {
                debug.textContent += `\n重新生成第 ${index + 1} 张图片...`;
                
                const newImage = await generateSingleImage(
                    apiKey, 
                    img.prompt, 
                    promptsData[img.groupIndex].refImage.data, 
                    img.groupIndex, 
                    img.imageIndex
                );
                
                if (newImage) {
                    // 更新图片数据
                    generatedImages[index] = newImage;
                    
                    // 更新显示
                    const imageElement = button.closest('.image-item').querySelector('img');
                    imageElement.src = newImage.url;
                    
                    debug.textContent += ` ✅ 重新生成成功`;
                    
                    button.textContent = '生成成功';
                    button.style.backgroundColor = '#95de64';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                        button.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` ❌ 重新生成失败`;
                    throw new Error('生成失败');
                }
                
            } catch (error) {
                debug.textContent += ` ❌ 重新生成错误: ${error.message}`;
                alert(`重新生成失败：${error.message}`);
                
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // 下载所有图片
        async function downloadAllImages() {
            const downloadBtn = document.getElementById('downloadBtn');
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = '下载中...';

            let successCount = 0;
            let failedDownloads = [];

            try {
                debug.textContent += '\n\n开始批量下载所有图片...';
                debug.textContent += '\n💡 采用分批下载模式，确保稳定性...';
                
                // 分批下载，每批3张图片，避免浏览器限制
                const batchSize = 3;
                const totalBatches = Math.ceil(generatedImages.length / batchSize);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIndex = batchIndex * batchSize;
                    const endIndex = Math.min(startIndex + batchSize, generatedImages.length);
                    const currentBatch = generatedImages.slice(startIndex, endIndex);
                    
                    debug.textContent += `\n\n📦 第 ${batchIndex + 1}/${totalBatches} 批下载 (${currentBatch.length} 张图片)`;
                    downloadBtn.textContent = `下载中... 第${batchIndex + 1}/${totalBatches}批`;
                    
                    // 并发下载当前批次
                    const batchPromises = currentBatch.map(async (img, localIndex) => {
                        const globalIndex = startIndex + localIndex;
                        const filename = `generated_${img.groupIndex + 1}_${img.imageIndex + 1}_${img.refImage.split('.')[0]}.jpg`;
                        
                        try {
                            debug.textContent += `\n正在下载第 ${globalIndex + 1} 张: ${filename}`;
                            const success = await downloadImageWithRetry(img.url, filename, 2);
                            
                            if (success) {
                                successCount++;
                                debug.textContent += ` ✅`;
                                return { success: true, index: globalIndex + 1, filename };
                            } else {
                                failedDownloads.push({ index: globalIndex + 1, filename, url: img.url });
                                debug.textContent += ` ❌`;
                                return { success: false, index: globalIndex + 1, filename };
                            }
        } catch (error) {
                            failedDownloads.push({ index: globalIndex + 1, filename, url: img.url, error: error.message });
                            debug.textContent += ` ❌ ${error.message}`;
                            return { success: false, index: globalIndex + 1, filename, error: error.message };
                        }
                    });
                    
                    // 等待当前批次完成
                    await Promise.allSettled(batchPromises);
                    
                    // 批次间延迟，给浏览器缓冲时间
                    if (batchIndex < totalBatches - 1) {
                        debug.textContent += `\n⏳ 等待 2 秒后开始下一批...`;
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                // 显示最终结果
                debug.textContent += `\n\n📊 批量下载完成统计:`;
                debug.textContent += `\n✅ 成功下载: ${successCount} 张`;
                debug.textContent += `\n❌ 下载失败: ${failedDownloads.length} 张`;
                
                if (failedDownloads.length > 0) {
                    debug.textContent += `\n\n失败列表:`;
                    failedDownloads.forEach(failed => {
                        debug.textContent += `\n- 第 ${failed.index} 张: ${failed.filename}`;
                    });
                    
                    const retryChoice = confirm(`✅ 成功下载 ${successCount} 张图片\n❌ ${failedDownloads.length} 张失败\n\n💡 提示：失败的图片可以点击单独的"下载"按钮重试\n或者点击"复制URL"手动下载\n\n是否现在重新尝试下载失败的图片？`);
                    
                    if (retryChoice) {
                        await retryFailedDownloads(failedDownloads);
                    }
                } else {
                    debug.textContent += `\n\n🎉 所有图片下载成功！`;
                    alert(`🎉 恭喜！成功下载所有 ${successCount} 张图片！`);
                }
                
            } catch (error) {
                debug.textContent += `\n\n❌ 批量下载过程中发生错误: ${error.message}`;
                alert(`下载失败：${error.message}\n\n建议：请尝试单独下载失败的图片`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = '保存所有图片';
            }
        }

        // 带重试的图片下载函数
        async function downloadImageWithRetry(url, filename, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const blob = await response.blob();
                    
                    // 检查blob是否有效
                    if (blob.size === 0) {
                        throw new Error('下载的文件为空');
                    }
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    
                    // 确保链接被添加到DOM中
                    document.body.appendChild(link);
                    link.click();
                    
                    // 清理
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    
                    return true; // 下载成功
                    
                } catch (error) {
                    console.error(`下载尝试 ${attempt} 失败:`, error);
                    
                    if (attempt === maxRetries) {
                        throw error; // 最后一次尝试失败，抛出错误
                    }
                    
                    // 等待后重试
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
            return false;
        }

        // 重新下载失败的图片
        async function retryFailedDownloads(failedDownloads) {
        const debug = document.getElementById('debug');
            const downloadBtn = document.getElementById('downloadBtn');
            
            downloadBtn.textContent = '重试下载中...';
            debug.textContent += `\n\n🔄 开始重试下载 ${failedDownloads.length} 张失败的图片...`;
            
            let retrySuccessCount = 0;
            
            for (let i = 0; i < failedDownloads.length; i++) {
                const failed = failedDownloads[i];
                
                try {
                    debug.textContent += `\n重试下载第 ${failed.index} 张: ${failed.filename}`;
                    downloadBtn.textContent = `重试中... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` ✅ 重试成功`;
            } else {
                        debug.textContent += ` ❌ 重试仍然失败`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    debug.textContent += ` ❌ 重试失败: ${error.message}`;
                }
            }
            
            debug.textContent += `\n\n🔄 重试完成: ${retrySuccessCount}/${failedDownloads.length} 张成功`;
            
            if (retrySuccessCount === failedDownloads.length) {
                alert(`🎉 重试成功！所有图片都已下载完成！`);
        } else {
                alert(`重试完成: ${retrySuccessCount} 张成功，${failedDownloads.length - retrySuccessCount} 张仍然失败。\n请检查网络连接或手动保存失败的图片。`);
            }
            
            downloadBtn.textContent = '保存所有图片';
        }

        // 导出故事脚本为CSV
        function exportStoryToCsv() {
            if (storyScript.length === 0) {
                alert('没有可导出的故事脚本');
                return;
            }
            
            const debug = document.getElementById('debug');
            debug.textContent += '\n正在导出故事脚本为CSV...';
            
            try {
                // 准备CSV数据
                const csvHeaders = ['分镜序号', '文生图prompt', '参考图片数量', '参考图片名称', '生成数量', '创建时间'];
                const csvRows = [csvHeaders];
                
                // 添加数据行
                storyScript.forEach((item, index) => {
                    const promptText = document.getElementById(`storyPrompt_${index}`)?.value || item.prompt;
                    const refImageCount = item.refImages ? item.refImages.length : 0;
                    const refImageNames = item.refImages ? item.refImages.map(img => img.name).join(';') : '';
                    const currentTime = new Date().toLocaleString('zh-CN');
                    
                    csvRows.push([
                        item.index,
                        `"${promptText.replace(/"/g, '""')}"`, // 转义引号并用引号包围
                        refImageCount,
                        `"${refImageNames}"`,
                        item.imageCount,
                        currentTime
                    ]);
                });
                
                // 转换为CSV字符串
                const csvContent = csvRows.map(row => row.join(',')).join('\n');
                
                // 创建下载链接
                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' }); // 添加BOM以支持中文
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.setAttribute('href', url);
                link.setAttribute('download', `story_script_${timestamp}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                debug.textContent += '\n✅ 故事脚本CSV导出成功！';
                debug.textContent += `\n📁 文件名: story_script_${timestamp}.csv`;
                debug.textContent += `\n📊 导出${storyScript.length}个分镜的详细信息`;
                
                // 显示导出摘要
                const totalPromptLength = storyScript.reduce((sum, item, index) => {
                    const promptText = document.getElementById(`storyPrompt_${index}`)?.value || item.prompt;
                    return sum + promptText.length;
                }, 0);
                
                const exportSummary = `
📄 CSV导出完成！
📊 导出统计:
   - 分镜数量: ${storyScript.length}
   - 提示词总长度: ${totalPromptLength} 字符
   - 参考图片总数: ${storyScript.reduce((sum, item) => sum + (item.refImages ? item.refImages.length : 0), 0)}
   - 文件名: story_script_${timestamp}.csv
                `;
                
                alert(exportSummary);
                
        } catch (error) {
                debug.textContent += `\n❌ CSV导出失败: ${error.message}`;
                alert(`CSV导出失败：${error.message}`);
            }
        }

        // 验证垫图数据的有效性
        function validateRefImageData(refImageData, context = '') {
            const debug = document.getElementById('debug');
            
            debug.textContent += `\n🔍 ${context} 垫图数据验证:`;
            
            if (!refImageData) {
                debug.textContent += `\n❌ ${context}: 无垫图数据 (refImageData为null/undefined)`;
                return false;
            }
            
            if (typeof refImageData !== 'string') {
                debug.textContent += `\n❌ ${context}: 垫图数据类型错误 (${typeof refImageData}，应为string)`;
                return false;
            }
            
            if (!refImageData.trim()) {
                debug.textContent += `\n❌ ${context}: 垫图数据为空字符串`;
                return false;
            }
            
            debug.textContent += `\n   - 数据长度: ${refImageData.length} 字符`;
            debug.textContent += `\n   - 数据前缀: ${refImageData.substring(0, 50)}...`;
            
            if (!refImageData.startsWith('data:image/')) {
                debug.textContent += `\n❌ ${context}: 垫图数据格式错误 (不是有效的data:image/ URL)`;
                debug.textContent += `\n   实际开头: ${refImageData.substring(0, 50)}...`;
                return false;
            }
            
            // 检查base64数据的完整性
            const parts = refImageData.split(',');
            if (parts.length !== 2) {
                debug.textContent += `\n❌ ${context}: base64数据格式错误，分割后部分数: ${parts.length} (应为2)`;
                return false;
            }
            
            const [header, base64Part] = parts;
            debug.textContent += `\n   - MIME类型: ${header}`;
            debug.textContent += `\n   - base64长度: ${base64Part.length} 字符`;
            
            if (!base64Part || base64Part.length < 100) {
                debug.textContent += `\n❌ ${context}: base64数据过短或无效 (长度: ${base64Part ? base64Part.length : 0})`;
                return false;
            }
            
            // 检查base64字符的有效性
            const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
            if (!base64Regex.test(base64Part)) {
                debug.textContent += `\n❌ ${context}: base64数据包含无效字符`;
                return false;
            }
            
            // 计算图片大小
            const imageSizeKB = Math.round(base64Part.length * 0.75 / 1024);
            debug.textContent += `\n   - 估算图片大小: ${imageSizeKB}KB`;
            
            // 检查图片大小是否合理
            if (imageSizeKB > 10240) { // 10MB
                debug.textContent += `\n⚠️ ${context}: 垫图过大 (${imageSizeKB}KB)，可能导致API调用失败`;
            } else if (imageSizeKB < 1) {
                debug.textContent += `\n⚠️ ${context}: 垫图过小 (${imageSizeKB}KB)，可能质量不佳`;
            }
            
            debug.textContent += `\n✅ ${context}: 垫图数据验证通过 (${imageSizeKB}KB)`;
            return true;
        }

        // 🔍 调试故事数据状态的函数
        function debugStoryDataState() {
            const debug = document.getElementById('debug');
            debug.textContent += `\n\n🔍 === 故事数据状态调试 ===`;
            storyScript.forEach((item, index) => {
                debug.textContent += `\n📋 分镜${item.index} (索引${index}):`;
                debug.textContent += `\n   - refImages数组长度: ${item.refImages ? item.refImages.length : 'null'}`;
                if (item.refImages && item.refImages.length > 0) {
                    debug.textContent += `\n   - refImages详情: ${item.refImages.map((img, i) => `[${i}]${img.name}(${img.data ? '有数据' : '无数据'})`).join(', ')}`;
                }
                debug.textContent += `\n   - imageCount: ${item.imageCount}`;
            });
            debug.textContent += `\n🔍 === 调试结束 ===\n`;
        }

        // 清空故事历史图片
        function clearStoryHistory() {
            const debug = document.getElementById('debug');
            
            // 确认操作
            if (storyGeneratedImages.length === 0) {
                alert('当前没有历史图片可以清空');
                return;
            }
            
            const confirmMessage = `确定要清空所有历史图片吗？\n\n当前共有 ${storyGeneratedImages.length} 张图片将被清空：\n- 所有批次的生成记录\n- 所有下载和重试历史\n\n⚠️ 此操作不可撤销！`;
            
            if (!confirm(confirmMessage)) {
                debug.textContent += '\n⏹️ 用户取消了清空历史操作';
                return;
            }
            
            // 记录清空前的状态
            const clearedCount = storyGeneratedImages.length;
            const groupedByBatch = {};
            storyGeneratedImages.forEach(img => {
                const batchKey = img.batchIndex || 1;
                groupedByBatch[batchKey] = (groupedByBatch[batchKey] || 0) + 1;
            });
            
            // 清空数据
            storyGeneratedImages = [];
            
            // 更新UI
            updateStoryResult();
            
            // 隐藏下载按钮
            document.getElementById('downloadAllStoryBtn').style.display = 'none';
            
            // 记录操作日志
            debug.textContent += `\n\n🗑️ === 历史图片清空操作 ===`;
            debug.textContent += `\n🧹 清空时间: ${new Date().toLocaleString()}`;
            debug.textContent += `\n📊 清空统计: 共清空 ${clearedCount} 张图片`;
            debug.textContent += `\n📦 涉及批次: ${Object.keys(groupedByBatch).map(batch => `批次${batch}(${groupedByBatch[batch]}张)`).join(', ')}`;
            debug.textContent += `\n✅ 历史数据已完全清空，可以重新开始生成`;
            debug.textContent += `\n🔍 === 清空操作完成 ===\n`;
            
            // 显示成功消息
            alert(`🗑️ 历史图片清空完成！\n\n已清空 ${clearedCount} 张图片\n现在可以重新开始生成故事图片了`);
        }

        // 使用GBK编码读取文件（ANSI中文常用编码）
        function tryReadWithGBK(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                try {
                    // 使用TextDecoder尝试GBK解码
                    const decoder = new TextDecoder('gbk');
                    const csvText = decoder.decode(arrayBuffer);
                    
                    console.log('GBK解码结果前100字符:', csvText.substring(0, 100));
                    
                    if (csvText && csvText.trim() && isValidText(csvText)) {
                        console.log('使用GBK编码成功读取CSV文件');
                        parseCsvAndDisplayPreview(csvText);
                    } else {
                        console.log('GBK解码结果无效，尝试其他编码');
                        // GBK也失败，尝试其他编码
                        tryReadWithOtherEncodings(file);
                    }
                } catch (error) {
                    console.log('GBK解码失败:', error);
                    // GBK解码失败，尝试其他编码
                    tryReadWithOtherEncodings(file);
                }
            };
            reader.onerror = function() {
                console.log('ArrayBuffer读取失败，尝试其他编码...');
                tryReadWithOtherEncodings(file);
            };
            reader.readAsArrayBuffer(file); // 修复：使用readAsArrayBuffer而不是readAsText
        }
        
        // 尝试其他编码
        function tryReadWithOtherEncodings(file) {
            const encodings = ['gb2312', 'big5', 'windows-1252'];
            let encodingIndex = 0;
            
            function tryNextEncoding() {
                if (encodingIndex >= encodings.length) {
                    // 所有编码都失败，使用UTF-8作为最后尝试并提示用户
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const csvText = e.target.result;
                        console.warn('所有编码尝试完毕，使用UTF-8编码读取，可能存在乱码');
                        alert('文件编码检测失败，已使用UTF-8读取。\n\n如果出现乱码，请尝试：\n1. 将CSV文件另存为UTF-8编码\n2. 或使用我们提供的修复版本文件 prompt_fixed.csv');
                        parseCsvAndDisplayPreview(csvText);
                    };
                    reader.readAsText(file, 'UTF-8');
                    return;
                }
                
                const encoding = encodings[encodingIndex];
                console.log(`尝试使用${encoding}编码...`);
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        const decoder = new TextDecoder(encoding);
                        const csvText = decoder.decode(arrayBuffer);
                        
                        console.log(`${encoding}解码结果前100字符:`, csvText.substring(0, 100));
                        
                        if (csvText && csvText.trim() && isValidText(csvText)) {
                            console.log(`成功使用${encoding}编码读取文件`);
                            parseCsvAndDisplayPreview(csvText);
                        } else {
                            console.log(`${encoding}解码结果无效，尝试下一个编码`);
                            encodingIndex++;
                            tryNextEncoding();
                        }
                    } catch (error) {
                        console.log(`${encoding}解码失败:`, error);
                        encodingIndex++;
                        tryNextEncoding();
                    }
                };
                reader.readAsArrayBuffer(file);
            }
            
            tryNextEncoding();
        }
        
        // 检查文本是否为有效的UTF-8
        function isValidUTF8Text(text) {
            console.log('验证UTF-8文本，前100字符:', text.substring(0, 100));
            
            // 检查是否包含常见的乱码字符或异常字符
            const invalidChars = /[\uFFFD\u0000-\u0008\u000E-\u001F\u007F-\u009F]/;
            
            // 如果包含替换字符()或控制字符，可能是编码问题
            if (invalidChars.test(text)) {
                console.log('检测到无效字符，可能是编码问题');
                return false;
            }
            
            // 检查中文字符是否正常显示
            const chineseChars = text.match(/[\u4e00-\u9fff]/g);
            if (chineseChars) {
                console.log('检测到中文字符数量:', chineseChars.length);
                // 如果有中文字符，检查是否有连续的异常字符模式
                const suspiciousPattern = /[À-ÿ]{3,}/g; // 可能是GBK错误解码为UTF-8的模式
                if (suspiciousPattern.test(text)) {
                    console.log('检测到可疑的字符模式，可能是GBK编码');
                    return false;
                }
            }
            
            // 检查是否包含常见的CSV头部关键字
            const csvHeaders = /分镜序号|文生图|prompt|图转视频/;
            if (!csvHeaders.test(text.substring(0, 200))) {
                console.log('未检测到预期的CSV头部信息');
                return false;
            }
            
            console.log('UTF-8文本验证通过');
            return true;
        }
        
        // 检查文本是否有效（用于其他编码）
        function isValidText(text) {
            console.log('验证文本有效性，前100字符:', text.substring(0, 100));
            
            // 基本检查：文本不为空且包含可读字符
            if (!text || !text.trim()) {
                console.log('文本为空或只有空白字符');
                return false;
            }
            
            // 检查是否包含过多的异常字符
            const totalChars = text.length;
            const invalidChars = (text.match(/[\uFFFD\u0000-\u0008\u000E-\u001F\u007F-\u009F]/g) || []).length;
            
            // 如果异常字符超过5%，认为编码可能有问题
            if ((invalidChars / totalChars) >= 0.05) {
                console.log(`异常字符过多: ${invalidChars}/${totalChars} (${((invalidChars/totalChars)*100).toFixed(1)}%)`);
                return false;
            }
            
            // 检查是否包含常见的CSV头部关键字（中文）
            const csvHeaders = /分镜序号|文生图|prompt|图转视频|序号/;
            if (csvHeaders.test(text.substring(0, 200))) {
                console.log('检测到有效的CSV头部信息');
                return true;
            }
            
            // 检查是否有基本的CSV结构（至少包含逗号）
            const hasCSVStructure = text.includes(',') && text.includes('\n');
            if (hasCSVStructure) {
                console.log('检测到基本的CSV结构');
                return true;
            }
            
            console.log('文本格式验证失败');
            return false;
        }

        // API状态诊断和建议
        function diagnoseApiResponse(data, requestId) {
            const debug = document.getElementById('debug');
            
            debug.textContent += `\n\n🔧 [${requestId}] API响应格式诊断:`;
            
            // 检查响应结构
            const responseKeys = Object.keys(data);
            debug.textContent += `\n   📋 响应字段: ${responseKeys.join(', ')}`;
            
            // 检查是否是传统格式
            if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                debug.textContent += `\n   ✅ 检测到传统ChatGPT格式`;
                return 'traditional';
            }
            
            // 检查是否是新的异步格式
            if (data.prompt && data.ratio && data.n) {
                debug.textContent += `\n   ⚠️ 检测到新的异步格式 (仅返回参数确认)`;
                debug.textContent += `\n   💡 建议解决方案:`;
                debug.textContent += `\n      1. 检查云雾AI官方文档是否有API更新说明`;
                debug.textContent += `\n      2. 查看是否需要使用新的端点或参数`;
                debug.textContent += `\n      3. 确认是否需要异步轮询结果`;
                debug.textContent += `\n      4. 联系云雾AI技术支持获取最新API文档`;
                return 'async_params';
            }
            
            // 检查是否有任务ID
            if (data.task_id || data.id || data.job_id) {
                debug.textContent += `\n   ⏳ 检测到异步任务格式`;
                debug.textContent += `\n   💡 这种格式通常需要轮询任务状态`;
                return 'async_task';
            }
            
            // 检查是否直接包含图片URL
            if (data.image_url || data.url || (data.result && data.result.url)) {
                debug.textContent += `\n   ✅ 检测到直接URL格式`;
                return 'direct_url';
            }
            
            debug.textContent += `\n   ❓ 未知的响应格式`;
            return 'unknown';
        }

        // 显示API格式变化的用户提示
        // 轮询任务结果函数
        async function pollTaskResult(apiKey, taskId, requestId) {
            const debug = document.getElementById('debug');
            const maxAttempts = 30; // 最多轮询30次
            const pollInterval = 2000; // 每2秒轮询一次
            
            debug.textContent += `\n🔄 [${requestId}] 开始轮询任务结果，任务ID: ${taskId}`;
            debug.textContent += `\n⏱️ [${requestId}] 轮询设置: 间隔${pollInterval/1000}秒，最多${maxAttempts}次`;
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                debug.textContent += `\n🔄 [${requestId}] 轮询第${attempt}次...`;
                
                try {
                    // 等待指定时间
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                    
                    // 发送轮询请求 - 改为POST方法查询任务状态
                    const response = await fetch('https://yunwu.ai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: "sora_image",
                            task_id: taskId,
                            action: "query_status"
                        })
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        debug.textContent += `\n❌ [${requestId}] 轮询请求失败: ${response.status} ${response.statusText}`;
                        debug.textContent += `\n❌ [${requestId}] 错误详情: ${errorText}`;
                        
                        // 如果是404，可能是任务ID格式不对，尝试备用端点
                        if (response.status === 404 && attempt === 1) {
                            debug.textContent += `\n🔄 [${requestId}] 尝试备用轮询端点...`;
                            return await pollTaskResultAlternative(apiKey, taskId, requestId);
                        }
                        
                        continue; // 继续下一次轮询
                    }
                    
                    const data = await response.json();
                    debug.textContent += `\n📋 [${requestId}] 轮询响应: ${JSON.stringify(data)}`;
                    
                    // 检查任务是否完成
                    if (data.status === 'completed' || data.status === 'succeeded') {
                        // 尝试从不同的响应格式中提取图片URL
                        let imageUrl = null;
                        
                        if (data.output && data.output.length > 0) {
                            imageUrl = data.output[0];
                        } else if (data.result && data.result.url) {
                            imageUrl = data.result.url;
                        } else if (data.url) {
                            imageUrl = data.url;
                        } else if (data.image_url) {
                            imageUrl = data.image_url;
                        } else if (data.data && data.data.length > 0 && data.data[0].url) {
                            imageUrl = data.data[0].url;
                        }
                        
                        // 如果找到图片URL，返回成功
                        if (imageUrl) {
                            debug.textContent += `\n✅ [${requestId}] 任务完成，成功获取图片URL`;
                            return { success: true, imageUrl };
                        } else {
                            debug.textContent += `\n⚠️ [${requestId}] 任务完成但未找到图片URL`;
                        }
                    } else if (data.status === 'failed' || data.status === 'error') {
                        // 任务失败
                        const errorMessage = data.error || '任务执行失败';
                        debug.textContent += `\n❌ [${requestId}] 任务失败: ${errorMessage}`;
                        throw new Error(`任务执行失败: ${errorMessage}`);
                    } else {
                        // 任务仍在进行中
                        const progress = data.progress || '未知';
                        debug.textContent += `\n⏳ [${requestId}] 任务进行中，进度: ${progress}`;
                    }
                    
                } catch (error) {
                    debug.textContent += `\n❌ [${requestId}] 轮询过程出错: ${error.message}`;
                    // 继续轮询，不中断
                }
            }
            
            // 超过最大轮询次数
            debug.textContent += `\n⚠️ [${requestId}] 达到最大轮询次数(${maxAttempts})，任务可能仍在处理中`;
            throw new Error(`轮询超时，请稍后在历史记录中查看结果`);
        }
        
        // 备用轮询方法（使用不同的API端点格式）
        async function pollTaskResultAlternative(apiKey, taskId, requestId) {
            const debug = document.getElementById('debug');
            const maxAttempts = 30;
            const pollInterval = 2000;
            
            debug.textContent += `\n🔄 [${requestId}] 使用备用端点轮询任务结果`;
            
            // 尝试几种可能的API端点格式
            const endpoints = [
                `https://yunwu.ai/v1/${taskId}`,
                `https://yunwu.ai/${taskId}`,
                `https://yunwu.ai/v1/chat/completions/${taskId}`
            ];
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                debug.textContent += `\n🔄 [${requestId}] 备用轮询第${attempt}次...`;
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                
                // 尝试所有可能的端点
                for (const endpoint of endpoints) {
                    try {
                        debug.textContent += `\n🔍 [${requestId}] 尝试端点: ${endpoint}`;
                        
                        const response = await fetch('https://yunwu.ai/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: "sora_image",
                                task_id: taskId,
                                action: "query_status"
                            })
                        });
                        
                        if (!response.ok) {
                            continue; // 尝试下一个端点
                        }
                        
                        const data = await response.json();
                        debug.textContent += `\n📋 [${requestId}] 备用轮询响应: ${JSON.stringify(data)}`;
                        
                        // 尝试从响应中提取图片URL
                        let imageUrl = null;
                        const responseText = JSON.stringify(data);
                        const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                        const urls = responseText.match(urlRegex);
                        
                        if (urls && urls.length > 0) {
                            imageUrl = urls[0];
                            debug.textContent += `\n✅ [${requestId}] 从备用轮询中找到图片URL`;
                            return { success: true, imageUrl };
                        }
                        
                    } catch (error) {
                        debug.textContent += `\n❌ [${requestId}] 备用端点请求失败: ${error.message}`;
                    }
                }
            }
            
            debug.textContent += `\n⚠️ [${requestId}] 备用轮询达到最大次数，未能获取结果`;
            throw new Error('备用轮询失败，未能获取任务结果');
        }
        
        function showApiFormatChangeNotice() {
            const notice = document.createElement('div');
            notice.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                width: 400px;
                padding: 20px;
                background: linear-gradient(135deg, #4caf50, #8bc34a);
                color: white;
                border-radius: 10px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                z-index: 10000;
                font-family: Arial, sans-serif;
                font-size: 14px;
                line-height: 1.5;
            `;
            
            notice.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 24px; margin-right: 10px;">✅</span>
                    <strong style="font-size: 16px;">云雾API异步模式已适配</strong>
                </div>
                <p style="margin: 0 0 15px 0;">
                    检测到云雾API已更新为异步模式，系统已自动适配并支持轮询结果。
                </p>
                <ul style="margin: 0; padding-left: 20px;">
                    <li>图片生成可能需要更长时间，请耐心等待</li>
                    <li>系统会自动轮询任务状态直到完成</li>
                    <li>生成过程中可查看调试信息了解进度</li>
                </ul>
                <button onclick="this.parentElement.remove()" style="
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(255,255,255,0.3);
                    border: none;
                    color: white;
                    width: 25px;
                    height: 25px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 16px;
                ">×</button>
            `;
            
            document.body.appendChild(notice);
            
            // 5秒后自动消失
            setTimeout(() => {
                if (notice.parentElement) {
                    notice.remove();
                }
            }, 8000);
        }
</script>

    <!-- 云雾API优化补丁 -->
    <script>
// 云雾API优化补丁 - 基于测试结果的API调用优化
// 这个补丁基于我们的测试结果，使用成功率最高的API端点和格式

// 优化后的云雾API调用函数
async function callYunwuAPIOptimized(prompt, refImageData = null) {
    const apiKey = document.getElementById('apiKey').value;
    if (!apiKey) {
        throw new Error('请输入云雾API Key');
    }

    // 基于测试结果，优先使用成功率高的API
    const workingAPIs = [
        {
            name: 'Chat Completions API',
            endpoint: 'https://yunwu.ai/v1/chat/completions',
            createRequest: (prompt) => ({
                model: "sora_image",
                messages: [
                    {
                        role: "system",
                        content: "You are a helpful assistant."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ]
            }),
            extractImageUrl: (data) => {
                if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                    const content = data.choices[0].message.content;
                    // 提取图片URL
                    const urlMatch = content.match(/https?:\/\/[^\s"'\],})\n]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/i);
                    if (urlMatch) {
                        return urlMatch[0];
                    }
                }
                return null;
            }
        },
        {
            name: 'Images Generation API',
            endpoint: 'https://yunwu.ai/v1/images/generations',
            createRequest: (prompt) => ({
                prompt: prompt,
                model: "sora_image",
                n: 1,
                size: "1024x1024"
            }),
            extractImageUrl: (data) => {
                if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    return data.data[0].url;
                }
                return null;
            }
        }
    ];

    let lastError = null;

    // 尝试可用的API端点
    for (const api of workingAPIs) {
        try {
            console.log(`🔍 尝试 ${api.name}: ${api.endpoint}`);
            
            const requestBody = api.createRequest(prompt);
            console.log(`📦 请求体:`, requestBody);

            const response = await fetch(api.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'User-Agent': 'Sora-Image-Demo/1.0'
                },
                body: JSON.stringify(requestBody)
            });

            console.log(`📊 响应状态: ${response.status} ${response.statusText}`);

            if (response.ok) {
                const data = await response.json();
                console.log(`✅ 成功响应:`, data);
                
                const imageUrl = api.extractImageUrl(data);
                if (imageUrl) {
                    console.log(`🖼️ 提取到图片URL: ${imageUrl}`);
                    
                    // 验证图片URL是否可访问
                    try {
                        const imageResponse = await fetch(imageUrl, { method: 'HEAD' });
                        if (imageResponse.ok) {
                            console.log(`✅ 图片URL可访问 (${imageResponse.status})`);
                            return {
                                success: true,
                                imageUrl: imageUrl,
                                endpoint: api.endpoint,
                                apiName: api.name
                            };
                        } else {
                            console.log(`⚠️ 图片URL不可访问 (${imageResponse.status})`);
                            lastError = new Error(`图片URL不可访问: ${imageResponse.status}`);
                        }
                    } catch (urlError) {
                        console.log(`⚠️ 验证图片URL时出错: ${urlError.message}`);
                        // 仍然返回成功，因为API调用本身是成功的
                        return {
                            success: true,
                            imageUrl: imageUrl,
                            endpoint: api.endpoint,
                            apiName: api.name,
                            urlWarning: urlError.message
                        };
                    }
                } else {
                    console.log(`⚠️ 无法从响应中提取图片URL`);
                    lastError = new Error('无法从响应中提取图片URL');
                }
            } else {
                const errorText = await response.text();
                console.log(`❌ 错误响应: ${errorText}`);
                
                try {
                    const errorData = JSON.parse(errorText);
                    lastError = new Error(`HTTP ${response.status}: ${errorData.error?.message || errorText}`);
                } catch (e) {
                    lastError = new Error(`HTTP ${response.status}: ${errorText}`);
                }
            }
        } catch (error) {
            console.log(`💥 请求异常: ${error.message}`);
            lastError = error;
        }

        // 添加延迟避免请求过频
        await new Promise(resolve => setTimeout(resolve, 2000));
    }

    throw lastError || new Error('所有API端点都失败了');
}

// 优化的单个图片生成函数
async function generateSingleImageOptimized(apiKey, promptText, refImageData, groupIndex, imageIndex) {
    const debug = document.getElementById('debug');
    const requestId = `${groupIndex + 1}-${imageIndex + 1}`;
    
    debug.textContent += `\n\n🔍 [${requestId}] 开始处理图片生成请求 (优化版)`;
    debug.textContent += `\n📝 [${requestId}] 提示词: ${promptText.substring(0, 100)}...`;
    
    try {
        const result = await callYunwuAPIOptimized(promptText, refImageData);
        
        debug.textContent += `\n🎉 [${requestId}] 图片生成成功!`;
        debug.textContent += `\n🔗 [${requestId}] 使用API: ${result.apiName}`;
        debug.textContent += `\n🖼️ [${requestId}] 图片URL: ${result.imageUrl.substring(0, 50)}...`;
        
        if (result.urlWarning) {
            debug.textContent += `\n⚠️ [${requestId}] URL验证警告: ${result.urlWarning}`;
        }
        
        return {
            url: result.imageUrl,
            prompt: promptText,
            groupIndex: groupIndex,
            imageIndex: imageIndex,
            apiUsed: result.apiName,
            endpoint: result.endpoint
        };
        
    } catch (error) {
        debug.textContent += `\n💥 [${requestId}] 生成失败: ${error.message}`;
        throw error;
    }
}

// 优化的测试连接函数
async function testYunwuConnectionOptimized() {
    const apiKey = document.getElementById('apiKey').value;
    const testBtn = document.getElementById('testYunwuBtn');
    const debug = document.getElementById('debug');

    if (!apiKey) {
        alert('请输入云雾API Key');
        return;
    }

    testBtn.disabled = true;
    testBtn.textContent = '测试中...';
    debug.textContent += '\n\n🔍 开始测试云雾API连接 (优化版)...\n';

    try {
        const result = await callYunwuAPIOptimized('测试图片生成');
        
        debug.textContent += `\n✅ 连接测试成功!`;
        debug.textContent += `\n🔗 使用API: ${result.apiName}`;
        debug.textContent += `\n📍 端点: ${result.endpoint}`;
        debug.textContent += `\n🖼️ 测试图片: ${result.imageUrl}`;
        
        alert('✅ 云雾API连接测试成功!\n\n' + 
              `使用API: ${result.apiName}\n` +
              `端点: ${result.endpoint}\n` +
              `图片已生成: ${result.imageUrl.substring(0, 50)}...`);
              
    } catch (error) {
        debug.textContent += `\n❌ 连接测试失败: ${error.message}`;
        alert('❌ 云雾API连接测试失败:\n\n' + error.message);
    } finally {
        testBtn.disabled = false;
        testBtn.textContent = '测试连接';
    }
}

// 导出函数供全局使用
window.callYunwuAPIOptimized = callYunwuAPIOptimized;
window.generateSingleImageOptimized = generateSingleImageOptimized;
window.testYunwuConnectionOptimized = testYunwuConnectionOptimized;

console.log('✅ 云雾API优化补丁已加载');
    </script>

    <script>
        // 替换原有的测试连接函数
        if (typeof testYunwuConnection !== "undefined") {
            window.testYunwuConnectionOriginal = testYunwuConnection;
        }
        window.testYunwuConnection = testYunwuConnectionOptimized;
        
        // 替换原有的生成函数
        if (typeof generateSingleImage !== "undefined") {
            window.generateSingleImageOriginal = generateSingleImage;
        }
        window.generateSingleImage = generateSingleImageOptimized;
        
        console.log("✅ 云雾API已优化，使用基于测试结果的高成功率端点");
    </script>

    <!-- Failed to fetch 错误修复补丁 -->
    <script>
// 修复 Failed to fetch 错误的补丁

// 增强的fetch函数，添加更多错误处理和重试机制
async function enhancedFetch(url, options = {}) {
    const maxRetries = 3;
    const retryDelay = 2000; // 2秒
    
    // 根据URL设置不同的超时时间
    let timeoutMs = 60000; // 默认60秒
    if (url.includes('api.apicore.ai')) {
        timeoutMs = 180000; // APICore使用3分钟
    } else if (url.includes('yunwu.ai')) {
        timeoutMs = 120000; // 云雾API使用2分钟
    }
    
    // 创建兼容的超时控制器
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
        controller.abort();
    }, timeoutMs);
    
    // 默认选项
    const defaultOptions = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'User-Agent': 'Sora-Image-Demo/1.0',
            ...options.headers
        },
        signal: controller.signal,
        ...options
    };
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`🔄 尝试第 ${attempt} 次请求: ${url}`);
            
            const response = await fetch(url, defaultOptions);
            
            console.log(`📊 响应状态: ${response.status} ${response.statusText}`);
            
            // 如果响应成功，直接返回
            if (response.ok) {
                clearTimeout(timeoutId);
                return response;
            }
            
            // 如果是客户端错误（4xx），不重试
            if (response.status >= 400 && response.status < 500) {
                console.log(`❌ 客户端错误 (${response.status})，不重试`);
                clearTimeout(timeoutId);
                return response;
            }
            
            // 服务器错误（5xx），可以重试
            if (response.status >= 500 && attempt < maxRetries) {
                console.log(`⚠️ 服务器错误 (${response.status})，${retryDelay/1000}秒后重试...`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
                continue;
            }
            
            clearTimeout(timeoutId);
            return response;
            
        } catch (error) {
            console.log(`❌ 请求异常 (尝试 ${attempt}/${maxRetries}): ${error.message}`);
            
            // 分析错误类型
            if (error.name === 'AbortError') {
                console.log('⏰ 请求超时');
            } else if (error.message.includes('Failed to fetch')) {
                console.log('🌐 网络连接问题');
            } else if (error.message.includes('CORS')) {
                console.log('🔒 跨域问题');
            }
            
            // 如果是最后一次尝试，抛出错误
            if (attempt === maxRetries) {
                clearTimeout(timeoutId);
                throw new Error(`请求失败 (${maxRetries}次尝试): ${error.message}`);
            }
            
            // 等待后重试
            console.log(`⏳ ${retryDelay/1000}秒后重试...`);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
    }
}

// 优化的云雾API调用函数（修复版）
async function callYunwuAPIFixed(prompt, refImageData = null) {
    const apiKey = document.getElementById('apiKey').value;
    if (!apiKey) {
        throw new Error('请输入云雾API Key');
    }

    // 基于测试结果的API配置
    const workingAPIs = [
        {
            name: 'Chat Completions API',
            endpoint: 'https://yunwu.ai/v1/chat/completions',
            createRequest: (prompt) => ({
                model: "sora_image",
                messages: [
                    {
                        role: "system",
                        content: "You are a helpful assistant."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ]
            }),
            extractImageUrl: (data) => {
                if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                    const content = data.choices[0].message.content;
                    const urlMatch = content.match(/https?:\/\/[^\s"'\],})\n]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/i);
                    if (urlMatch) {
                        return urlMatch[0];
                    }
                }
                return null;
            }
        },
        {
            name: 'Images Generation API',
            endpoint: 'https://yunwu.ai/v1/images/generations',
            createRequest: (prompt) => ({
                prompt: prompt,
                model: "sora_image",
                n: 1,
                size: "1024x1024"
            }),
            extractImageUrl: (data) => {
                if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    return data.data[0].url;
                }
                return null;
            }
        }
    ];

    let lastError = null;

    // 尝试可用的API端点
    for (const api of workingAPIs) {
        try {
            console.log(`🔍 尝试 ${api.name}: ${api.endpoint}`);
            
            const requestBody = api.createRequest(prompt);
            console.log(`📦 请求体:`, requestBody);

            // 使用增强的fetch函数
            const response = await enhancedFetch(api.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`,
                    'User-Agent': 'Sora-Image-Demo/1.0'
                },
                body: JSON.stringify(requestBody)
            });

            if (response.ok) {
                const data = await response.json();
                console.log(`✅ 成功响应:`, data);
                
                const imageUrl = api.extractImageUrl(data);
                if (imageUrl) {
                    console.log(`🖼️ 提取到图片URL: ${imageUrl}`);
                    
                    return {
                        success: true,
                        imageUrl: imageUrl,
                        endpoint: api.endpoint,
                        apiName: api.name
                    };
                } else {
                    console.log(`⚠️ 无法从响应中提取图片URL`);
                    lastError = new Error('无法从响应中提取图片URL');
                }
            } else {
                const errorText = await response.text();
                console.log(`❌ 错误响应: ${errorText}`);
                
                try {
                    const errorData = JSON.parse(errorText);
                    lastError = new Error(`HTTP ${response.status}: ${errorData.error?.message || errorText}`);
                } catch (e) {
                    lastError = new Error(`HTTP ${response.status}: ${errorText}`);
                }
            }
        } catch (error) {
            console.log(`💥 请求异常: ${error.message}`);
            lastError = error;
        }

        // 添加延迟避免请求过频
        await new Promise(resolve => setTimeout(resolve, 1000));
    }

    throw lastError || new Error('所有API端点都失败了');
}

// 修复版的单个图片生成函数
async function generateSingleImageFixed(apiKey, promptText, refImageData, groupIndex, imageIndex) {
    const debug = document.getElementById('debug');
    const requestId = `${groupIndex + 1}-${imageIndex + 1}`;
    
    debug.textContent += `\n\n🔍 [${requestId}] 开始处理图片生成请求 (修复版)`;
    debug.textContent += `\n📝 [${requestId}] 提示词: ${promptText.substring(0, 100)}...`;
    
    try {
        const result = await callYunwuAPIFixed(promptText, refImageData);
        
        debug.textContent += `\n🎉 [${requestId}] 图片生成成功!`;
        debug.textContent += `\n🔗 [${requestId}] 使用API: ${result.apiName}`;
        debug.textContent += `\n🖼️ [${requestId}] 图片URL: ${result.imageUrl.substring(0, 50)}...`;
        
        return {
            url: result.imageUrl,
            prompt: promptText,
            groupIndex: groupIndex,
            imageIndex: imageIndex,
            apiUsed: result.apiName,
            endpoint: result.endpoint
        };
        
    } catch (error) {
        debug.textContent += `\n💥 [${requestId}] 生成失败: ${error.message}`;
        
        // 提供更详细的错误信息和建议
        if (error.message.includes('Failed to fetch')) {
            debug.textContent += `\n💡 [${requestId}] 建议: 检查网络连接，尝试刷新页面`;
        } else if (error.message.includes('timeout')) {
            debug.textContent += `\n💡 [${requestId}] 建议: 请求超时，请稍后重试`;
        } else if (error.message.includes('401')) {
            debug.textContent += `\n💡 [${requestId}] 建议: API Key可能无效，请检查`;
        }
        
        throw error;
    }
}

// 导出修复版函数
window.callYunwuAPIFixed = callYunwuAPIFixed;
window.generateSingleImageFixed = generateSingleImageFixed;
window.enhancedFetch = enhancedFetch;

console.log('🔧 Failed to fetch 错误修复补丁已加载');
    </script>

    <script>
        // 集成修复方案到主页面
        console.log("🔧 正在集成 Failed to fetch 错误修复方案...");
        
        // 备份原有函数
        if (typeof generateSingleImage !== "undefined") {
            window.generateSingleImageOriginal = generateSingleImage;
            console.log("📦 已备份原始 generateSingleImage 函数");
        }
        
        if (typeof testYunwuConnection !== "undefined") {
            window.testYunwuConnectionOriginal = testYunwuConnection;
            console.log("📦 已备份原始 testYunwuConnection 函数");
        }
        
        // 替换为修复版本
        window.generateSingleImage = generateSingleImageFixed;
        window.testYunwuConnection = async function() {
            const debug = document.getElementById("debug");
            const testBtn = document.getElementById("testYunwuBtn");
            
            if (!testBtn) {
                console.log("⚠️ 测试按钮未找到，使用默认测试");
                return;
            }
            
            testBtn.disabled = true;
            testBtn.textContent = "测试中...";
            debug.textContent += "\n\n🔍 开始测试云雾API连接 (修复版)...\n";
            
            try {
                const result = await callYunwuAPIFixed("测试连接");
                
                debug.textContent += `\n✅ 连接测试成功!`;
                debug.textContent += `\n🔗 使用API: ${result.apiName}`;
                debug.textContent += `\n📍 端点: ${result.endpoint}`;
                debug.textContent += `\n🖼️ 测试图片: ${result.imageUrl}`;
                
                alert("✅ 云雾API连接测试成功!\n\n" + 
                      `使用API: ${result.apiName}\n` +
                      `端点: ${result.endpoint}\n` +
                      `图片已生成: ${result.imageUrl.substring(0, 50)}...`);
                      
            } catch (error) {
                debug.textContent += `\n❌ 连接测试失败: ${error.message}`;
                alert("❌ 云雾API连接测试失败:\n\n" + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = "测试连接";
            }
        };
        
        // 添加修复状态指示
        const debugElement = document.getElementById("debug");
        if (debugElement) {
            debugElement.textContent = "🔧 Failed to fetch 错误修复补丁已加载\n" +
                                       "✅ 增强的网络请求功能已启用\n" +
                                       "🔄 自动重试机制已激活\n" +
                                       "⏰ 60秒超时保护已设置\n\n" +
                                       "等待操作...";
        }
        
        console.log("✅ Failed to fetch 错误修复方案已成功集成到主页面");
        console.log("🎯 现在可以正常使用云雾API功能了");
    </script>

    <!-- APICore平台集成 -->
    <script>
// APICore平台集成补丁
// 添加对APICore平台sora_image模型的支持

// APICore API调用函数（优化版）
async function callAPICore(prompt, apiKey, options = {}) {
    const {
        size = "1024x1024",
        quality = "hd",
        response_format = "url",
        n = 1
    } = options;

    console.log('🔍 调用APICore API (修复版)...');
    console.log(`📝 提示词: ${prompt.substring(0, 100)}...`);
    console.log(`🔑 API Key: ${apiKey.substring(0, 10)}...`);

    // 修复：确保请求体格式正确，参数类型正确
    const requestBody = {
        prompt: prompt.trim(),
        model: "sora_image",
        n: parseInt(n),
        size: size,
        quality: quality,
        response_format: response_format
    };

    console.log('📦 修复后的请求体:', requestBody);

    try {
        // 修复：使用更合理的超时时间（2分钟）
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            console.log('⏰ APICore请求即将超时 (2分钟)...');
            controller.abort();
        }, 120000); // 2分钟超时

        console.log('🚀 发送修复后的请求到 APICore...');
        const response = await fetch('https://api.apicore.ai/v1/images/generations', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'User-Agent': 'APICore-Fix/1.0',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestBody),
            signal: controller.signal
        });

        clearTimeout(timeoutId);
        console.log(`📊 APICore响应状态: ${response.status} ${response.statusText}`);

        // 修复：先获取响应文本，再解析JSON
        const responseText = await response.text();
        console.log(`📄 原始响应: ${responseText.substring(0, 200)}...`);

        if (response.ok) {
            try {
                const data = JSON.parse(responseText);
                console.log('✅ APICore成功响应:', data);

                // 提取图片URL
                if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                    const imageUrl = data.data[0].url || data.data[0].b64_json;
                    if (imageUrl) {
                        console.log(`🖼️ 提取到图片URL: ${imageUrl.substring(0, 50)}...`);
                        return {
                            success: true,
                            imageUrl: imageUrl,
                            platform: 'APICore',
                            model: 'sora_image',
                            created: data.created
                        };
                    }
                }

                throw new Error('无法从APICore响应中提取图片URL');
            } catch (parseError) {
                console.log(`❌ JSON解析失败: ${parseError.message}`);
                throw new Error(`响应解析失败: ${parseError.message}`);
            }
        } else {
            console.log(`❌ APICore错误响应: ${responseText}`);
            
            try {
                const errorData = JSON.parse(responseText);
                const errorMessage = errorData.error?.message || errorData.message || responseText;
                
                // 提供更详细的错误信息
                if (response.status === 401) {
                    throw new Error(`APICore认证失败: 请检查API Key是否正确 (${errorMessage})`);
                } else if (response.status === 429) {
                    throw new Error(`APICore请求过于频繁: 请稍后再试 (${errorMessage})`);
                } else if (response.status === 400) {
                    throw new Error(`APICore请求参数错误: ${errorMessage}`);
                } else {
                    throw new Error(`APICore API错误 (${response.status}): ${errorMessage}`);
                }
            } catch (parseError) {
                throw new Error(`APICore API错误 (${response.status}): ${responseText}`);
            }
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log(`⏰ APICore请求超时 (2分钟)`);
            throw new Error('APICore请求超时，图片生成时间过长，请稍后重试');
        }
        
        console.log(`💥 APICore请求异常: ${error.message}`);
        throw error;
    }
}

// 测试APICore连接（优化版）
async function testAPICoreConnection(apiKey) {
    const debug = document.getElementById('debug');
    
    debug.textContent += '\n\n🔍 开始测试APICore连接...\n';
    debug.textContent += `🔑 API Key: ${apiKey.substring(0, 15)}...\n`;
    debug.textContent += `⏰ 超时设置: 3分钟\n`;

    try {
        const result = await callAPICore('测试图片生成', apiKey, {
            size: "512x512",
            n: 1
        });

        debug.textContent += `✅ APICore连接测试成功!\n`;
        debug.textContent += `🏢 平台: ${result.platform}\n`;
        debug.textContent += `🤖 模型: ${result.model}\n`;
        debug.textContent += `🖼️ 测试图片: ${result.imageUrl}\n`;

        return result;
    } catch (error) {
        debug.textContent += `❌ APICore连接测试失败: ${error.message}\n`;
        throw error;
    }
}

// 增强的图片生成函数，支持多平台
async function generateImageMultiPlatform(promptText, platforms, groupIndex, imageIndex) {
    const debug = document.getElementById('debug');
    const requestId = `${groupIndex + 1}-${imageIndex + 1}`;
    
    debug.textContent += `\n\n🔍 [${requestId}] 开始多平台图片生成`;
    debug.textContent += `\n📝 [${requestId}] 提示词: ${promptText.substring(0, 100)}...`;
    debug.textContent += `\n🏢 [${requestId}] 可用平台: ${platforms.map(p => p.name).join(', ')}`;

    let lastError = null;

    // 按优先级尝试各个平台
    for (const platform of platforms) {
        try {
            debug.textContent += `\n🔍 [${requestId}] 尝试平台: ${platform.name}`;
            
            let result;
            
            if (platform.name === 'APICore') {
                result = await callAPICore(promptText, platform.apiKey, {
                    size: platform.size || "1024x1024",
                    quality: platform.quality || "hd",
                    n: 1
                });
            } else if (platform.name === '云雾API') {
                result = await callYunwuAPIFixed(promptText);
            } else {
                throw new Error(`不支持的平台: ${platform.name}`);
            }

            debug.textContent += `\n🎉 [${requestId}] ${platform.name} 生成成功!`;
            debug.textContent += `\n🖼️ [${requestId}] 图片URL: ${result.imageUrl.substring(0, 50)}...`;

            return {
                url: result.imageUrl,
                prompt: promptText,
                groupIndex: groupIndex,
                imageIndex: imageIndex,
                platform: platform.name,
                model: result.model || 'sora_image'
            };

        } catch (error) {
            debug.textContent += `\n❌ [${requestId}] ${platform.name} 失败: ${error.message}`;
            lastError = error;
            
            // 如果不是最后一个平台，继续尝试下一个
            if (platform !== platforms[platforms.length - 1]) {
                debug.textContent += `\n🔄 [${requestId}] 尝试下一个平台...`;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
    }

    // 所有平台都失败了
    debug.textContent += `\n💥 [${requestId}] 所有平台都失败了`;
    throw lastError || new Error('所有图片生成平台都不可用');
}

// 获取配置的平台列表
function getConfiguredPlatforms() {
    const platforms = [];
    
    // 检查云雾API
    const yunwuApiKey = document.getElementById('apiKey')?.value;
    if (yunwuApiKey) {
        platforms.push({
            name: '云雾API',
            apiKey: yunwuApiKey,
            priority: 1
        });
    }
    
    // 检查APICore
    const apicoreApiKey = document.getElementById('apicoreApiKey')?.value;
    if (apicoreApiKey) {
        platforms.push({
            name: 'APICore',
            apiKey: apicoreApiKey,
            priority: 2,
            size: document.getElementById('apicoreSize')?.value || "1024x1024",
            quality: document.getElementById('apicoreQuality')?.value || "hd"
        });
    }
    
    // 按优先级排序
    platforms.sort((a, b) => a.priority - b.priority);
    
    return platforms;
}

// 导出函数供全局使用
window.callAPICore = callAPICore;
window.testAPICoreConnection = testAPICoreConnection;
window.generateImageMultiPlatform = generateImageMultiPlatform;
window.getConfiguredPlatforms = getConfiguredPlatforms;

console.log('✅ APICore平台集成补丁已加载');
    </script>

    <script>
        // APICore UI交互函数
        function toggleAPICoreSettings() {
            const settings = document.getElementById("apicoreAdvancedSettings");
            const showBtn = document.getElementById("showAPICoreSettingsBtn");
            
            if (settings.style.display === "none") {
                settings.style.display = "block";
                showBtn.style.display = "none";
            } else {
                settings.style.display = "none";
                showBtn.style.display = "inline-block";
            }
        }
        
        // APICore连接测试 UI 函数
        async function testAPICoreConnection() {
            const apiKey = document.getElementById("apicoreApiKey").value;
            const testBtn = document.getElementById("testAPICoreBtn");
            
            if (!apiKey) {
                alert("请输入APICore API Key");
                return;
            }
            
            testBtn.disabled = true;
            testBtn.textContent = "测试中...";
            
            try {
                // 调用内部的测试函数
                const result = await window.testAPICoreConnection(apiKey);
                alert("✅ APICore连接测试成功!\n\n" +
                      `平台: ${result.platform}\n` +
                      `模型: ${result.model}\n` +
                      `测试图片: ${result.imageUrl.substring(0, 50)}...`);
            } catch (error) {
                alert("❌ APICore连接测试失败:\n\n" + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = "测试连接";
            }
        }
        
        // 多平台图片生成 - 图转提示词
        async function generateAllImagesMultiPlatform() {
            const generateBtn = document.getElementById("generateBtn");
            const debug = document.getElementById("debug");
            
            if (promptsData.length === 0) {
                alert("请先生成提示词");
                return;
            }
            
            const platforms = getConfiguredPlatforms();
            if (platforms.length === 0) {
                alert("请至少配置一个API平台 (云雾API 或 APICore)");
                return;
            }
            
            generateBtn.disabled = true;
            generateBtn.textContent = "生成中...";
            debug.textContent += `\n\n🚀 开始多平台批量生成图片...`;
            debug.textContent += `\n🏢 可用平台: ${platforms.map(p => p.name).join(", ")}`;
            
            try {
                generatedImages = [];
                const imageCount = parseInt(document.getElementById("imageCount").value) || 1;
                
                for (let groupIndex = 0; groupIndex < promptsData.length; groupIndex++) {
                    const promptData = promptsData[groupIndex];
                    
                    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
                        try {
                            const result = await generateImageMultiPlatform(
                                promptData.prompt,
                                platforms,
                                groupIndex,
                                imageIndex
                            );
                            generatedImages.push(result);
                        } catch (error) {
                            debug.textContent += `\n❌ 第 ${groupIndex + 1}-${imageIndex + 1} 张图片生成失败: ${error.message}`;
                        }
                    }
                }
                
                displayGeneratedImages();
                debug.textContent += `\n\n🎉 批量生成完成! 成功: ${generatedImages.length} 张`;
                
            } catch (error) {
                debug.textContent += `\n💥 批量生成过程出错: ${error.message}`;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = "批量生成图片 (多平台)";
            }
        }
        
        // 多平台图片生成 - 故事提示词
        async function generateAllStoryImagesMultiPlatform() {
            const generateBtn = document.getElementById("generateAllStoryBtn");
            const debug = document.getElementById("debug");
            
            if (storyScript.length === 0) {
                alert("请先生成故事脚本或导入CSV文件");
                return;
            }
            
            const platforms = getConfiguredPlatforms();
            if (platforms.length === 0) {
                alert("请至少配置一个API平台 (云雾API 或 APICore)");
                return;
            }
            
            generateBtn.disabled = true;
            generateBtn.textContent = "生成中...";
            debug.textContent += `\n\n🎬 开始多平台故事分镜生成...`;
            debug.textContent += `\n🏢 可用平台: ${platforms.map(p => p.name).join(", ")}`;
            
            try {
                storyGeneratedImages = [];
                
                for (let sceneIndex = 0; sceneIndex < storyScript.length; sceneIndex++) {
                    const scene = storyScript[sceneIndex];
                    const imageCount = scene.imageCount || 1;
                    
                    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
                        try {
                            const result = await generateImageMultiPlatform(
                                scene.prompt,
                                platforms,
                                sceneIndex,
                                imageIndex
                            );
                            storyGeneratedImages.push(result);
                        } catch (error) {
                            debug.textContent += `\n❌ 分镜 ${scene.index}-${imageIndex + 1} 生成失败: ${error.message}`;
                        }
                    }
                }
                
                displayStoryImages();
                debug.textContent += `\n\n🎉 故事分镜生成完成! 成功: ${storyGeneratedImages.length} 张`;
                
            } catch (error) {
                debug.textContent += `\n💥 故事生成过程出错: ${error.message}`;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = "🎬 一键生成整个故事 (多平台)";
            }
        }
        
        console.log("✅ APICore UI集成完成");
    </script>
</body>
</html>