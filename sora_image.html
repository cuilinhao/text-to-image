
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Sora Image Demo</title>
    <style>
        body {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tab-container {
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-buttons {
            display: flex;
            gap: 0;
        }
        .tab-button {
            padding: 12px 20px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-bottom: none;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
        }
        .tab-button.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
            color: #1890ff;
        }
        .tab-button:hover {
            background-color: #e6f7ff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="text"], input[type="password"], input[type="number"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            width: 100px;
        }
        button {
            padding: 10px 20px;
            background-color: #1890ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
        }
        button.secondary {
            background-color: #52c41a;
        }
        button.secondary:disabled {
            background-color: #ccc;
        }
        button.download {
            background-color: #722ed1;
            margin-left: 10px;
        }
        .result {
            margin-top: 20px;
        }
        img {
            max-width: 100%;
            margin-top: 10px;
        }
        .debug {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .image-preview {
            max-width: 200px;
            margin: 5px;
            border: 1px solid #ddd;
            padding: 5px;
            display: inline-block;
        }
        .upload-area {
            border: 2px dashed #ddd;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .upload-area:hover {
            border-color: #1890ff;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .prompt-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
        }
        .prompt-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .prompt-item img {
            max-width: 100px;
            max-height: 100px;
        }
        .prompt-item textarea {
            flex: 1;
            height: 60px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .image-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background-color: white;
        }
        .image-item img {
            width: 100%;
            height: auto;
            border-radius: 4px;
        }
        .image-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .image-controls button {
            flex: 1;
            padding: 5px 10px;
            font-size: 12px;
        }
        .btn-download {
            background-color: #52c41a;
        }
        .btn-copy {
            background-color: #1890ff;
        }
        .btn-retry {
            background-color: #fa8c16;
        }
        .inline-control {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .inline-control label {
            white-space: nowrap;
        }
        
        /* æ•…äº‹æç¤ºè¯ç‰¹æœ‰æ ·å¼ */
        .story-item {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: white;
            align-items: flex-start;
        }
        .story-index {
            min-width: 50px;
            font-weight: bold;
            color: #666;
            text-align: center;
            padding-top: 10px;
        }
        .story-prompt {
            flex: 1;
        }
        .story-prompt textarea {
            height: 80px;
            margin-bottom: 10px;
        }
        .story-ref-images {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .story-ref-images img {
            max-width: 60px;
            max-height: 60px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .story-ref-images img.selected {
            border-color: #1890ff;
            border-width: 2px;
        }
        .story-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            min-width: 200px;
            flex-direction: column;
        }
        .story-controls .button-group {
            width: 100%;
        }
        .file-input-button {
            background-color: #fa8c16;
            cursor: pointer;
        }
        .csv-preview {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: white;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sora Image Demo - æ‰¹é‡å›¾ç‰‡ç”Ÿæˆå™¨</h1>
        
        <!-- æ ‡ç­¾é¡µ -->
        <div class="tab-container">
            <div class="tab-buttons">
                <div class="tab-button active" onclick="switchTab('imageToPrompt')">å›¾è½¬æç¤ºè¯</div>
                <div class="tab-button" onclick="switchTab('storyPrompt')">æ•…äº‹æç¤ºè¯</div>
            </div>
        </div>
        
        <!-- å›¾è½¬æç¤ºè¯æ ‡ç­¾é¡µ -->
        <div id="imageToPrompt" class="tab-content active">
            <!-- ä½¿ç”¨æç¤º -->
            <div style="background-color: #e6f7ff; border: 1px solid #91d5ff; border-radius: 6px; padding: 16px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #1890ff;">ğŸ’¡ ä½¿ç”¨æç¤º</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li><strong>å›¾ç‰‡è¦æ±‚</strong>ï¼šå»ºè®®ä¸Šä¼ æ¸…æ™°çš„è§’è‰²å›¾ç‰‡ï¼Œé¿å…è¿‡äºæš´éœ²æˆ–æ•æ„Ÿçš„å†…å®¹</li>
                    <li><strong>æ¨¡å‹é€‰æ‹©</strong>ï¼šå¯ä»¥æ‰‹åŠ¨é€‰æ‹©ä¸åŒçš„æ¨¡å‹ï¼Œå¦‚Claude-3 Sonnetå¯¹å†…å®¹é™åˆ¶è¾ƒä¸ºå®½æ¾</li>
                    <li><strong>å›¾ç‰‡å‹ç¼©</strong>ï¼šç³»ç»Ÿä¼šè‡ªåŠ¨å°†å›¾ç‰‡å‹ç¼©åˆ°1024pxä»¥å†…ï¼Œæé«˜å¤„ç†æˆåŠŸç‡</li>
                    <li><strong>æ‰¹é‡å¤„ç†</strong>ï¼šå¯ä¸€æ¬¡ä¸Šä¼ å¤šå¼ å›¾ç‰‡ï¼Œç³»ç»Ÿä¼šä¾æ¬¡ä¸ºæ¯å¼ å›¾ç‰‡ç”Ÿæˆæ—¶å°šTå°æç¤ºè¯</li>
                    <li><strong>å¤šå¹³å°æ”¯æŒ</strong>ï¼šç°å·²æ”¯æŒäº‘é›¾(yunwu.ai)å’ŒAPICore(apicore.ai)ä¸¤ä¸ªå›¾ç‰‡ç”Ÿæˆå¹³å°</li>
                </ul>
            </div>
            
            <!-- OpenRouter æç¤ºè¯ç”Ÿæˆç»„ -->
            <div class="control-group">
                <h3>ğŸ¤– AI æç¤ºè¯ç”Ÿæˆå™¨</h3>
                
                <div class="input-group">
                    <label for="openrouterKey">OpenRouter API Key:</label>
                    <div class="button-group">
                        <input type="password" id="openrouterKey" placeholder="è¾“å…¥ä½ çš„ OpenRouter API Key" style="flex: 1;" value="">
                        <button onclick="testOpenRouterConnection()" id="testBtn" style="width: auto; padding: 8px 16px;">æµ‹è¯•è¿æ¥</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="modelSelect">é€‰æ‹©æ¨¡å‹:</label>
                    <select id="modelSelect">
                        <option value="openai/gpt-4o-mini" selected>GPT-4o Mini</option>
                        <option value="openai/gpt-4.1-mini">GPT-4.1 Mini</option>
                        <option value="openai/gpt-4-vision-preview">GPT-4 Vision</option>
                        <option value="openai/gpt-4o">GPT-4o</option>
                        <option value="anthropic/claude-3-opus">Claude-3 Opus</option>
                        <option value="anthropic/claude-3-sonnet">Claude-3 Sonnet</option>
                        <option value="google/gemini-pro-vision">Gemini Pro Vision</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>å‚è€ƒå›¾ç‰‡ç›®å½• (å¯é€‰æ‹©å¤šå¼ å›¾ç‰‡):</label>
                    <div class="upload-area" onclick="document.getElementById('refImageInput').click()">
                        ç‚¹å‡»é€‰æ‹©å¤šå¼ å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ
                        <input type="file" id="refImageInput" accept="image/*" multiple style="display: none" onchange="handleRefImageUpload(event)">
                    </div>
                    <div id="refImagePreview"></div>
                </div>

                <div class="input-group">
                    <label for="metaPrompt">å…ƒæç¤ºè¯:</label>
                    <textarea id="metaPrompt" placeholder="è¯·æ ¹æ®ä¸Šä¼ çš„å›¾ç‰‡ï¼Œç”Ÿæˆä¸€ä¸ªè¯¦ç»†çš„AIç»˜ç”»æç¤ºè¯ï¼Œè¦æ±‚åŒ…å«ç”»é¢æ„å›¾ã€è‰²å½©ã€é£æ ¼ã€ç»†èŠ‚ç­‰æè¿°...">ä½ æ˜¯ä¸€ä½AIå›¾åƒæç¤ºè¯é€ å‹å¸ˆï¼Œä¸“æ”»å°†ä»»æ„è§’è‰²å½¢è±¡åœ¨å®Œç¾ä¿ç•™å…¶æ ¸å¿ƒè¯†åˆ«ç‰¹å¾çš„å‰æä¸‹ï¼Œç²¾å‡†è½¬åŒ–ä¸º'èŒç³»å©´å„¿/å¹¼ç«¥è¶…æ¨¡'ï¼Œå¹¶ä¸ºå…¶å®šåˆ¶ç®€æ´ã€é«˜å†²å‡»åŠ›ã€æå…·è§†è§‰ç¾æ„Ÿçš„Tå°èµ°ç§€é€ å‹æç¤ºè¯ã€‚æˆ‘ä¼šæä¾›ä¸€å¼ æ‹ŸäººåŒ–è§’è‰²çš„å›¾ç‰‡ã€‚
ä½ çš„ä»»åŠ¡æ˜¯ï¼š
æ·±åº¦åˆ†æå¹¶ç‰¢è®°æä¾›çš„å‚è€ƒå›¾è§’è‰²çš„æ ¸å¿ƒé¢éƒ¨ç‰¹å¾ã€äº”å®˜é£æ ¼åŠç¥éŸµã€‚
åŸºäºæ­¤ï¼Œå°†è§’è‰²é‡å¡‘ä¸ºä¸€ä¸ªäº”å®˜ç²¾è‡´ã€è„¸é¢Šè‚‰å˜Ÿå˜Ÿã€è¡¨æƒ…ç”ŸåŠ¨å¯çˆ±çš„å©´å„¿/å¹¼ç«¥ç‰ˆæœ¬ï¼Œç¡®ä¿å…¶ä¸€çœ¼å°±èƒ½è¢«è®¤å‡ºæ˜¯åŸè§’è‰²çš„å©´å„¿å½¢æ€ã€‚
ä¸ºè¿™ä¸ª'ä¿ç•™äº†åŸè§’è‰²ç¥éŸµçš„å©´å„¿è¶…æ¨¡'ç”Ÿæˆä¸€æ®µé«˜åº¦å‡ç»ƒã€å…³é”®è¯é©±åŠ¨ã€é¿å…å†—ä½™æè¿°çš„æ–‡æœ¬åˆ°å›¾åƒæç¤ºè¯ã€‚ä½¿å…¶ç©¿ç€æˆäººé«˜çº§æ—¶å°š/æ½®æµæœé¥°çš„è¿·ä½ ç²¾åç‰ˆï¼ˆä¸¥ç¦ä½¿ç”¨æ™®é€šæ—¥å¸¸å©´å„¿æœè£…æ¦‚å¿µï¼Œå¦‚è¿ä½“è¡£ã€å°¿å¸ƒè£¤ã€ä¼ ç»Ÿå©´å„¿å¸½ç­‰ï¼Œé™¤éè¢«æåº¦æ—¶å°šåŒ–è§£æ„é‡å¡‘ï¼‰ï¼Œåœ¨æ˜ç¡®æ— è¯¯çš„Tå°ç§€èˆå°ç¯å¢ƒä¸­è‡ªä¿¡èµ°ç§€ã€‚
ã€é‡è¦ï¼ç”Ÿæˆçš„æ–‡ç”Ÿå›¾æç¤ºè¯ç»“æ„ä¸å†…å®¹æ ¸å¿ƒè¦æ±‚ã€‘
å¼€ç¯‡æŒ‡ä»¤ï¼ˆç»å¯¹ç²¾ç‚¼ï¼‰ï¼š ä½ ç”Ÿæˆçš„å…·ä½“æ–‡ç”Ÿå›¾æç¤ºè¯ï¼Œå¼€ç¯‡å¿…é¡»ç”¨æœ€ç®€çŸ­ã€æœ€å¼ºåŠ¿çš„æŒ‡ä»¤ç›´æ¥ç‚¹æ˜æ ¸å¿ƒç”»é¢ï¼š
æ ¼å¼ç¤ºä¾‹ï¼š ä¸»é¢˜ï¼š[ä¾‹å¦‚ï¼Œå’–å•¡æ¯å¨ƒå¨ƒ]å©´å„¿è¶…æ¨¡Tå°ç§€ï¼Œå®Œç¾å¤åˆ»åŸç‰ˆäº”å®˜ç¥éŸµï¼Œç”œç¾å¾®ç¬‘ï¼Œ100%æ­£è„¸ç›´è§†é•œå¤´ï¼Œè¿é¢èµ°æ¥ï¼Œç¥é‡‡å¥•å¥•ã€‚ (æ­¤å¤„çš„"[ä¾‹å¦‚ï¼Œå’–å•¡æ¯å¨ƒå¨ƒ]"éœ€è¦ä½ æ ¹æ®æˆ‘æä¾›çš„å›¾ç‰‡åŠ¨æ€æ›¿æ¢)
æœè£…æè¿°ï¼ˆå…³é”®è¯é©±åŠ¨ï¼Œæ‹’ç»å¹³åº¸ï¼‰ï¼š
é£æ ¼å®šä½ï¼š æ˜ç¡®ä¸€ç§æˆ–å‡ ç§èåˆçš„æˆäººæ—¶å°šé£æ ¼ï¼ˆå¦‚ï¼šè¿·ä½ å“¥ç‰¹æœ‹å…‹ã€å®å®é«˜å®šè¡—å¤´ã€è½¯èŒèµ›åšæœºèƒ½ã€å¤å¤å¥¢åY2Kç­‰ï¼‰ã€‚
æ ¸å¿ƒå•å“ï¼š ç”¨ç²¾å‡†çš„å…³é”®è¯æè¿°1-3ä»¶æœ€å…·ä»£è¡¨æ€§çš„**"æˆäººæ—¶å°šè¿·ä½ ç‰ˆ"æ ¸å¿ƒæœé¥°å•å“** (ä¾‹å¦‚ï¼šå¾®ç¼©ç‰ˆè§£æ„ä¸»ä¹‰é£è¡£ã€è¶…è¿·ä½ äº®ç‰‡é£è¡Œå‘˜å¤¹å…‹ã€å±‚å è–„çº±è›‹ç³•çŸ­è£™é…è¿·ä½ é©¬ä¸é´)ã€‚
è‰²å½©ä¸æè´¨ï¼š ç®€è¿°ä¸»è‰²è°ƒå’Œçªå‡ºæè´¨ï¼ˆä¾‹å¦‚ï¼šæš—é»‘æ’è‰²éœ“è™¹ã€é©¬å¡é¾™è‰²ç³»ä¸ç»’ã€é‡‘å±è´¨æ„Ÿçš®é©ï¼‰ã€‚
ç‚¹ç›é…é¥°ï¼š æåŠ1-2ä¸ªæ—¶å°šæ„Ÿå¼ºã€ç¬¦åˆæ•´ä½“é£æ ¼çš„è¿·ä½ é…é¥° (ä¾‹å¦‚ï¼šè¶…å°å·é“¾æ¡åŒ…ã€è¶£å‘³å¢¨é•œã€é€ å‹å¤¸å¼ çš„è¿·ä½ å¤´é¥°)ã€‚
ç»å¯¹é¿å…ï¼š æ™®é€šçš„å©´å„¿æœè£…æè¿°ï¼Œå¦‚"å¯çˆ±çš„è¿ä½“è¡£"ã€"æŸ”è½¯çš„æ¯›çº¿å¸½"ç­‰ï¼Œé™¤éå®ƒä»¬è¢«èµ‹äºˆäº†æå¼ºçš„æ—¶å°šè®¾è®¡æ„Ÿå’Œè§£æ„å…ƒç´ ã€‚ç›®æ ‡æ˜¯"ç©¿ç€ç¼©å°ç‰ˆé«˜å®šæ—¶è£…çš„å©´å„¿"ï¼Œè€Œä¸æ˜¯"ç©¿ç€å©´å„¿æœçš„å©´å„¿"ã€‚
Tå°åœºæ™¯ä¸æ°›å›´ï¼ˆä¸€å¥è¯ç‚¹æ˜ï¼Œå¼ºåˆ¶Tå°ï¼‰ï¼š
ç¯å¢ƒé£æ ¼ï¼š å¿…é¡»æ˜ç¡®æŒ‡å®šä¸ºTå°ç§€èˆå°ç¯å¢ƒï¼Œä¾‹å¦‚ï¼šåœºæ™¯ï¼šæœªæ¥ç§‘æŠ€æ„Ÿå…‰å½±Tå°ï¼ŒèƒŒæ™¯åŠ¨æ€ç²’å­ç‰¹æ•ˆã€‚ æˆ– åœºæ™¯ï¼šæ¢¦å¹»ç³–æœåŸå ¡ä¸»é¢˜Tå°ï¼ŒæŸ”å’Œæ™¯æ·±ã€‚ æˆ– åœºæ™¯ï¼šç®€çº¦å‡ ä½•çº¿æ¡Tå°ï¼Œèšç„¦ç¯å…‰ã€‚ ä¸¥ç¦ä½¿ç”¨éTå°çš„æ—¥å¸¸æˆ–è‡ªç„¶åœºæ™¯ã€‚
ç¯å…‰æ°›å›´ï¼š ä¾‹å¦‚ï¼šç¯å…‰ï¼šä¸“ä¸šTå°èšç„¦é¡¶å…‰ï¼Œæ°›å›´è¿·å¹»ã€‚
ç”»è´¨ä¸æ„å›¾ï¼ˆå›ºå®šæŒ‡ä»¤ï¼‰ï¼š
ç”»è´¨ï¼šè¶…ç²¾ç»†3Dæ¸²æŸ“ï¼Œç”µå½±çº§è´¨æ„Ÿï¼Œç»†èŠ‚çˆ†æ£šã€‚
æœ«å°¾å¿…é¡»æ·»åŠ ï¼š ratio 9:16
ã€å¯¹æˆ‘ï¼ˆAIé€ å‹å¸ˆï¼‰ç”Ÿæˆæç¤ºè¯çš„é¢å¤–çº¦æŸã€‘
æåº¦ç®€æ´ï¼š ä½ ç”Ÿæˆçš„æ¯ä¸€æ®µæè¿°ï¼ˆæœè£…ã€åœºæ™¯ç­‰ï¼‰éƒ½åº”åŠ›æ±‚ç”¨æœ€å°‘çš„è¯è¯­è¡¨è¾¾æœ€æ ¸å¿ƒçš„è§†è§‰ä¿¡æ¯ã€‚é¿å…ä½¿ç”¨è¿‡å¤šå½¢å®¹è¯å’Œé‡å¤æ€§æè¿°ã€‚
å†²å‡»åŠ›ä¸è®°å¿†ç‚¹ï¼š ä¼˜å…ˆä½¿ç”¨èƒ½äº§ç”Ÿå¼ºçƒˆè§†è§‰è”æƒ³å’Œç‹¬ç‰¹è®°å¿†ç‚¹çš„å…³é”®è¯ã€‚
å¿ äºåŸè§’è‰²ç¥éŸµï¼š åœ¨å©´å„¿åŒ–çš„åŒæ—¶ï¼Œå¿…é¡»é€šè¿‡å¯¹é¢éƒ¨ç‰¹å¾çš„å¼ºè°ƒï¼Œç¡®ä¿è§’è‰²çš„å¯è¯†åˆ«åº¦ã€‚
æ—¶å°šæ„Ÿä¼˜å…ˆï¼š åœ¨"èŒ"çš„åŸºç¡€ä¸Šï¼Œæœè£…å’Œæ•´ä½“é€ å‹çš„"æ—¶å°šæ„Ÿ"å’Œ"è®¾è®¡æ„Ÿ"æ˜¯æ›´é«˜ä¼˜å…ˆçº§ã€‚
åœºæ™¯å¼ºåˆ¶Tå°ï¼š æ— è®ºæœè£…é£æ ¼å¦‚ä½•ï¼ŒèƒŒæ™¯ç¯å¢ƒå¿…é¡»å§‹ç»ˆæ˜¯Tå°ç§€çš„èˆå°ã€‚
è¯·ä¸¥æ ¼æŒ‰ç…§æ­¤V5.1å…ƒæç¤ºè¯çš„æŒ‡å¯¼æ€æƒ³å’Œç»“æ„è¦æ±‚ï¼Œä¸ºæˆ‘ç”Ÿæˆå…·ä½“è§’è‰²çš„æ–‡ç”Ÿå›¾æç¤ºè¯ã€‚</textarea>
                </div>

                <button onclick="generatePrompts()" id="generatePromptBtn" class="secondary">æ‰¹é‡ç”Ÿæˆ Prompts</button>
            </div>

            <!-- ç”Ÿæˆçš„æç¤ºè¯åˆ—è¡¨ -->
            <div class="control-group" id="promptListGroup" style="display: none;">
                <h3>ğŸ“ ç”Ÿæˆçš„æç¤ºè¯åˆ—è¡¨</h3>
                <div class="prompt-list" id="promptList"></div>
            </div>

            <!-- å¤šå¹³å°å›¾ç‰‡ç”Ÿæˆç»„ -->
            <div class="control-group">
                <h3>ğŸ¨ å›¾ç‰‡ç”Ÿæˆ (æ”¯æŒäº‘é›¾/APICore)</h3>
                
                <div class="input-group">
                    <label for="apiPlatform">é€‰æ‹©APIå¹³å°:</label>
                    <select id="apiPlatform" onchange="updateApiKeyLabel()">
                        <option value="yunwu">äº‘é›¾ (yunwu.ai)</option>
                        <option value="apicore">APICore (apicore.ai)</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="apiKey" id="apiKeyLabel">äº‘é›¾ API Key:</label>
                    <input type="password" id="apiKey" placeholder="è¾“å…¥ä½ çš„API Key" value="" oninput="saveApiConfig()">
                </div>

                <div class="inline-control">
                    <label for="imageCount">ç”Ÿæˆæ•°é‡:</label>
                    <input type="number" id="imageCount" min="1" max="10" value="1">
                    <span>å¼ å›¾ç‰‡ (æ¯ä¸ªæç¤ºè¯)</span>
                </div>

                <div class="button-group">
                    <button onclick="generateAllImages()" id="generateBtn">æ‰¹é‡ç”Ÿæˆå›¾ç‰‡</button>
                    <button onclick="downloadAllImages()" id="downloadBtn" class="download" style="display: none;">ä¿å­˜æ‰€æœ‰å›¾ç‰‡</button>
                </div>
            </div>
        </div>
        
        <!-- æ•…äº‹æç¤ºè¯æ ‡ç­¾é¡µ -->
        <div id="storyPrompt" class="tab-content">
            <!-- ä½¿ç”¨æç¤º -->
            <div style="background-color: #fff2e8; border: 1px solid #ffbb96; border-radius: 6px; padding: 16px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #fa8c16;">ğŸ“– æ•…äº‹æç¤ºè¯åŠŸèƒ½è¯´æ˜</h4>
                <ul style="margin: 0; padding-left: 20px;">
                    <li><strong>AIç”Ÿæˆæ•…äº‹</strong>ï¼šé€šè¿‡å…ƒæç¤ºè¯+ç›®å½•å›¾ç‰‡è‡ªåŠ¨ç”Ÿæˆæ•…äº‹åˆ†é•œè„šæœ¬</li>
                    <li><strong>CSVå¯¼å…¥</strong>ï¼šæ”¯æŒå¯¼å…¥ç°æœ‰çš„æ•…äº‹è„šæœ¬æ–‡ä»¶ï¼ŒåŒ…å«åˆ†é•œåºå·å’Œæ–‡ç”Ÿå›¾prompt</li>
                    <li><strong>å‚è€ƒå›¾ç‰‡</strong>ï¼šä¸ºæ¯ä¸ªåˆ†é•œæŒ‡å®šå‚è€ƒå›¾ç‰‡ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åŒ¹é…æˆ–æ‰‹åŠ¨é€‰æ‹©</li>
                    <li><strong>æ‰¹é‡ç”Ÿæˆ</strong>ï¼šä¸€é”®ç”Ÿæˆæ•´ä¸ªæ•…äº‹çš„æ‰€æœ‰åˆ†é•œå›¾ç‰‡</li>
                </ul>
            </div>
            
            <!-- AI æ•…äº‹ç”Ÿæˆå™¨ -->
            <div class="control-group">
                <h3>ğŸ¤– AI æ•…äº‹ç”Ÿæˆå™¨</h3>
                
                <div class="input-group">
                    <label for="storyMetaPrompt">æ•…äº‹å…ƒæç¤ºè¯:</label>
                    <textarea id="storyMetaPrompt" placeholder="æè¿°ä½ æƒ³è¦ç”Ÿæˆçš„æ•…äº‹ç±»å‹ã€é£æ ¼ã€ä¸»é¢˜ç­‰...">è¯·æ ¹æ®æä¾›çš„ç›®å½•å›¾ç‰‡ï¼Œä¸ºæˆ‘ç”Ÿæˆä¸€ä¸ª10-15ä¸ªåˆ†é•œçš„æ•…äº‹è„šæœ¬ã€‚æ¯ä¸ªåˆ†é•œåº”è¯¥åŒ…å«è¯¦ç»†çš„æ–‡ç”Ÿå›¾promptï¼Œæè¿°ç”»é¢æ„å›¾ã€è§’è‰²ã€åŠ¨ä½œã€ç¯å¢ƒã€è‰²å½©ã€é£æ ¼ç­‰ã€‚æ•…äº‹åº”è¯¥æœ‰æ˜ç¡®çš„èµ·æ‰¿è½¬åˆï¼Œæƒ…èŠ‚ç”ŸåŠ¨æœ‰è¶£ã€‚

è¦æ±‚ï¼š
1. æ¯ä¸ªåˆ†é•œçš„promptåº”è¯¥è¯¦ç»†å…·ä½“ï¼ŒåŒ…å«ç”»é¢çš„æ‰€æœ‰é‡è¦å…ƒç´ 
2. æ•…äº‹æƒ…èŠ‚è¦è¿è´¯ï¼Œæœ‰èµ·ä¼å’Œè½¬æŠ˜
3. ç”»é¢æè¿°è¦ç”ŸåŠ¨ï¼Œå¯Œæœ‰è§†è§‰å†²å‡»åŠ›
4. é£æ ¼ä¿æŒä¸€è‡´ï¼Œé€‚åˆAIå›¾åƒç”Ÿæˆ

è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š
åˆ†é•œ1ï¼š[è¯¦ç»†çš„æ–‡ç”Ÿå›¾prompt]
åˆ†é•œ2ï¼š[è¯¦ç»†çš„æ–‡ç”Ÿå›¾prompt] 
...

å¼€å§‹ç”Ÿæˆæ•…äº‹åˆ†é•œè„šæœ¬ï¼š</textarea>
    </div>

    <div class="input-group">
                    <label>æ•…äº‹ç›®å½•å›¾ç‰‡ (å¯é€‰æ‹©å¤šå¼ å›¾ç‰‡ä½œä¸ºæ•…äº‹å‚è€ƒ):</label>
                    <div class="upload-area" onclick="document.getElementById('storyRefImageInput').click()">
            ç‚¹å‡»é€‰æ‹©å¤šå¼ å›¾ç‰‡æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ
                        <input type="file" id="storyRefImageInput" accept="image/*" multiple style="display: none" onchange="handleStoryRefImageUpload(event)">
        </div>
        <div id="storyRefImagePreview"></div>
    </div>

                <button onclick="generateStoryScript()" id="generateStoryBtn" class="secondary">ç”Ÿæˆæ•…äº‹è„šæœ¬</button>
            </div>
            
            <!-- CSV å¯¼å…¥åŠŸèƒ½ -->
            <div class="control-group">
                <h3>ğŸ“ CSV æ•…äº‹è„šæœ¬å¯¼å…¥</h3>
                
                <div class="input-group">
                    <label>é€‰æ‹©CSVæ–‡ä»¶ (åŒ…å«åˆ†é•œåºå·å’Œæ–‡ç”Ÿå›¾prompt):</label>
    <div class="button-group">
                        <input type="file" id="csvFileInput" accept=".csv" style="display: none" onchange="handleCsvImport(event)">
                        <button onclick="document.getElementById('csvFileInput').click()" class="file-input-button">é€‰æ‹©CSVæ–‡ä»¶</button>
                        <span id="csvFileName">æœªé€‰æ‹©æ–‡ä»¶</span>
    </div>
                    <div id="csvPreview" class="csv-preview" style="display: none;"></div>
</div>
</div>

            <!-- æ•…äº‹è„šæœ¬ç¼–è¾‘å™¨ -->
            <div class="control-group" id="storyEditorGroup" style="display: none;">
                <h3>ğŸ“ æ•…äº‹åˆ†é•œè„šæœ¬ç¼–è¾‘å™¨</h3>
                
                <div class="inline-control" style="margin-bottom: 15px;">
                    <label for="batchImageCount">æ‰¹é‡ç”Ÿæˆæ•°é‡:</label>
                    <input type="number" id="batchImageCount" min="1" max="10" value="2">
                    <span>å¼ å›¾ç‰‡ (æ¯ä¸ªåˆ†é•œ)</span>
                    <button onclick="setBatchImageCount()" style="margin-left: 10px; background-color: #52c41a; color: white;">ğŸ“‹ åº”ç”¨åˆ°æ‰€æœ‰åˆ†é•œ</button>
                    <small style="color: #666; margin-left: 10px;">ğŸ’¡ è®¾ç½®æ¯ä¸ªåˆ†é•œç”Ÿæˆçš„å›¾ç‰‡æ•°é‡</small>
    </div>

                <div class="button-group" style="margin-bottom: 15px;">
                    <button onclick="generateAllStoryImages()" id="generateAllStoryBtn" class="secondary">ğŸ¬ ä¸€é”®ç”Ÿæˆæ•´ä¸ªæ•…äº‹</button>
                    <button onclick="downloadAllStoryImages()" id="downloadAllStoryBtn" class="download" style="display: none;">ä¿å­˜æ‰€æœ‰å›¾ç‰‡</button>
                    <button onclick="batchDeleteStoryItems()" id="batchDeleteBtn" style="background-color: #fa8c16; color: white;">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤åˆ†é•œ</button>
                    <button onclick="clearStoryHistory()" id="clearHistoryBtn" style="background-color: #ff4d4f; color: white;">ğŸ—‘ï¸ æ¸…ç©ºå†å²</button>
                    <button onclick="exportStoryToCsv()" id="exportStoryBtn" style="background-color: #722ed1; color: white;">ğŸ“„ å¯¼å‡ºCSV</button>
    </div>

                <div id="storyScriptEditor"></div>
    </div>
</div>

        <div class="result" id="result"></div>
    <div class="debug" id="debug"></div>
</div>

<script>
        // åŸæœ‰å˜é‡
        let refImages = [];
        let promptsData = [];
        let generatedImages = [];
        
        // æ•…äº‹ç›¸å…³å˜é‡
        let storyRefImages = [];
        let storyScript = [];
        let storyGeneratedImages = [];
        
        // æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½
        function switchTab(tabName) {
            // éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            
            // ç§»é™¤æ‰€æœ‰æ ‡ç­¾æŒ‰é’®çš„activeçŠ¶æ€
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));
            
            // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µå†…å®¹
            document.getElementById(tabName).classList.add('active');
            
            // è®¾ç½®å¯¹åº”æŒ‰é’®ä¸ºactiveçŠ¶æ€
            event.target.classList.add('active');
        }
        
        // æ•…äº‹å‚è€ƒå›¾ç‰‡ä¸Šä¼ å¤„ç†
        function handleStoryRefImageUpload(event) {
            const files = Array.from(event.target.files);
            storyRefImages = [];
            
            files.forEach((file, index) => {
                compressImage(file, (compressedDataUrl) => {
                    storyRefImages.push({
                        data: compressedDataUrl,
                        name: file.name
                    });
                    
                    if (index === files.length - 1) {
                        displayStoryRefImages();
                    }
                });
            });
        }
        
        function displayStoryRefImages() {
            const preview = document.getElementById('storyRefImagePreview');
            preview.innerHTML = storyRefImages.map((img, index) => 
                `<img src="${img.data}" alt="Story Reference ${index + 1}" class="image-preview" title="${img.name}">`
            ).join('');
        }
        
        // CSVæ–‡ä»¶å¯¼å…¥å¤„ç†
        function handleCsvImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('csvFileName').textContent = file.name;
            
            // å°è¯•æ£€æµ‹ç¼–ç å¹¶è¯»å–æ–‡ä»¶
            tryReadCsvWithEncoding(file);
        }
        
        function tryReadCsvWithEncoding(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¹±ç æˆ–æ— æ•ˆå­—ç¬¦
                if (isValidUTF8Text(csvText)) {
                    console.log('ä½¿ç”¨UTF-8ç¼–ç æˆåŠŸè¯»å–CSVæ–‡ä»¶');
                    parseCsvAndDisplayPreview(csvText);
                } else {
                    console.log('UTF-8ç¼–ç è¯»å–å¼‚å¸¸ï¼Œå°è¯•ANSIç¼–ç ...');
                    // UTF-8å¤±è´¥ï¼Œå°è¯•GBKç¼–ç  (å¸¸ç”¨äºANSIä¸­æ–‡)
                    tryReadWithGBK(file);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }
        
        function parseCsvAndDisplayPreview(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            const preview = document.getElementById('csvPreview');
            const storyEditorGroup = document.getElementById('storyEditorGroup');
            
            // è§£æCSV
            storyScript = [];
            const headers = lines[0].split(',');
            
            // æ‰¾åˆ°åˆ†é•œåºå·å’Œæ–‡ç”Ÿå›¾promptçš„åˆ—ç´¢å¼•
            const indexCol = headers.findIndex(h => h.includes('åˆ†é•œåºå·') || h.includes('åºå·'));
            const promptCol = headers.findIndex(h => h.includes('æ–‡ç”Ÿå›¾prompt') || h.includes('prompt'));
            
            if (indexCol === -1 || promptCol === -1) {
                alert('CSVæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ç¡®ä¿åŒ…å«"åˆ†é•œåºå·"å’Œ"æ–‡ç”Ÿå›¾prompt"åˆ—');
                return;
            }
            
            // è§£ææ•°æ®è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length > Math.max(indexCol, promptCol)) {
                    storyScript.push({
                        index: values[indexCol]?.trim() || (i).toString(),
                        prompt: values[promptCol]?.trim() || '',
                        refImages: [], // åˆå§‹ä¸ºç©ºï¼Œç”¨æˆ·å¯ä»¥æ‰‹åŠ¨æŒ‡å®š
                        imageCount: 1
                    });
                }
            }
            
            // æ˜¾ç¤ºé¢„è§ˆ
            preview.style.display = 'block';
            preview.innerHTML = `
                <h4>CSVé¢„è§ˆ (å…±${storyScript.length}ä¸ªåˆ†é•œ):</h4>
                <div style="max-height: 150px; overflow-y: auto;">
                    ${storyScript.slice(0, 5).map(item => 
                        `<div><strong>åˆ†é•œ${item.index}:</strong> ${item.prompt.substring(0, 100)}${item.prompt.length > 100 ? '...' : ''}</div>`
                    ).join('')}
                    ${storyScript.length > 5 ? '<div><em>... è¿˜æœ‰æ›´å¤šåˆ†é•œ</em></div>' : ''}
                </div>
            `;
            
            // æ˜¾ç¤ºç¼–è¾‘å™¨
            displayStoryEditor();
            storyEditorGroup.style.display = 'block';
        }
        
        // ç”ŸæˆAIæ•…äº‹è„šæœ¬
        async function generateStoryScript() {
        const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const metaPrompt = document.getElementById('storyMetaPrompt').value;
            const generateStoryBtn = document.getElementById('generateStoryBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey || !metaPrompt) {
                alert('è¯·è¾“å…¥ OpenRouter API Key å’Œæ•…äº‹å…ƒæç¤ºè¯');
                return;
            }

            generateStoryBtn.disabled = true;
            generateStoryBtn.textContent = 'ç”Ÿæˆä¸­...';
            debug.textContent = 'æ­£åœ¨ç”Ÿæˆæ•…äº‹è„šæœ¬...\n';

            try {
                const messages = [
                    {
                        role: "user",
                        content: metaPrompt
                    }
                ];
                
                // å¦‚æœæœ‰å‚è€ƒå›¾ç‰‡ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯ä¸­
                if (storyRefImages.length > 0) {
                    messages[0].content = [
                        {
                            type: "text",
                            text: metaPrompt
                        },
                        ...storyRefImages.map(img => ({
                            type: "image_url",
                            image_url: {
                                url: img.data
                            }
                        }))
                    ];
                }

            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Sora Image Demo'
                },
                body: JSON.stringify({
                        model: model,
                        messages: messages,
                        max_tokens: 2000
                })
            });

                const data = await response.json();
                debug.textContent += `API å“åº”çŠ¶æ€: ${response.status}\n`;
                
                if (response.ok && data.choices && data.choices.length > 0) {
                    const storyText = data.choices[0]?.message?.content;
                    parseStoryScript(storyText);
                    debug.textContent += `âœ… æ•…äº‹è„šæœ¬ç”ŸæˆæˆåŠŸï¼`;
            } else {
                    debug.textContent += `âŒ API è¯·æ±‚å¤±è´¥: ${data.error?.message || 'æœªçŸ¥é”™è¯¯'}`;
                    alert('æ•…äº‹ç”Ÿæˆå¤±è´¥ï¼Œè¯·æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯');
            }
                
        } catch (error) {
                debug.textContent += `âŒ å‘ç”Ÿé”™è¯¯: ${error.message}`;
                alert(`å‘ç”Ÿé”™è¯¯ï¼š${error.message}`);
        } finally {
                generateStoryBtn.disabled = false;
                generateStoryBtn.textContent = 'ç”Ÿæˆæ•…äº‹è„šæœ¬';
            }
        }
        
        function parseStoryScript(storyText) {
            // è§£æAIç”Ÿæˆçš„æ•…äº‹æ–‡æœ¬
            const lines = storyText.split('\n').filter(line => line.trim());
            storyScript = [];
            
            let currentIndex = 1;
            for (const line of lines) {
                // åŒ¹é…ç±»ä¼¼ "åˆ†é•œ1ï¼š"ã€"åˆ†é•œ 1ï¼š"ã€"1."ã€"ç¬¬1ä¸ªåˆ†é•œ" ç­‰æ ¼å¼
                const match = line.match(/(?:åˆ†é•œ|ç¬¬)?\s*(\d+)(?:ä¸ªåˆ†é•œ)?[ï¼š:\.]\s*(.+)/);
                if (match) {
                    storyScript.push({
                        index: match[1],
                        prompt: match[2].trim(),
                        refImages: [],
                        imageCount: 1
                    });
                } else if (line.trim() && !line.includes('åˆ†é•œ') && storyScript.length > 0) {
                    // å¯èƒ½æ˜¯ç»­è¡Œçš„æè¿°
                    storyScript[storyScript.length - 1].prompt += ' ' + line.trim();
                }
            }
            
            // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•æŒ‰æ®µè½åˆ†å‰²
            if (storyScript.length === 0) {
                const paragraphs = storyText.split('\n\n').filter(p => p.trim());
                paragraphs.forEach((paragraph, index) => {
                    if (paragraph.trim()) {
                        storyScript.push({
                            index: (index + 1).toString(),
                            prompt: paragraph.trim(),
                            refImages: [],
                            imageCount: 1
                        });
                    }
                });
            }
            
            displayStoryEditor();
            document.getElementById('storyEditorGroup').style.display = 'block';
        }
        
        // æ˜¾ç¤ºæ•…äº‹ç¼–è¾‘å™¨
        function displayStoryEditor() {
            const editor = document.getElementById('storyScriptEditor');
            editor.innerHTML = storyScript.map((item, index) => `
                <div class="story-item" id="storyItem_${index}">
                    <div class="story-index">åˆ†é•œ<br>${item.index}</div>
                    <div class="story-prompt">
                        <textarea id="storyPrompt_${index}" placeholder="åˆ†é•œæç¤ºè¯...">${item.prompt}</textarea>
                        <div class="story-ref-images" id="storyRefImages_${index}">
                            ${item.refImages.map((img, imgIndex) => 
                                `<img src="${img.data}" title="${img.name}" onclick="removeStoryRefImage(${index}, ${imgIndex})" class="selected">`
                            ).join('')}
                            <div style="padding: 20px; border: 1px dashed #ddd; cursor: pointer; font-size: 12px; text-align: center; min-width: 60px;" 
                                 onclick="selectStoryRefImage(${index})">
                                ç‚¹å‡»é€‰æ‹©<br>å‚è€ƒå›¾ç‰‡
                            </div>
                        </div>
                    </div>
                    <div class="story-controls">
                        <div class="inline-control">
                            <label>æ•°é‡:</label>
                            <input type="number" id="storyImageCount_${index}" min="1" max="10" value="${item.imageCount}" 
                                   onchange="updateStoryImageCount(${index})">
                        </div>
                        <div class="button-group">
                            <button onclick="generateSingleStoryImage(${index})" class="secondary">ç”Ÿæˆå›¾ç‰‡</button>
                            <button onclick="deleteStoryItem(${index})" class="btn-delete" style="background-color: #ff4d4f; color: white; margin-top: 5px; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; font-size: 12px; transition: background-color 0.3s;" onmouseover="this.style.backgroundColor='#f5222d'" onmouseout="this.style.backgroundColor='#ff4d4f'">ğŸ—‘ï¸ åˆ é™¤åˆ†é•œ</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        // é€‰æ‹©æ•…äº‹å‚è€ƒå›¾ç‰‡
        function selectStoryRefImage(storyIndex) {
            if (storyRefImages.length === 0) {
                alert('è¯·å…ˆåœ¨ä¸Šæ–¹ä¸Šä¼ æ•…äº‹å‚è€ƒå›¾ç‰‡');
                return;
            }
            
            // åˆ›å»ºå›¾ç‰‡é€‰æ‹©å¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 1000; display: flex; 
                justify-content: center; align-items: center;
            `;
            
            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 8px; max-width: 98%; max-height: 90%; overflow-y: auto; min-height: 70vh;">
                    <h3>é€‰æ‹©å‚è€ƒå›¾ç‰‡ (å•å‡»å¤šé€‰ï¼ŒåŒå‡»å¿«é€Ÿç¡®è®¤)</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin: 20px 0;">
                        ${storyRefImages.map((img, index) => `
                            <div style="text-align: center; cursor: pointer; border: 2px solid transparent; padding: 5px;" 
                                 onclick="toggleImageSelection(this, ${index})" 
                                 ondblclick="quickSelectImage(${storyIndex}, ${index})" 
                                 id="selectImg_${index}">
                                <img src="${img.data}" style="width: 140px; height: 140px; object-fit: cover; border-radius: 4px;">
                                <div style="font-size: 12px; margin-top: 5px; word-wrap: break-word; max-width: 140px;">${img.name}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="text-align: center; gap: 10px; display: flex; justify-content: center;">
                        <button onclick="confirmImageSelection(${storyIndex})" class="secondary">ç¡®è®¤é€‰æ‹©</button>
                        <button onclick="closeImageSelection()">å–æ¶ˆ</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            window.currentModal = modal;
            window.selectedImages = [];
        }
        
        function toggleImageSelection(element, imageIndex) {
            if (element.style.borderColor === 'rgb(24, 144, 255)') {
                element.style.borderColor = 'transparent';
                window.selectedImages = window.selectedImages.filter(i => i !== imageIndex);
            } else {
                element.style.borderColor = '#1890ff';
                window.selectedImages.push(imageIndex);
            }
        }
        
        // åŒå‡»å¿«é€Ÿé€‰æ‹©å›¾ç‰‡å¹¶ç¡®è®¤
        function quickSelectImage(storyIndex, imageIndex) {
            // æ¸…é™¤å½“å‰æ‰€æœ‰é€‰æ‹©
            window.selectedImages = [];
            // æ¸…é™¤æ‰€æœ‰å›¾ç‰‡çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('[id^="selectImg_"]').forEach(el => {
                el.style.borderColor = 'transparent';
            });
            
            // é€‰ä¸­å½“å‰åŒå‡»çš„å›¾ç‰‡
            window.selectedImages = [imageIndex];
            const element = document.getElementById(`selectImg_${imageIndex}`);
            if (element) {
                element.style.borderColor = '#1890ff';
            }
            
            // ç›´æ¥ç¡®è®¤é€‰æ‹©
            confirmImageSelection(storyIndex);
        }
        
        function confirmImageSelection(storyIndex) {
            if (window.selectedImages.length === 0) {
                alert('è¯·é€‰æ‹©è‡³å°‘ä¸€å¼ å‚è€ƒå›¾ç‰‡');
                return;
            }
            
            storyScript[storyIndex].refImages = window.selectedImages.map(i => storyRefImages[i]);
            displayStoryEditor();
            closeImageSelection();
        }
        
        function closeImageSelection() {
            if (window.currentModal) {
                document.body.removeChild(window.currentModal);
                window.currentModal = null;
                window.selectedImages = [];
            }
        }
        
        function removeStoryRefImage(storyIndex, imgIndex) {
            storyScript[storyIndex].refImages.splice(imgIndex, 1);
            displayStoryEditor();
        }
        
        function updateStoryImageCount(storyIndex) {
            const count = parseInt(document.getElementById(`storyImageCount_${storyIndex}`).value);
            storyScript[storyIndex].imageCount = count;
        }
        
        // åˆ é™¤æŒ‡å®šçš„æ•…äº‹åˆ†é•œ
        function deleteStoryItem(storyIndex) {
            const item = storyScript[storyIndex];
            const confirmMessage = `ç¡®å®šè¦åˆ é™¤åˆ†é•œ ${item.index} å—ï¼Ÿ\n\nåˆ†é•œå†…å®¹ï¼š${item.prompt.substring(0, 100)}${item.prompt.length > 100 ? '...' : ''}\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // ä»æ•°ç»„ä¸­åˆ é™¤è¯¥åˆ†é•œ
            storyScript.splice(storyIndex, 1);
            
            // åˆ é™¤å¯¹åº”çš„å·²ç”Ÿæˆå›¾ç‰‡
            const originalLength = storyGeneratedImages.length;
            storyGeneratedImages = storyGeneratedImages.filter(img => {
                // ä¿ç•™å…¶ä»–åˆ†é•œçš„å›¾ç‰‡ï¼Œåˆ é™¤å½“å‰åˆ†é•œçš„å›¾ç‰‡
                return img.storyItemIndex !== item.index;
            });
            
            const deletedImagesCount = originalLength - storyGeneratedImages.length;
            
            // é‡æ–°æ˜¾ç¤ºç¼–è¾‘å™¨
            displayStoryEditor();
            
            // æ›´æ–°ç»“æœæ˜¾ç¤º
            if (storyGeneratedImages.length > 0) {
                updateStoryResult();
            } else {
                // å¦‚æœæ²¡æœ‰å›¾ç‰‡äº†ï¼Œæ¸…ç©ºç»“æœåŒºåŸŸ
                const result = document.getElementById('result');
                result.innerHTML = '';
            }
            
            // æ˜¾ç¤ºåˆ é™¤ç»“æœ
            const debug = document.getElementById('debug');
            debug.textContent += `\nğŸ—‘ï¸ å·²åˆ é™¤åˆ†é•œ ${item.index}`;
            if (deletedImagesCount > 0) {
                debug.textContent += `ï¼ŒåŒæ—¶åˆ é™¤äº† ${deletedImagesCount} å¼ ç›¸å…³å›¾ç‰‡`;
            }
            
            // æ›´æ–°CSVé¢„è§ˆæ˜¾ç¤º
            updateCsvPreview();
            
            alert(`âœ… åˆ†é•œ ${item.index} åˆ é™¤æˆåŠŸï¼${deletedImagesCount > 0 ? `\nåŒæ—¶åˆ é™¤äº† ${deletedImagesCount} å¼ ç›¸å…³å›¾ç‰‡` : ''}`);
        }
        
        // æ›´æ–°CSVé¢„è§ˆæ˜¾ç¤º
        function updateCsvPreview() {
            const preview = document.getElementById('csvPreview');
            if (preview && preview.style.display !== 'none') {
                preview.innerHTML = `
                    <h4>CSVé¢„è§ˆ (å…±${storyScript.length}ä¸ªåˆ†é•œ):</h4>
                    <div style="max-height: 150px; overflow-y: auto;">
                        ${storyScript.slice(0, 5).map(item => 
                            `<div><strong>åˆ†é•œ${item.index}:</strong> ${item.prompt.substring(0, 100)}${item.prompt.length > 100 ? '...' : ''}</div>`
                        ).join('')}
                        ${storyScript.length > 5 ? '<div><em>... è¿˜æœ‰æ›´å¤šåˆ†é•œ</em></div>' : ''}
                    </div>
                `;
            }
        }

        // æ‰¹é‡åˆ é™¤åˆ†é•œåŠŸèƒ½
        function batchDeleteStoryItems() {
            if (storyScript.length === 0) {
                alert('æ²¡æœ‰å¯åˆ é™¤çš„åˆ†é•œ');
                return;
            }

            // åˆ›å»ºé€‰æ‹©ç•Œé¢
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0,0,0,0.5); z-index: 1000; display: flex; 
                justify-content: center; align-items: center;
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 8px; max-width: 90%; max-height: 80%; overflow-y: auto;">
                    <h3>ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤åˆ†é•œ</h3>
                    <p style="color: #666; margin-bottom: 20px;">è¯·é€‰æ‹©è¦åˆ é™¤çš„åˆ†é•œ (å¯å¤šé€‰)ï¼š</p>
                    <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; margin: 15px 0;">
                        ${storyScript.map((item, index) => `
                            <div style="margin-bottom: 10px; padding: 10px; border: 1px solid #f0f0f0; border-radius: 4px;">
                                <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                    <input type="checkbox" id="deleteCheck_${index}" style="margin-top: 3px; margin-right: 10px;">
                                    <div style="flex: 1;">
                                        <strong>åˆ†é•œ ${item.index}</strong><br>
                                        <span style="font-size: 12px; color: #666;">
                                            ${item.prompt.substring(0, 80)}${item.prompt.length > 80 ? '...' : ''}
                                        </span>
                                    </div>
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 20px;">
                        <button onclick="selectAllForDelete(true)" style="background: #1890ff; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">å…¨é€‰</button>
                        <button onclick="selectAllForDelete(false)" style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">å…¨ä¸é€‰</button>
                    </div>
                    <div style="text-align: center; margin-top: 20px; gap: 10px; display: flex; justify-content: center;">
                        <button onclick="confirmBatchDelete()" style="background-color: #ff4d4f; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">ğŸ—‘ï¸ ç¡®è®¤åˆ é™¤</button>
                        <button onclick="closeBatchDeleteModal()" style="background-color: #d9d9d9; color: #333; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            window.currentDeleteModal = modal;
        }

        // å…¨é€‰/å…¨ä¸é€‰åˆ é™¤é¡¹
        function selectAllForDelete(selectAll) {
            storyScript.forEach((item, index) => {
                const checkbox = document.getElementById(`deleteCheck_${index}`);
                if (checkbox) {
                    checkbox.checked = selectAll;
                }
            });
        }

        // ç¡®è®¤æ‰¹é‡åˆ é™¤
        function confirmBatchDelete() {
            const selectedIndices = [];
            storyScript.forEach((item, index) => {
                const checkbox = document.getElementById(`deleteCheck_${index}`);
                if (checkbox && checkbox.checked) {
                    selectedIndices.push(index);
                }
            });

            if (selectedIndices.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåˆ†é•œè¿›è¡Œåˆ é™¤');
                return;
            }

            const confirmMessage = `ç¡®å®šè¦åˆ é™¤ ${selectedIndices.length} ä¸ªåˆ†é•œå—ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼åŒæ—¶ä¼šåˆ é™¤è¿™äº›åˆ†é•œçš„æ‰€æœ‰å·²ç”Ÿæˆå›¾ç‰‡ã€‚`;
            
            if (!confirm(confirmMessage)) {
                return;
            }

            // è®°å½•è¦åˆ é™¤çš„åˆ†é•œä¿¡æ¯
            const deletedItems = selectedIndices.map(index => storyScript[index]);
            const deletedItemIndices = deletedItems.map(item => item.index);

            // åˆ é™¤å¯¹åº”çš„å·²ç”Ÿæˆå›¾ç‰‡
            const originalImageLength = storyGeneratedImages.length;
            storyGeneratedImages = storyGeneratedImages.filter(img => {
                return !deletedItemIndices.includes(img.storyItemIndex);
            });
            const deletedImagesCount = originalImageLength - storyGeneratedImages.length;

            // ä»æ•°ç»„ä¸­åˆ é™¤åˆ†é•œï¼ˆå€’åºåˆ é™¤é¿å…ç´¢å¼•å˜åŒ–ï¼‰
            selectedIndices.sort((a, b) => b - a).forEach(index => {
                storyScript.splice(index, 1);
            });

            // å…³é—­æ¨¡æ€æ¡†
            closeBatchDeleteModal();

            // é‡æ–°æ˜¾ç¤ºç¼–è¾‘å™¨
            displayStoryEditor();

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            if (storyGeneratedImages.length > 0) {
                updateStoryResult();
            } else {
                const result = document.getElementById('result');
                result.innerHTML = '';
            }

            // æ›´æ–°CSVé¢„è§ˆ
            updateCsvPreview();

            // æ˜¾ç¤ºåˆ é™¤ç»“æœ
            const debug = document.getElementById('debug');
            debug.textContent += `\nğŸ—‘ï¸ æ‰¹é‡åˆ é™¤å®Œæˆï¼šåˆ é™¤äº† ${selectedIndices.length} ä¸ªåˆ†é•œ`;
            if (deletedImagesCount > 0) {
                debug.textContent += `ï¼ŒåŒæ—¶åˆ é™¤äº† ${deletedImagesCount} å¼ ç›¸å…³å›¾ç‰‡`;
            }

            alert(`âœ… æ‰¹é‡åˆ é™¤æˆåŠŸï¼\nåˆ é™¤äº† ${selectedIndices.length} ä¸ªåˆ†é•œ${deletedImagesCount > 0 ? `\nåŒæ—¶åˆ é™¤äº† ${deletedImagesCount} å¼ ç›¸å…³å›¾ç‰‡` : ''}`);
        }

        // å…³é—­æ‰¹é‡åˆ é™¤æ¨¡æ€æ¡†
        function closeBatchDeleteModal() {
            if (window.currentDeleteModal) {
                document.body.removeChild(window.currentDeleteModal);
                window.currentDeleteModal = null;
            }
        }
        
        function setBatchImageCount() {
            const batchCount = parseInt(document.getElementById('batchImageCount').value);
            storyScript.forEach((item, index) => {
                item.imageCount = batchCount;
                document.getElementById(`storyImageCount_${index}`).value = batchCount;
            });
        }
        
        // ç”Ÿæˆå•ä¸ªæ•…äº‹åˆ†é•œå›¾ç‰‡
        async function generateSingleStoryImage(storyIndex) {
            const apiKey = document.getElementById('apiKey').value;
            const item = storyScript[storyIndex];
            const promptText = document.getElementById(`storyPrompt_${storyIndex}`).value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('è¯·è¾“å…¥äº‘é›¾ API Key');
                return;
            }
            
            if (!promptText.trim()) {
                alert('è¯·è¾“å…¥æç¤ºè¯');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'ç”Ÿæˆä¸­...';
            button.disabled = true;
            
            try {
                debug.textContent += `\næ­£åœ¨ç”Ÿæˆåˆ†é•œ${item.index}çš„å›¾ç‰‡...`;
                debug.textContent += `\nğŸ“ æç¤ºè¯: ${promptText.substring(0, 100)}...`;
                debug.textContent += `\nğŸ–¼ï¸ å«å›¾æ•°é‡: ${item.refImages ? item.refImages.length : 0}`;
                
                // ä¸ºæ¯ä¸ªæ•°é‡ç”Ÿæˆå›¾ç‰‡
                const promises = [];
                for (let i = 0; i < item.imageCount; i++) {
                    // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ‰€æœ‰é…ç½®çš„å«å›¾ï¼Œè€Œä¸æ˜¯åªç”¨ç¬¬ä¸€å¼ 
                    const refImageDataArray = item.refImages && item.refImages.length > 0 
                        ? item.refImages.map(refImg => refImg.data) 
                        : [];
                    
                    if (refImageDataArray.length > 0) {
                        const refImageNames = item.refImages.map(img => img.name).join(', ');
                        debug.textContent += `\nğŸ–¼ï¸ ç¬¬${i + 1}å¼ å°†ä½¿ç”¨å«å›¾: ${refImageNames} (å…±${refImageDataArray.length}å¼ )`;
                    } else {
                        debug.textContent += `\nğŸ“ ç¬¬${i + 1}å¼ å°†çº¯æ–‡æœ¬ç”Ÿæˆ`;
                    }
                    
                    promises.push(generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, storyIndex, i));
                }
                
                const results = await Promise.allSettled(promises);
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        storyGeneratedImages.push(result.value);
                        debug.textContent += `\nâœ… åˆ†é•œ${item.index}ç¬¬${index + 1}å¼ å›¾ç‰‡ç”ŸæˆæˆåŠŸ`;
                    } else {
                        debug.textContent += `\nâŒ åˆ†é•œ${item.index}ç¬¬${index + 1}å¼ å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${result.reason}`;
                    }
                });
                
                updateStoryResult();
                
            } catch (error) {
                debug.textContent += `\nâŒ ç”Ÿæˆé”™è¯¯: ${error.message}`;
                alert(`ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // å•ä¸ªæ•…äº‹å›¾ç‰‡ç”Ÿæˆè¯·æ±‚
        async function generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, storyIndex, imageIndex) {
            const debug = document.getElementById('debug');
            
            // è·å–å«å›¾æ–‡ä»¶åç”¨äºæ—¥å¿—
            const storyItem = storyScript[storyIndex];
            const refImageNames = (storyItem.refImages && storyItem.refImages.length > 0) 
                ? storyItem.refImages.map(img => img.name).join(', ')
                : 'æ— å«å›¾';
            const refImageCount = storyItem.refImages ? storyItem.refImages.length : 0;
            const requestId = `æ•…äº‹${storyItem.index}-${imageIndex + 1}`;
            
            debug.textContent += `\n\nğŸ” [${requestId}] å¼€å§‹å¤„ç†æ•…äº‹å›¾ç‰‡ç”Ÿæˆè¯·æ±‚`;
            debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames} (å…±${refImageCount}å¼ )`;
            
            // ğŸ”§ ä¿®å¤ï¼šæ£€æŸ¥å¤šå¼ å«å›¾æ•°æ®çŠ¶æ€
            debug.textContent += `\nğŸ” [${requestId}] å«å›¾æ•°æ®æ£€æŸ¥:`;
            debug.textContent += `\n   - refImageDataArrayç±»å‹: ${typeof refImageDataArray}`;
            debug.textContent += `\n   - refImageDataArrayæ˜¯å¦ä¸ºæ•°ç»„: ${Array.isArray(refImageDataArray)}`;
            debug.textContent += `\n   - å«å›¾æ•°é‡: ${refImageDataArray.length}`;
            
            // éªŒè¯æ‰€æœ‰å«å›¾æ•°æ®
            const validRefImages = [];
            if (refImageDataArray && refImageDataArray.length > 0) {
                for (let i = 0; i < refImageDataArray.length; i++) {
                    const refImageData = refImageDataArray[i];
                    debug.textContent += `\n   - å«å›¾${i + 1}æ•°æ®é•¿åº¦: ${refImageData ? refImageData.length : 0} å­—ç¬¦`;
                    
                    if (refImageData) {
                        debug.textContent += `\n   - å«å›¾${i + 1}æ•°æ®å¼€å¤´: ${refImageData.substring(0, 30)}...`;
                        debug.textContent += `\n   - å«å›¾${i + 1}æ˜¯å¦ä¸ºdata:imageæ ¼å¼: ${refImageData.startsWith('data:image/')}`;
                        
                        // æ£€æŸ¥base64éƒ¨åˆ†
                        const parts = refImageData.split(',');
                        if (parts.length === 2) {
                            const base64Part = parts[1];
                            debug.textContent += `\n   - å«å›¾${i + 1} base64éƒ¨åˆ†é•¿åº¦: ${base64Part.length} å­—ç¬¦`;
                            debug.textContent += `\n   - å«å›¾${i + 1} ä¼°ç®—å›¾ç‰‡å¤§å°: ${Math.round(base64Part.length * 0.75 / 1024)}KB`;
                        }
                        
                        // éªŒè¯å½“å‰å«å›¾
                        if (validateRefImageData(refImageData, `[${requestId}] å«å›¾${i + 1}`)) {
                            validRefImages.push(refImageData);
                        }
                    }
                }
            }
            
            debug.textContent += `\nâœ… [${requestId}] æœ‰æ•ˆå«å›¾æ•°é‡: ${validRefImages.length}/${refImageDataArray.length}`;
            
            // æ„å»ºæ¶ˆæ¯å†…å®¹
            let messageContent;
            if (validRefImages.length > 0) {
                // ğŸ”§ ä¿®å¤ï¼šæ”¯æŒå¤šå¼ å«å›¾çš„æƒ…å†µ
                const imageUrlItems = validRefImages.map(imgData => ({
                    "type": "image_url",
                    "image_url": {
                        "url": imgData
                    }
                }));
                
                messageContent = [
                    {
                        "type": "text",
                        "text": promptText
                    },
                    ...imageUrlItems
                ];
                
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] ä½¿ç”¨å«å›¾ç”Ÿæˆæ¨¡å¼ (${validRefImages.length}å¼ å«å›¾)`;
                debug.textContent += `\nğŸ“‹ [${requestId}] æ¶ˆæ¯å†…å®¹åŒ…å«: æ–‡æœ¬ + ${validRefImages.length}å¼ å›¾ç‰‡URL`;
                debug.textContent += `\nğŸ¯ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames}`;
            } else {
                // æ²¡æœ‰å«å›¾æˆ–å«å›¾æ— æ•ˆçš„æƒ…å†µ
                messageContent = promptText;
                debug.textContent += `\nğŸ“ [${requestId}] çº¯æ–‡æœ¬ç”Ÿæˆæ¨¡å¼ (å«å›¾æ— æ•ˆæˆ–ç¼ºå¤±)`;
                debug.textContent += `\nğŸ“‹ [${requestId}] æ¶ˆæ¯å†…å®¹: ä»…æ–‡æœ¬`;
                debug.textContent += `\nâš ï¸ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames} (æœªä½¿ç”¨)`;
            }
            
            const messages = [
                {
                    role: "system",
                    content: "You are a helpful assistant."
                },
                {
                    role: "user",
                    content: messageContent
                }
            ];

            debug.textContent += `\nğŸš€ [${requestId}] å‡†å¤‡å‘é€APIè¯·æ±‚...`;
            debug.textContent += `\nğŸ“¦ [${requestId}] è¯·æ±‚ä½“å¤§å°: ${JSON.stringify(messages).length} å­—ç¬¦`;
            
            // è®°å½•è¯·æ±‚è¯¦æƒ…ï¼ˆä¸åŒ…å«å®Œæ•´çš„base64æ•°æ®ï¼Œé¿å…æ—¥å¿—è¿‡é•¿ï¼‰
            if (validRefImages.length > 0) {
                debug.textContent += `\nğŸ“· [${requestId}] è¯·æ±‚åŒ…å«å›¾ç‰‡: ${refImageNames}`;
                debug.textContent += `\nğŸ”— [${requestId}] å›¾ç‰‡URLç±»å‹: ${validRefImages[0].substring(0, 20)}... (ç­‰${validRefImages.length}å¼ )`;
            }
            
            try {
                const config = getApiConfig();
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "sora_image",
                        messages: messages
                    })
                });

                debug.textContent += `\nğŸ“Š [${requestId}] APIå“åº”çŠ¶æ€: ${response.status}`;

                if (!response.ok) {
                    const errorText = await response.text();
                    debug.textContent += `\nâŒ [${requestId}] APIå“åº”é”™è¯¯: ${response.status} ${response.statusText}`;
                    debug.textContent += `\nâŒ [${requestId}] é”™è¯¯è¯¦æƒ…: ${errorText}`;
                    debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${validRefImages.length > 0 ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}`;
                    debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames}`;
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                debug.textContent += `\nâœ… [${requestId}] APIè°ƒç”¨æˆåŠŸ`;
                debug.textContent += `\nğŸ“„ [${requestId}] å®Œæ•´å“åº”å†…å®¹: \`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``;
                
                // è¿›è¡ŒAPIå“åº”æ ¼å¼è¯Šæ–­
                const responseFormat = diagnoseApiResponse(data, requestId);
                
                // é€‚åº”æ–°çš„å“åº”æ ¼å¼å¤„ç†é€»è¾‘
                let imageUrl = null;
                
                // æ–¹æ³•1ï¼šæ£€æŸ¥ä¼ ç»Ÿæ ¼å¼ (choices[0].message.content)
                const content = data.choices?.[0]?.message?.content;
                if (content) {
                    imageUrl = extractImageUrl(content);
                    if (imageUrl) {
                        debug.textContent += `\nâœ… [${requestId}] ä»ä¼ ç»Ÿæ ¼å¼æå–åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                // æ–¹æ³•2ï¼šæ£€æŸ¥æ–°æ ¼å¼ - ç›´æ¥åœ¨å“åº”ä¸­æŸ¥æ‰¾å›¾ç‰‡URL
                if (!imageUrl) {
                    // æ£€æŸ¥å“åº”ä¸­æ˜¯å¦ç›´æ¥åŒ…å«å›¾ç‰‡URLå­—æ®µ
                    if (data.image_url) {
                        imageUrl = data.image_url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(image_urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    } else if (data.url) {
                        imageUrl = data.url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    } else if (data.result && data.result.url) {
                        imageUrl = data.result.url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(result.urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                // æ–¹æ³•3ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºå¼‚æ­¥å“åº”æ ¼å¼
                if (!imageUrl) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡IDæˆ–å…¶ä»–å¼‚æ­¥æ ‡è¯†
                    if (data.task_id || data.id || data.prompt) {
                        debug.textContent += `\nâ³ [${requestId}] æ£€æµ‹åˆ°å¼‚æ­¥å“åº”æ ¼å¼`;
                        debug.textContent += `\nğŸ“‹ [${requestId}] å“åº”å‚æ•°ç¡®è®¤: ${JSON.stringify(data)}`;
                        
                        // æ˜¾ç¤ºæ ¼å¼å˜åŒ–æç¤º
                        if (responseFormat === 'async_params') {
                            showApiFormatChangeNotice();
                        }
                        
                        // å¯¹äºå¼‚æ­¥APIï¼Œæˆ‘ä»¬éœ€è¦ç­‰å¾…å¹¶è½®è¯¢ç»“æœ
                        debug.textContent += `\nâ³ [${requestId}] æ£€æµ‹åˆ°äº‘é›¾APIå¼‚æ­¥æ¨¡å¼ï¼Œå¼€å§‹è½®è¯¢ç»“æœ`;
                        
                        // è·å–ä»»åŠ¡ID
                        const taskId = data.task_id || data.id || data.prompt;
                        debug.textContent += `\nğŸ”‘ [${requestId}] ä»»åŠ¡ID: ${taskId}`;
                        
                        // è½®è¯¢ä»»åŠ¡ç»“æœ
                        try {
                            const pollResult = await pollTaskResult(apiKey, taskId, requestId);
                            if (pollResult && pollResult.imageUrl) {
                                imageUrl = pollResult.imageUrl;
                                debug.textContent += `\nâœ… [${requestId}] å¼‚æ­¥è½®è¯¢æˆåŠŸè·å–å›¾ç‰‡URL`;
                            } else {
                                throw new Error('è½®è¯¢ä»»åŠ¡ç»“æœå¤±è´¥');
                            }
                        } catch (pollError) {
                            debug.textContent += `\nâŒ [${requestId}] è½®è¯¢ä»»åŠ¡å¤±è´¥: ${pollError.message}`;
                            throw new Error(`å¼‚æ­¥APIè½®è¯¢å¤±è´¥: ${pollError.message}`);
                        }
                    }
                }
                
                // æ–¹æ³•4ï¼šå°è¯•åœ¨å“åº”æ–‡æœ¬ä¸­æŸ¥æ‰¾ä»»ä½•HTTP URL
                if (!imageUrl) {
                    const responseText = JSON.stringify(data);
                    const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                    const urls = responseText.match(urlRegex);
                    if (urls && urls.length > 0) {
                        imageUrl = urls[0];
                        debug.textContent += `\nâœ… [${requestId}] é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼åœ¨å“åº”ä¸­æ‰¾åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                if (!imageUrl) {
                    debug.textContent += `\nâŒ [${requestId}] æ‰€æœ‰æ–¹æ³•éƒ½æ— æ³•æå–å›¾ç‰‡URL`;
                    debug.textContent += `\nğŸ“„ [${requestId}] å“åº”æ•°æ®ç»“æ„: ${Object.keys(data).join(', ')}`;
                    debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${hasValidRefImage ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}`;
                    debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames}`;
                    
                    // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    const errorDetails = {
                        responseStructure: Object.keys(data),
                        hasChoices: !!data.choices,
                        hasContent: !!(data.choices?.[0]?.message?.content),
                        responseData: data
                    };
                    
                    throw new Error(`æœªèƒ½ä»å“åº”ä¸­æå–å›¾ç‰‡URLã€‚å“åº”æ ¼å¼å¯èƒ½å·²å˜åŒ–ã€‚è¯¦æƒ…: ${JSON.stringify(errorDetails, null, 2)}`);
                }

                debug.textContent += `\nğŸ‰ [${requestId}] æ•…äº‹å›¾ç‰‡ç”ŸæˆæˆåŠŸ!`;
                debug.textContent += `\nğŸ”— [${requestId}] å›¾ç‰‡URL: ${imageUrl.substring(0, 50)}...`;
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${validRefImages.length > 0 ? 'âœ… å·²ä½¿ç”¨' : 'âŒ æœªä½¿ç”¨'}`;
                debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames}`;
                
                return {
                    url: imageUrl,
                    prompt: promptText,
                    storyIndex: storyIndex,
                    imageIndex: imageIndex,
                    storyItemIndex: storyItem.index,
                    usedRefImage: validRefImages.length > 0,
                    refImageFile: refImageNames
                };
            } catch (error) {
                debug.textContent += `\nğŸ’¥ [${requestId}] æ•…äº‹ç”Ÿæˆè¿‡ç¨‹å‡ºé”™: ${error.message}`;
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${validRefImages.length > 0 ? 'å·²é…ç½®ä½†å¤±è´¥' : 'æœªä½¿ç”¨'}`;
                debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageNames}`;
                throw error;
            }
        }
        
        // ç”Ÿæˆæ‰€æœ‰æ•…äº‹å›¾ç‰‡
        async function generateAllStoryImages() {
            const apiKey = document.getElementById('apiKey').value;
            const generateAllStoryBtn = document.getElementById('generateAllStoryBtn');
            const debug = document.getElementById('debug');

            if (!apiKey) {
                alert('è¯·è¾“å…¥äº‘é›¾ API Key');
                return;
            }

            if (storyScript.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆæˆ–å¯¼å…¥æ•…äº‹è„šæœ¬');
                return;
            }

            // ğŸ”§ è‡ªåŠ¨æ£€æŸ¥å¹¶åº”ç”¨æ‰¹é‡å›¾ç‰‡æ•°é‡è®¾ç½®
            const batchImageCount = parseInt(document.getElementById('batchImageCount').value) || 1;
            const currentImageCounts = storyScript.map(item => item.imageCount);
            const allSameCount = currentImageCounts.every(count => count === currentImageCounts[0]);
            
            // å¦‚æœç”¨æˆ·è®¾ç½®çš„æ‰¹é‡æ•°é‡ä¸å½“å‰åˆ†é•œè®¾ç½®ä¸åŒï¼Œè‡ªåŠ¨åº”ç”¨
            if (!allSameCount || currentImageCounts[0] !== batchImageCount) {
                debug.textContent += `\nğŸ”§ æ£€æµ‹åˆ°æ‰¹é‡è®¾ç½®(${batchImageCount}å¼ )ä¸åˆ†é•œè®¾ç½®ä¸ä¸€è‡´ï¼Œè‡ªåŠ¨åº”ç”¨æ‰¹é‡è®¾ç½®...`;
                setBatchImageCount();
                debug.textContent += `\nâœ… å·²å°†æ‰€æœ‰åˆ†é•œçš„å›¾ç‰‡æ•°é‡è®¾ç½®ä¸º: ${batchImageCount} å¼ `;
            }

            generateAllStoryBtn.disabled = true;
            generateAllStoryBtn.textContent = 'ç”Ÿæˆä¸­...';
            // ğŸ”§ ä¿®å¤ï¼šä¸å†é‡ç½®æ•°ç»„ï¼Œæ”¹ä¸ºç´¯ç§¯ä¿å­˜æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡  
            // storyGeneratedImages = [];
            
            // è®°å½•æœ¬æ¬¡ç”Ÿæˆå¼€å§‹å‰çš„å›¾ç‰‡æ•°é‡
            const initialImageCount = storyGeneratedImages.length;

            try {
                debug.textContent += `\n\nå¼€å§‹æ‰¹é‡ç”Ÿæˆæ•…äº‹å›¾ç‰‡ï¼Œå…±${storyScript.length}ä¸ªåˆ†é•œ...`;
                if (initialImageCount > 0) {
                    debug.textContent += `\nğŸ“Š å·²æœ‰å†å²å›¾ç‰‡: ${initialImageCount} å¼ ï¼Œæœ¬æ¬¡ç”Ÿæˆå°†ç´¯ç§¯ä¿å­˜`;
                }
                
                // ğŸ” è°ƒç”¨è°ƒè¯•å‡½æ•°æ£€æŸ¥æ•°æ®çŠ¶æ€
                debugStoryDataState();
                
                // ç»Ÿè®¡å«å›¾ä½¿ç”¨æƒ…å†µ
                let totalWithRefImages = 0;
                let totalWithoutRefImages = 0;
                
                // åˆ›å»ºæ‰€æœ‰å¹¶å‘è¯·æ±‚
                const allRequests = [];
                
                for (let i = 0; i < storyScript.length; i++) {
                    const item = storyScript[i];
                    const promptText = document.getElementById(`storyPrompt_${i}`).value;
                    
                    if (!promptText.trim()) {
                        debug.textContent += `\nâš ï¸ è·³è¿‡åˆ†é•œ${item.index}: æç¤ºè¯ä¸ºç©º`;
                        continue;
                    }
                    
                    const hasRefImages = item.refImages && item.refImages.length > 0;
                    const refImageCount = item.refImages ? item.refImages.length : 0;
                    debug.textContent += `\nğŸ“‹ åˆ†é•œ${item.index}: ${hasRefImages ? `ä½¿ç”¨å«å›¾ (${refImageCount}å¼ å«å›¾)` : 'çº¯æ–‡æœ¬'} - ç”Ÿæˆ${item.imageCount}å¼ å›¾ç‰‡`;
                    
                    for (let j = 0; j < item.imageCount; j++) {
                        // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ‰€æœ‰é…ç½®çš„å«å›¾ï¼Œè€Œä¸æ˜¯åªç”¨ç¬¬ä¸€å¼ 
                        const refImageDataArray = hasRefImages 
                            ? item.refImages.map(img => img.data) 
                            : [];
                        
                        if (refImageDataArray.length > 0) {
                            totalWithRefImages++;
                        } else {
                            totalWithoutRefImages++;
                        }
                        
                        const requestPromise = generateSingleStoryImageRequest(apiKey, promptText, refImageDataArray, i, j);
                        allRequests.push(requestPromise);
                    }
                }

                debug.textContent += `\nğŸ“Š ç”Ÿæˆç»Ÿè®¡: å«å›¾ç”Ÿæˆ${totalWithRefImages}å¼ , çº¯æ–‡æœ¬ç”Ÿæˆ${totalWithoutRefImages}å¼ `;
                debug.textContent += `\nå¼€å§‹å¹¶å‘ç”Ÿæˆ ${allRequests.length} å¼ å›¾ç‰‡...`;
                
                // ğŸ” è°ƒè¯•Promise.allSettledæ‰§è¡Œå‰çŠ¶æ€
                debug.textContent += `\nğŸ” å‡†å¤‡æ‰§è¡ŒPromise.allSettledï¼Œè¯·æ±‚æ•°é‡: ${allRequests.length}`;
                debug.textContent += `\nğŸ” æ£€æŸ¥æ‰€æœ‰è¯·æ±‚æ˜¯å¦ä¸ºPromise: ${allRequests.every(req => req && typeof req.then === 'function')}`;
                if (allRequests.length > 0) {
                    debug.textContent += `\nğŸ” ç¬¬ä¸€ä¸ªè¯·æ±‚ç±»å‹: ${typeof allRequests[0]}`;
                    debug.textContent += `\nğŸ” ç¬¬ä¸€ä¸ªè¯·æ±‚æœ‰thenæ–¹æ³•: ${typeof allRequests[0].then === 'function'}`;
                }
                
                // ğŸ”§ æ·»åŠ è¿›åº¦ç›‘æ§
                let completedCount = 0;
                const progressPromises = allRequests.map((promise, index) => {
                    return promise.then(
                        result => {
                            completedCount++;
                            debug.textContent += `\nğŸ“ˆ è¿›åº¦: ${completedCount}/${allRequests.length} å®Œæˆ`;
                            return result;
                        },
                        error => {
                            completedCount++;
                            debug.textContent += `\nğŸ“ˆ è¿›åº¦: ${completedCount}/${allRequests.length} å®Œæˆ (ç¬¬${index + 1}ä¸ªå¤±è´¥: ${error.message})`;
                            throw error;
                        }
                    );
                });
                
                // å¹¶å‘æ‰§è¡Œæ‰€æœ‰è¯·æ±‚
                try {
                    debug.textContent += `\nğŸ” å¼€å§‹æ‰§è¡ŒPromise.allSettled...`;
                    
                    // ğŸ”§ è°ƒæ•´æ€»ä½“è¶…æ—¶æœºåˆ¶ï¼ˆ10åˆ†é’Ÿï¼‰
                    const allSettledTimeout = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('æ‰¹é‡æ“ä½œè¶…æ—¶ (10åˆ†é’Ÿ)')), 10 * 60 * 1000);
                    });
                    
                    let results;
                    try {
                        results = await Promise.race([
                            Promise.allSettled(progressPromises),
                            allSettledTimeout
                        ]);
                    } catch (timeoutError) {
                        debug.textContent += `\nâš ï¸ æ“ä½œè¶…æ—¶ï¼Œä½†ç»§ç»­å¤„ç†å·²å®Œæˆçš„è¯·æ±‚...`;
                        debug.textContent += `\nğŸ” ç­‰å¾…å‰©ä½™è¯·æ±‚å®Œæˆ...`;
                        
                        // å³ä½¿è¶…æ—¶ï¼Œä¹Ÿç»™ä¸€äº›é¢å¤–æ—¶é—´è®©æ›´å¤šè¯·æ±‚å®Œæˆ
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        
                        // æ£€æŸ¥å·²å®Œæˆçš„è¯·æ±‚
                        const partialResults = [];
                        for (let i = 0; i < progressPromises.length; i++) {
                            try {
                                // ä½¿ç”¨Promise.raceå¿«é€Ÿæ£€æŸ¥æ˜¯å¦å·²å®Œæˆ
                                const quickCheck = await Promise.race([
                                    progressPromises[i],
                                    Promise.resolve({ status: 'pending' })
                                ]);
                                if (quickCheck.status !== 'pending') {
                                    partialResults.push({ status: 'fulfilled', value: quickCheck });
                                } else {
                                    partialResults.push({ status: 'rejected', reason: 'è¶…æ—¶æœªå®Œæˆ' });
                                }
                            } catch (error) {
                                partialResults.push({ status: 'rejected', reason: error.message });
                            }
                        }
                        results = partialResults;
                        debug.textContent += `\nğŸ” éƒ¨åˆ†ç»“æœæ”¶é›†å®Œæˆï¼Œå…± ${results.length} ä¸ªç»“æœ`;
                    }
                    
                    debug.textContent += `\nğŸ” Promise.allSettledæ‰§è¡Œå®Œæˆï¼Œç»“æœæ•°é‡: ${results ? results.length : 'null'}`;
                    
                    if (!results) {
                        debug.textContent += `\nâŒ é”™è¯¯ï¼šPromise.allSettledè¿”å›nullæˆ–undefined`;
                        return;
                    }
                    
                    // ğŸ” æ£€æŸ¥resultsç»“æ„
                    debug.textContent += `\nğŸ” resultsç±»å‹: ${typeof results}`;
                    debug.textContent += `\nğŸ” resultsæ˜¯å¦ä¸ºæ•°ç»„: ${Array.isArray(results)}`;
                    
                    // ğŸ”§ å°†ç»“æœå¤„ç†ç§»åˆ°tryå—å†…ï¼Œè§£å†³ä½œç”¨åŸŸé—®é¢˜
                    // å¤„ç†ç»“æœ
                    let successCount = 0;
                    let failCount = 0;
                    
                    // ğŸ”§ ä¿®å¤ï¼šåœ¨å¾ªç¯å¼€å§‹å‰è®¡ç®—æ­£ç¡®çš„æ‰¹æ¬¡ç¼–å·
                    const currentBatchIndex = Math.floor(storyGeneratedImages.length / 10) + 1;
                    
                    // ğŸ” æ·»åŠ è°ƒè¯•ä¿¡æ¯
                    debug.textContent += `\n\nğŸ” === ç»“æœå¤„ç†è°ƒè¯• ===`;
                    debug.textContent += `\nğŸ“Š æ€»å…±æ”¶åˆ° ${results.length} ä¸ªç»“æœ`;
                    
                    results.forEach((result, index) => {
                        // ğŸ” è¯¦ç»†è°ƒè¯•æ¯ä¸ªç»“æœ
                        debug.textContent += `\nğŸ” [ç»“æœ${index + 1}] status: ${result.status}`;
                        if (result.status === 'fulfilled') {
                            debug.textContent += `\nğŸ” [ç»“æœ${index + 1}] value: ${result.value ? 'object' : 'null/undefined'}`;
                            if (result.value) {
                                debug.textContent += `\nğŸ” [ç»“æœ${index + 1}] value.url: ${result.value.url ? 'exists' : 'missing'}`;
                                debug.textContent += `\nğŸ” [ç»“æœ${index + 1}] value keys: ${Object.keys(result.value).join(', ')}`;
                            }
                        } else {
                            debug.textContent += `\nğŸ” [ç»“æœ${index + 1}] reason: ${result.reason}`;
                        }
                        
                        if (result.status === 'fulfilled' && result.value && result.value.url) {
                            // æ·»åŠ æ‰¹æ¬¡ä¿¡æ¯å’Œç”Ÿæˆæ—¶é—´
                            const imageWithBatch = {
                                ...result.value,
                                batchIndex: currentBatchIndex, // ä½¿ç”¨å›ºå®šçš„æ‰¹æ¬¡ç¼–å·
                                generateTime: new Date().toLocaleString() // ç”Ÿæˆæ—¶é—´
                            };
                            storyGeneratedImages.push(imageWithBatch);
                            successCount++;
                            debug.textContent += `\nâœ… ç¬¬ ${index + 1} å¼ å›¾ç‰‡ç”ŸæˆæˆåŠŸ`;
                        } else {
                            failCount++;
                            debug.textContent += `\nâŒ ç¬¬ ${index + 1} å¼ å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${result.reason || 'æœªçŸ¥é”™è¯¯'}`;
                        }
                    });

                    debug.textContent += `\nğŸ” === ç»“æœå¤„ç†å®Œæˆ ===`;
                    debug.textContent += `\nğŸ“Š æˆåŠŸå¤„ç†: ${successCount}å¼ , å¤±è´¥: ${failCount}å¼ `;

                    updateStoryResult();
                    document.getElementById('downloadAllStoryBtn').style.display = 'inline-block';
                    
                    debug.textContent += `\n\nğŸ‰ æ•…äº‹å›¾ç‰‡æ‰¹é‡ç”Ÿæˆå®Œæˆï¼`;
                    debug.textContent += `\nğŸ“Š æœ¬æ¬¡ç»Ÿè®¡: æˆåŠŸ${successCount}å¼ , å¤±è´¥${failCount}å¼ `;
                    debug.textContent += `\nğŸ“Š ç´¯è®¡æ€»æ•°: ${storyGeneratedImages.length}å¼ å›¾ç‰‡ (å«å†å²${initialImageCount}å¼ )`;
                    debug.textContent += `\nğŸ–¼ï¸ å…¶ä¸­å«å›¾ç”Ÿæˆ: ${Math.min(successCount, totalWithRefImages)}å¼ `;
                    debug.textContent += `\nğŸ“ å…¶ä¸­çº¯æ–‡æœ¬ç”Ÿæˆ: ${Math.max(0, successCount - totalWithRefImages)}å¼ `;
                    
                } catch (promiseError) {
                    debug.textContent += `\nâŒ Promise.allSettledæ‰§è¡Œå‡ºé”™: ${promiseError.message}`;
                    // ä¸è¦ç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œè€Œæ˜¯ç»§ç»­å°è¯•å¤„ç†
                    debug.textContent += `\nâš ï¸ ç»§ç»­å°è¯•æ›´æ–°ç•Œé¢...`;
                    updateStoryResult();
                    document.getElementById('downloadAllStoryBtn').style.display = 'inline-block';
                }
        } catch (error) {
                debug.textContent += `\nâŒ å‘ç”Ÿé”™è¯¯: ${error.message}`;
                alert(`å‘ç”Ÿé”™è¯¯ï¼š${error.message}`);
            } finally {
                generateAllStoryBtn.disabled = false;
                generateAllStoryBtn.textContent = 'ğŸ¬ ä¸€é”®ç”Ÿæˆæ•´ä¸ªæ•…äº‹';
            }
        }
        
        // æ›´æ–°æ•…äº‹ç»“æœæ˜¾ç¤º
        function updateStoryResult() {
            const result = document.getElementById('result');
            const withRefImageCount = storyGeneratedImages.filter(img => img.usedRefImage).length;
            const withoutRefImageCount = storyGeneratedImages.length - withRefImageCount;
            
            // æŒ‰æ‰¹æ¬¡åˆ†ç»„æ˜¾ç¤º
            const groupedImages = {};
            storyGeneratedImages.forEach((img, index) => {
                const batchKey = img.batchIndex || 1;
                if (!groupedImages[batchKey]) {
                    groupedImages[batchKey] = [];
                }
                groupedImages[batchKey].push({...img, originalIndex: index});
            });
            
            result.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">æ•…äº‹å›¾ç‰‡ç”Ÿæˆç»“æœ (å…± ${storyGeneratedImages.length} å¼ å›¾ç‰‡)ï¼š</h3>
                    <button id="batchDownloadStoryBtn" class="btn-download" onclick="batchDownloadAllStoryImages()" style="padding: 8px 16px; font-size: 14px;">
                        ğŸ“¥ æ‰¹é‡ä¸‹è½½æ‰€æœ‰æ•…äº‹å›¾ç‰‡
                    </button>
                </div>
                <div style="background-color: #f6ffed; border: 1px solid #b7eb8f; border-radius: 6px; padding: 10px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 8px 0; color: #52c41a;">ğŸ“Š å«å›¾ä½¿ç”¨ç»Ÿè®¡</h4>
                    <p style="margin: 0;">
                        ğŸ–¼ï¸ ä½¿ç”¨å«å›¾ç”Ÿæˆ: <strong>${withRefImageCount}</strong> å¼  | 
                        ğŸ“ çº¯æ–‡æœ¬ç”Ÿæˆ: <strong>${withoutRefImageCount}</strong> å¼ 
                    </p>
                    <p style="margin: 8px 0 0 0; font-size: 12px; color: #666;">
                        ğŸ’¡ æç¤ºï¼šæ‰€æœ‰å†å²ç”Ÿæˆçš„å›¾ç‰‡éƒ½ä¼šä¿ç•™ï¼Œå¯ä»¥éšæ—¶ä¸‹è½½
                    </p>
                </div>
                ${Object.keys(groupedImages).sort((a, b) => Number(b) - Number(a)).map(batchKey => `
                    <div style="border: 1px solid #d9d9d9; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: #1890ff;">
                            ğŸ“¦ æ‰¹æ¬¡ ${batchKey} (${groupedImages[batchKey].length} å¼ å›¾ç‰‡)
                            ${groupedImages[batchKey][0].generateTime ? `<span style="font-size: 12px; color: #666; font-weight: normal;"> - ${groupedImages[batchKey][0].generateTime}</span>` : ''}
                        </h4>
                        <div class="image-grid">
                            ${groupedImages[batchKey].map(img => `
                                <div class="image-item">
                                    <img src="${img.url}" alt="Story Image ${img.originalIndex + 1}">
                                    <div style="background-color: ${img.usedRefImage ? '#e6f7ff' : '#fff7e6'}; border: 1px solid ${img.usedRefImage ? '#91d5ff' : '#ffd591'}; border-radius: 4px; padding: 8px; margin: 8px 0;">
                                        <div style="font-size: 12px; color: ${img.usedRefImage ? '#1890ff' : '#fa8c16'}; font-weight: bold;">
                                            ${img.usedRefImage ? 'ğŸ–¼ï¸ å«å›¾ç”Ÿæˆ' : 'ğŸ“ çº¯æ–‡æœ¬ç”Ÿæˆ'}
                                        </div>
                                        <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                            åˆ†é•œ${img.storyItemIndex} - ç¬¬${img.imageIndex + 1}å¼ 
                                        </div>
                                    </div>
                                    <div style="margin: 10px 0;">
                                        <label style="font-weight: bold; display: block; margin-bottom: 5px;">åˆ†é•œ${img.storyItemIndex}æç¤ºè¯ (å¯ç¼–è¾‘):</label>
                                        <textarea id="story_prompt_edit_${img.originalIndex}" style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px; resize: vertical;">${img.prompt}</textarea>
                                    </div>
                                    <div class="image-controls">
                                        <button class="btn-download" onclick="downloadSingleStoryImage(${img.originalIndex}, this)">ä¸‹è½½</button>
                                        <button class="btn-copy" onclick="copyStoryImageUrl(${img.originalIndex}, this)">å¤åˆ¶URL</button>
                                        <button class="btn-retry" onclick="retrySingleStoryImageWithPrompt(${img.originalIndex}, this)">é‡è¯•ç”Ÿæˆ</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('')}
            `;
        }
        
        // ä¸‹è½½å•å¼ æ•…äº‹å›¾ç‰‡
        async function downloadSingleStoryImage(index, buttonElement) {
            const img = storyGeneratedImages[index];
            const filename = `story_${img.storyItemIndex}_${img.imageIndex + 1}.jpg`;
            const debug = document.getElementById('debug');

            // å®‰å…¨è·å–æŒ‰é’®å…ƒç´ 
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // å¦‚æœæ— æ³•è·å–event.targetï¼Œå°è¯•å…¶ä»–æ–¹å¼
                    button = document.querySelector(`[onclick*="downloadSingleStoryImage(${index})"]`);
                }
            }

            try {
                debug.textContent += `\næ­£åœ¨ä¸‹è½½: ${filename}`;
                const success = await downloadImageWithRetry(img.url, filename, 3);
                
                if (success) {
                    debug.textContent += ` âœ… ä¸‹è½½æˆåŠŸ`;
                    // å®‰å…¨æ›´æ–°æŒ‰é’®çŠ¶æ€
                    if (button) {
                        button.textContent = 'å·²ä¸‹è½½';
                        button.style.backgroundColor = '#95de64';
                        button.disabled = true;
                        setTimeout(() => {
                            button.textContent = 'ä¸‹è½½';
                            button.style.backgroundColor = '#52c41a';
                            button.disabled = false;
                        }, 2000);
                    }
                } else {
                    debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥`;
                    alert('ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–å°è¯•å¤åˆ¶URLæ‰‹åŠ¨ä¸‹è½½');
                }
            } catch (error) {
                debug.textContent += ` âŒ ä¸‹è½½é”™è¯¯: ${error.message}`;
                alert(`ä¸‹è½½å¤±è´¥ï¼š${error.message}`);
            }
        }
        
        // å¤åˆ¶æ•…äº‹å›¾ç‰‡URL
        async function copyStoryImageUrl(index, buttonElement) {
            const img = storyGeneratedImages[index];
            const debug = document.getElementById('debug');
            
            // å®‰å…¨è·å–æŒ‰é’®å…ƒç´ 
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // å¦‚æœæ— æ³•è·å–event.targetï¼Œå°è¯•å…¶ä»–æ–¹å¼
                    button = document.querySelector(`[onclick*="copyStoryImageUrl(${index})"]`);
                }
            }
            
            try {
                await navigator.clipboard.writeText(img.url);
                debug.textContent += `\nå·²å¤åˆ¶åˆ†é•œ${img.storyItemIndex}ç¬¬${img.imageIndex + 1}å¼ å›¾ç‰‡çš„URLåˆ°å‰ªè´´æ¿`;
                
                // å®‰å…¨æ›´æ–°æŒ‰é’®çŠ¶æ€
                if (button) {
                    button.textContent = 'å·²å¤åˆ¶';
                    button.style.backgroundColor = '#95de64';
                    setTimeout(() => {
                        button.textContent = 'å¤åˆ¶URL';
                        button.style.backgroundColor = '#1890ff';
                    }, 1500);
                }
            } catch (error) {
                // å¦‚æœclipboard APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
                const textArea = document.createElement('textarea');
                textArea.value = img.url;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    debug.textContent += `\nå·²å¤åˆ¶åˆ†é•œ${img.storyItemIndex}ç¬¬${img.imageIndex + 1}å¼ å›¾ç‰‡çš„URLåˆ°å‰ªè´´æ¿`;
                    alert('URLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                } catch (err) {
                    debug.textContent += `\nå¤åˆ¶å¤±è´¥: ${err.message}`;
                    alert(`å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š${img.url}`);
                }
                document.body.removeChild(textArea);
            }
        }
        
        // æ‰¹é‡ä¸‹è½½æ‰€æœ‰æ•…äº‹å›¾ç‰‡
        async function batchDownloadAllStoryImages() {
            if (storyGeneratedImages.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„æ•…äº‹å›¾ç‰‡');
                return;
            }

            const downloadBtn = document.getElementById('batchDownloadStoryBtn');
            const originalText = downloadBtn.textContent;
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'æ‰¹é‡ä¸‹è½½ä¸­...';
            
            debug.textContent += `\n\nğŸ”„ å¼€å§‹æ‰¹é‡ä¸‹è½½ ${storyGeneratedImages.length} å¼ æ•…äº‹å›¾ç‰‡...`;
            
            let successCount = 0;
            let failedDownloads = [];
            
            try {
                for (let i = 0; i < storyGeneratedImages.length; i++) {
                    const img = storyGeneratedImages[i];
                    const filename = `story_${img.storyItemIndex}_${img.imageIndex + 1}_${Date.now()}.jpg`;
                    
                    downloadBtn.textContent = `ä¸‹è½½ä¸­... (${i + 1}/${storyGeneratedImages.length})`;
                    debug.textContent += `\nä¸‹è½½ç¬¬ ${i + 1} å¼ : ${filename}`;
                    
                    try {
                        const success = await downloadImageWithRetry(img.url, filename, 2);
                        if (success) {
                            successCount++;
                            debug.textContent += ` âœ… ä¸‹è½½æˆåŠŸ`;
                        } else {
                            failedDownloads.push({
                                index: i + 1,
                                filename: filename,
                                url: img.url
                            });
                            debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥`;
                        }
                    } catch (error) {
                        failedDownloads.push({
                            index: i + 1,
                            filename: filename,
                            url: img.url
                        });
                        debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥: ${error.message}`;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                debug.textContent += `\n\nğŸ“Š æ•…äº‹å›¾ç‰‡æ‰¹é‡ä¸‹è½½å®Œæˆ: ${successCount}/${storyGeneratedImages.length} å¼ æˆåŠŸ`;
                
                if (failedDownloads.length === 0) {
                    alert(`ğŸ‰ æ‰€æœ‰æ•…äº‹å›¾ç‰‡ä¸‹è½½å®Œæˆï¼\næˆåŠŸä¸‹è½½ ${successCount} å¼ å›¾ç‰‡`);
                } else {
                    const retryChoice = confirm(`âœ… æˆåŠŸä¸‹è½½ ${successCount} å¼ æ•…äº‹å›¾ç‰‡\nâŒ ${failedDownloads.length} å¼ å¤±è´¥\n\nğŸ’¡ æç¤ºï¼šå¤±è´¥çš„å›¾ç‰‡å¯ä»¥ç‚¹å‡»å•ç‹¬çš„"ä¸‹è½½"æŒ‰é’®é‡è¯•\n\næ˜¯å¦ç°åœ¨é‡æ–°å°è¯•ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡ï¼Ÿ`);
                    
                    if (retryChoice) {
                        await retryFailedStoryDownloads(failedDownloads, downloadBtn, debug);
                    }
                }
                
            } catch (error) {
                debug.textContent += `\nâŒ æ•…äº‹å›¾ç‰‡æ‰¹é‡ä¸‹è½½å‡ºé”™: ${error.message}`;
                alert(`æ‰¹é‡ä¸‹è½½å¤±è´¥: ${error.message}`);
            } finally {
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
            }
        }

        // é‡è¯•å¤±è´¥çš„æ•…äº‹å›¾ç‰‡ä¸‹è½½
        async function retryFailedStoryDownloads(failedDownloads, downloadBtn, debug) {
            downloadBtn.textContent = 'é‡è¯•ä¸‹è½½ä¸­...';
            debug.textContent += `\n\nğŸ”„ å¼€å§‹é‡è¯•ä¸‹è½½ ${failedDownloads.length} å¼ å¤±è´¥çš„æ•…äº‹å›¾ç‰‡...`;
            
            let retrySuccessCount = 0;
            
            try {
                for (let i = 0; i < failedDownloads.length; i++) {
                    const failed = failedDownloads[i];
                    debug.textContent += `\né‡è¯•ä¸‹è½½ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    downloadBtn.textContent = `é‡è¯•ä¸­... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` âœ… é‡è¯•æˆåŠŸ`;
                    } else {
                        debug.textContent += ` âŒ é‡è¯•ä»ç„¶å¤±è´¥`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                debug.textContent += `\n\nğŸ”„ æ•…äº‹å›¾ç‰‡é‡è¯•å®Œæˆ: ${retrySuccessCount}/${failedDownloads.length} å¼ æˆåŠŸ`;
                
                if (retrySuccessCount === failedDownloads.length) {
                    alert(`ğŸ‰ é‡è¯•æˆåŠŸï¼æ‰€æœ‰æ•…äº‹å›¾ç‰‡éƒ½å·²ä¸‹è½½å®Œæˆï¼`);
                } else {
                    alert(`é‡è¯•å®Œæˆ: ${retrySuccessCount} å¼ æˆåŠŸï¼Œ${failedDownloads.length - retrySuccessCount} å¼ ä»ç„¶å¤±è´¥ã€‚\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ‰‹åŠ¨ä¿å­˜å¤±è´¥çš„å›¾ç‰‡ã€‚`);
                }
                
            } catch (error) {
                debug.textContent += `\nâŒ æ•…äº‹å›¾ç‰‡é‡è¯•å¤±è´¥: ${error.message}`;
            }
        }

        // ä½¿ç”¨ä¿®æ”¹åçš„æç¤ºè¯é‡æ–°ç”Ÿæˆå•å¼ æ•…äº‹å›¾ç‰‡
        async function retrySingleStoryImageWithPrompt(index, buttonElement = null) {
            const img = storyGeneratedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            const config = getApiConfig();
            
            if (!apiKey) {
                alert(`è¯·è¾“å…¥${config.platformName} API Key`);
                return;
            }
            
            // è·å–ç¼–è¾‘åçš„æç¤ºè¯
            const editedPrompt = document.getElementById(`story_prompt_edit_${index}`).value.trim();
            if (!editedPrompt) {
                alert('æç¤ºè¯ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            const button = buttonElement || event.target;
            const originalText = button.textContent;
            
            // è·å–å…³è”çš„æ•…äº‹é¡¹æ¥è·å–å«å›¾æ•°æ®
            const storyItemIndex = img.storyItemIndex;
            const storyItem = storyScript.find(item => item.index === storyItemIndex);
            const refImageDataArray = storyItem?.refImages?.map(refImg => refImg.data) || [];
            
            if (!button) {
                debug.textContent += ` âŒ æ— æ³•æ‰¾åˆ°é‡è¯•æŒ‰é’®`;
                alert('æ— æ³•æ‰¾åˆ°æŒ‰é’®å…ƒç´ ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }
            
            button.textContent = 'é‡è¯•ä¸­...';
            button.disabled = true;
            
            try {
                debug.textContent += `\n\nğŸ”„ é‡æ–°ç”Ÿæˆæ•…äº‹åˆ†é•œ ${storyItemIndex} ç¬¬ ${img.imageIndex + 1} å¼ å›¾ç‰‡...`;
                debug.textContent += `\nğŸ“ ä½¿ç”¨æ–°æç¤ºè¯: ${editedPrompt.substring(0, 100)}${editedPrompt.length > 100 ? '...' : ''}`;
                
                const requestId = `æ•…äº‹${storyItemIndex}-${img.imageIndex + 1}é‡è¯•`;
                const newImage = await generateSingleStoryImageRequest(
                    apiKey, 
                    editedPrompt,  // ä½¿ç”¨ç¼–è¾‘åçš„æç¤ºè¯
                    refImageDataArray, 
                    storyItemIndex - 1,  // storyScriptæ•°ç»„ç´¢å¼•
                    img.imageIndex
                );
                
                if (newImage) {
                    // æ›´æ–°å›¾ç‰‡æ•°æ®ï¼ŒåŒ…æ‹¬æ–°çš„æç¤ºè¯
                    storyGeneratedImages[index] = {
                        ...newImage,
                        prompt: editedPrompt,  // ä¿å­˜æ–°çš„æç¤ºè¯
                        storyItemIndex: storyItemIndex,
                        batchNumber: img.batchNumber,
                        generateTime: new Date().toLocaleString('zh-CN')
                    };
                    
                    // æ›´æ–°æ˜¾ç¤º
                    const imageElement = button.closest('.image-item').querySelector('img');
                    imageElement.src = newImage.url;
                    
                    debug.textContent += ` âœ… é‡æ–°ç”ŸæˆæˆåŠŸ`;
                    
                    // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
                    button.textContent = 'ç”ŸæˆæˆåŠŸ';
                    button.style.backgroundColor = '#52c41a';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                        button.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆå¤±è´¥`;
                    throw new Error('ç”Ÿæˆå¤±è´¥');
                }
                
            } catch (error) {
                debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆé”™è¯¯: ${error.message}`;
                alert(`é‡æ–°ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
                
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // é‡æ–°ç”Ÿæˆå•å¼ æ•…äº‹å›¾ç‰‡ (ä¿æŒåŸæœ‰åŠŸèƒ½ä»¥å…¼å®¹)
        async function retrySingleStoryImage(index, buttonElement = null) {
            const img = storyGeneratedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('è¯·è¾“å…¥äº‘é›¾ API Key');
                return;
            }
            
            // å®‰å…¨è·å–æŒ‰é’®å…ƒç´  - ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„buttonElement
            let button = buttonElement;
            if (!button) {
                try {
                    button = window.event && window.event.target;
                } catch (e) {
                    // å¦‚æœæ— æ³•è·å–event.targetï¼Œå°è¯•å…¶ä»–æ–¹å¼
                    const buttons = document.querySelectorAll(`[onclick*="retrySingleStoryImage(${index})"]`);
                    button = buttons[0] || null;
                }
            }
            
            if (!button) {
                debug.textContent += ` âŒ æ— æ³•æ‰¾åˆ°é‡è¯•æŒ‰é’®`;
                alert('æ— æ³•æ‰¾åˆ°æŒ‰é’®å…ƒç´ ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }
            
            const originalText = button.textContent;
            button.textContent = 'é‡è¯•ä¸­...';
            button.disabled = true;
            
            try {
                debug.textContent += `\né‡æ–°ç”Ÿæˆåˆ†é•œ${img.storyItemIndex}ç¬¬${img.imageIndex + 1}å¼ å›¾ç‰‡...`;
                
                const item = storyScript[img.storyIndex];
                // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æ‰€æœ‰é…ç½®çš„å«å›¾ï¼Œè€Œä¸æ˜¯åªç”¨ç¬¬ä¸€å¼ 
                const refImageDataArray = item.refImages && item.refImages.length > 0 
                    ? item.refImages.map(refImg => refImg.data) 
                    : [];
                
                const newImage = await generateSingleStoryImageRequest(
                    apiKey, 
                    img.prompt, 
                    refImageDataArray, 
                    img.storyIndex, 
                    img.imageIndex
                );
                
                if (newImage) {
                    // æ›´æ–°å›¾ç‰‡æ•°æ®
                    storyGeneratedImages[index] = newImage;
                    
                    // é‡æ–°æ¸²æŸ“æ•´ä¸ªç»“æœåŒºåŸŸè€Œä¸æ˜¯åªæ›´æ–°å•ä¸ªå›¾ç‰‡å…ƒç´ 
                    updateStoryResult();
                    
                    debug.textContent += ` âœ… é‡æ–°ç”ŸæˆæˆåŠŸ`;
                    
                    // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
                    button.textContent = 'ç”ŸæˆæˆåŠŸ';
                        button.style.backgroundColor = '#95de64';
                    
                    // å»¶è¿Ÿæ¢å¤æŒ‰é’®çŠ¶æ€
                        setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                            button.disabled = false;
                        }, 2000);
                    
                } else {
                    debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆå¤±è´¥`;
                    button.textContent = originalText;
                    button.disabled = false;
                    throw new Error('ç”Ÿæˆå¤±è´¥');
                }
                
            } catch (error) {
                debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆé”™è¯¯: ${error.message}`;
                alert(`é‡æ–°ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
                
                // é”™è¯¯æ—¶ç«‹å³æ¢å¤æŒ‰é’®çŠ¶æ€
                button.textContent = originalText;
                button.disabled = false;
            }
        }
        
        // ä¸‹è½½æ‰€æœ‰æ•…äº‹å›¾ç‰‡
        async function downloadAllStoryImages() {
            const downloadBtn = document.getElementById('downloadAllStoryBtn');
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'ä¸‹è½½ä¸­...';

            let successCount = 0;
            let failedDownloads = [];

            try {
                debug.textContent += '\n\nå¼€å§‹æ‰¹é‡ä¸‹è½½æ‰€æœ‰æ•…äº‹å›¾ç‰‡...';
                
                // åˆ†æ‰¹ä¸‹è½½ï¼Œæ¯æ‰¹3å¼ å›¾ç‰‡
                const batchSize = 3;
                const totalBatches = Math.ceil(storyGeneratedImages.length / batchSize);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIndex = batchIndex * batchSize;
                    const endIndex = Math.min(startIndex + batchSize, storyGeneratedImages.length);
                    const currentBatch = storyGeneratedImages.slice(startIndex, endIndex);
                    
                    debug.textContent += `\n\nğŸ“¦ ç¬¬ ${batchIndex + 1}/${totalBatches} æ‰¹ä¸‹è½½ (${currentBatch.length} å¼ å›¾ç‰‡)`;
                    downloadBtn.textContent = `ä¸‹è½½ä¸­... ç¬¬${batchIndex + 1}/${totalBatches}æ‰¹`;
                    
                    // å¹¶å‘ä¸‹è½½å½“å‰æ‰¹æ¬¡
                    const batchPromises = currentBatch.map(async (img, localIndex) => {
                        const globalIndex = startIndex + localIndex;
                        const filename = `story_${img.storyItemIndex}_${img.imageIndex + 1}.jpg`;
                        
                        try {
                            debug.textContent += `\næ­£åœ¨ä¸‹è½½ç¬¬ ${globalIndex + 1} å¼ : ${filename}`;
                            const success = await downloadImageWithRetry(img.url, filename, 2);
                            
                            if (success) {
                                successCount++;
                                debug.textContent += ` âœ…`;
                                return { success: true, index: globalIndex + 1, filename };
                            } else {
                                failedDownloads.push({ index: globalIndex + 1, filename, url: img.url });
                                debug.textContent += ` âŒ`;
                                return { success: false, index: globalIndex + 1, filename };
                            }
                        } catch (error) {
                            failedDownloads.push({ index: globalIndex + 1, filename, url: img.url, error: error.message });
                            debug.textContent += ` âŒ ${error.message}`;
                            return { success: false, index: globalIndex + 1, filename, error: error.message };
                        }
                    });
                    
                    // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                    await Promise.allSettled(batchPromises);
                    
                    // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                    if (batchIndex < totalBatches - 1) {
                        debug.textContent += `\nâ³ ç­‰å¾… 2 ç§’åå¼€å§‹ä¸‹ä¸€æ‰¹...`;
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
                debug.textContent += `\n\nğŸ“Š æ•…äº‹å›¾ç‰‡æ‰¹é‡ä¸‹è½½å®Œæˆç»Ÿè®¡:`;
                debug.textContent += `\nâœ… æˆåŠŸä¸‹è½½: ${successCount} å¼ `;
                debug.textContent += `\nâŒ ä¸‹è½½å¤±è´¥: ${failedDownloads.length} å¼ `;
                
                if (failedDownloads.length > 0) {
                    debug.textContent += `\n\nå¤±è´¥åˆ—è¡¨:`;
                    failedDownloads.forEach(failed => {
                        debug.textContent += `\n- ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    });
                    
                    const retryChoice = confirm(`âœ… æˆåŠŸä¸‹è½½ ${successCount} å¼ å›¾ç‰‡\nâŒ ${failedDownloads.length} å¼ å¤±è´¥\n\nğŸ’¡ æç¤ºï¼šå¤±è´¥çš„å›¾ç‰‡å¯ä»¥ç‚¹å‡»å•ç‹¬çš„"ä¸‹è½½"æŒ‰é’®é‡è¯•\n\næ˜¯å¦ç°åœ¨é‡æ–°å°è¯•ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡ï¼Ÿ`);
                    
                    if (retryChoice) {
                        await retryFailedStoryDownloads(failedDownloads);
                    }
                } else {
                    debug.textContent += `\n\nğŸ‰ æ‰€æœ‰æ•…äº‹å›¾ç‰‡ä¸‹è½½æˆåŠŸï¼`;
                    alert(`ğŸ‰ æ­å–œï¼æˆåŠŸä¸‹è½½æ‰€æœ‰ ${successCount} å¼ æ•…äº‹å›¾ç‰‡ï¼`);
                }
                
            } catch (error) {
                debug.textContent += `\n\nâŒ æ‰¹é‡ä¸‹è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}`;
                alert(`ä¸‹è½½å¤±è´¥ï¼š${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'ä¿å­˜æ‰€æœ‰å›¾ç‰‡';
            }
        }
        
        // é‡æ–°ä¸‹è½½å¤±è´¥çš„æ•…äº‹å›¾ç‰‡
        async function retryFailedStoryDownloads(failedDownloads) {
            const debug = document.getElementById('debug');
            const downloadBtn = document.getElementById('downloadAllStoryBtn');
            
            downloadBtn.textContent = 'é‡è¯•ä¸‹è½½ä¸­...';
            debug.textContent += `\n\nğŸ”„ å¼€å§‹é‡è¯•ä¸‹è½½ ${failedDownloads.length} å¼ å¤±è´¥çš„æ•…äº‹å›¾ç‰‡...`;
            
            let retrySuccessCount = 0;
            
            for (let i = 0; i < failedDownloads.length; i++) {
                const failed = failedDownloads[i];
                
                try {
                    debug.textContent += `\né‡è¯•ä¸‹è½½ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    downloadBtn.textContent = `é‡è¯•ä¸­... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` âœ… é‡è¯•æˆåŠŸ`;
                    } else {
                        debug.textContent += ` âŒ é‡è¯•ä»ç„¶å¤±è´¥`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    debug.textContent += ` âŒ é‡è¯•å¤±è´¥: ${error.message}`;
                }
            }
            
            debug.textContent += `\n\nğŸ”„ é‡è¯•å®Œæˆ: ${retrySuccessCount}/${failedDownloads.length} å¼ æˆåŠŸ`;
            
            if (retrySuccessCount === failedDownloads.length) {
                alert(`ğŸ‰ é‡è¯•æˆåŠŸï¼æ‰€æœ‰æ•…äº‹å›¾ç‰‡éƒ½å·²ä¸‹è½½å®Œæˆï¼`);
            } else {
                alert(`é‡è¯•å®Œæˆ: ${retrySuccessCount} å¼ æˆåŠŸï¼Œ${failedDownloads.length - retrySuccessCount} å¼ ä»ç„¶å¤±è´¥ã€‚\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ‰‹åŠ¨ä¿å­˜å¤±è´¥çš„å›¾ç‰‡ã€‚`);
            }
            
            downloadBtn.textContent = 'ä¿å­˜æ‰€æœ‰å›¾ç‰‡';
        }

        // åŸæœ‰çš„å¤„ç†å‚è€ƒå›¾ç‰‡ä¸Šä¼  (æ”¯æŒå¤šå¼ )
        function handleRefImageUpload(event) {
            const files = Array.from(event.target.files);
            refImages = [];
            
            files.forEach((file, index) => {
                compressImage(file, (compressedDataUrl) => {
                    refImages.push({
                        data: compressedDataUrl,
                        name: file.name
                    });
                    
                    if (index === files.length - 1) {
                        displayRefImages();
                    }
                });
            });
        }

        // å›¾ç‰‡å‹ç¼©å‡½æ•°
        function compressImage(file, callback) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                // è®¡ç®—æ–°å°ºå¯¸ï¼Œæœ€å¤§è¾¹ä¸è¶…è¿‡1024åƒç´ 
                const maxSize = 1024;
                let { width, height } = img;
                
                if (width > height && width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                } else if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
                ctx.drawImage(img, 0, 0, width, height);
                
                // è½¬æ¢ä¸ºbase64ï¼Œè´¨é‡è®¾ä¸º0.8
                const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                callback(compressedDataUrl);
            };
            
            const reader = new FileReader();
            reader.onload = function(e) {
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayRefImages() {
            const preview = document.getElementById('refImagePreview');
            preview.innerHTML = refImages.map((img, index) => 
                `<img src="${img.data}" alt="Reference ${index + 1}" class="image-preview" title="${img.name}">`
            ).join('');
        }

        // å¤„ç†æ‹–æ‹½ä¸Šä¼ 
        const refUploadArea = document.querySelector('#refImageInput').parentElement;
        refUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#1890ff';
        });

        refUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#ddd';
        });

        refUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            refUploadArea.style.borderColor = '#ddd';
            const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
            
            if (files.length > 0) {
                refImages = [];
                files.forEach((file, index) => {
                    compressImage(file, (compressedDataUrl) => {
                        refImages.push({
                            data: compressedDataUrl,
                            name: file.name
                        });
                        
                        if (index === files.length - 1) {
                            displayRefImages();
                        }
                    });
                });
            }
        });

        // æµ‹è¯•OpenRouterè¿æ¥
        async function testOpenRouterConnection() {
            const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const testBtn = document.getElementById('testBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey) {
                alert('è¯·å…ˆè¾“å…¥ OpenRouter API Key');
                return;
            }

            testBtn.disabled = true;
            testBtn.textContent = 'æµ‹è¯•ä¸­...';
            debug.textContent = 'æ­£åœ¨æµ‹è¯• OpenRouter è¿æ¥...\n';

            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Sora Image Demo'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: "user",
                                content: "Hello, this is a test message."
                            }
                        ],
                        max_tokens: 10
                    })
                });

                const data = await response.json();
                
                debug.textContent += `API å“åº”çŠ¶æ€: ${response.status}\n`;
                debug.textContent += `API å“åº”å†…å®¹: ${JSON.stringify(data, null, 2)}\n`;
                
                if (response.ok && data.choices && data.choices.length > 0) {
                    debug.textContent += 'âœ… OpenRouter è¿æ¥æµ‹è¯•æˆåŠŸï¼';
                    alert('âœ… API Key æœ‰æ•ˆï¼Œè¿æ¥æµ‹è¯•æˆåŠŸï¼');
                } else {
                    debug.textContent += `âŒ è¿æ¥æµ‹è¯•å¤±è´¥: ${data.error?.message || 'æœªçŸ¥é”™è¯¯'}`;
                    alert(`âŒ è¿æ¥æµ‹è¯•å¤±è´¥: ${data.error?.message || 'æœªçŸ¥é”™è¯¯'}`);
                }
                
            } catch (error) {
                debug.textContent += `âŒ è¿æ¥æµ‹è¯•å‡ºé”™: ${error.message}`;
                alert(`è¿æ¥æµ‹è¯•å‡ºé”™ï¼š${error.message}`);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = 'æµ‹è¯•è¿æ¥';
            }
        }

        // æ‰¹é‡ç”Ÿæˆæç¤ºè¯
        async function generatePrompts() {
            const openrouterKey = document.getElementById('openrouterKey').value;
            const model = document.getElementById('modelSelect').value;
            const metaPrompt = document.getElementById('metaPrompt').value;
            const generatePromptBtn = document.getElementById('generatePromptBtn');
            const debug = document.getElementById('debug');

            if (!openrouterKey || !metaPrompt || refImages.length === 0) {
                alert('è¯·è¾“å…¥ OpenRouter API Keyã€å…ƒæç¤ºè¯å¹¶é€‰æ‹©å‚è€ƒå›¾ç‰‡');
                return;
            }

            generatePromptBtn.disabled = true;
            generatePromptBtn.textContent = 'ç”Ÿæˆä¸­...';
            debug.textContent = 'æ­£åœ¨æ‰¹é‡ç”Ÿæˆæç¤ºè¯...\n';
            promptsData = [];

            try {
                for (let i = 0; i < refImages.length; i++) {
                    const refImage = refImages[i];
                    debug.textContent += `\næ­£åœ¨å¤„ç†ç¬¬ ${i + 1} å¼ å›¾ç‰‡: ${refImage.name}`;

                    const messages = [
                        {
                            role: "user",
                            content: [
                                {
                                    type: "text",
                                    text: metaPrompt
                                },
                                {
                                    type: "image_url",
                                    image_url: {
                                        url: refImage.data
                                    }
                                }
                            ]
                        }
                    ];

                    debug.textContent += `\nå‘é€è¯·æ±‚åˆ° ${model}...`;

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openrouterKey}`,
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Sora Image Demo'
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            max_tokens: 1000
                        })
                    });

                    const data = await response.json();
                    
                    // æ˜¾ç¤ºè¯¦ç»†çš„APIå“åº”ä¿¡æ¯
                    debug.textContent += `\nAPI å“åº”çŠ¶æ€: ${response.status}`;
                    debug.textContent += `\nAPI å“åº”å†…å®¹: ${JSON.stringify(data, null, 2)}`;
                    
                    if (response.ok && data.choices && data.choices.length > 0) {
                        const generatedPrompt = data.choices[0]?.message?.content;
                        if (generatedPrompt && generatedPrompt.trim() && 
                            !generatedPrompt.includes('æŠ±æ­‰ï¼Œæˆ‘æ— æ³•') && 
                            !generatedPrompt.includes('I cannot') &&
                            !generatedPrompt.includes('I\'m unable to')) {
                            promptsData.push({
                                prompt: generatedPrompt.trim(),
                                refImage: refImage,
                                index: i
                            });
                            debug.textContent += `\nâœ… æç¤ºè¯ç”ŸæˆæˆåŠŸ: ${generatedPrompt.substring(0, 50)}...`;
                        } else {
                            debug.textContent += `\nâŒ æ¨¡å‹æ‹’ç»å¤„ç†æ­¤å›¾ç‰‡ï¼Œå¯èƒ½è§¦å‘äº†å†…å®¹å®‰å…¨è¿‡æ»¤`;
                        }
                    } else {
                        debug.textContent += `\nâŒ API è¯·æ±‚å¤±è´¥: ${data.error?.message || 'æœªçŸ¥é”™è¯¯'}`;
                        // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­å¤„ç†ä¸‹ä¸€å¼ å›¾ç‰‡
                    }
                    
                    // æ·»åŠ å»¶è¿Ÿé¿å…APIé™åˆ¶
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }

                if (promptsData.length > 0) {
                    displayPromptList();
                    debug.textContent += `\n\nâœ… æˆåŠŸç”Ÿæˆ ${promptsData.length} ä¸ªæç¤ºè¯ï¼`;
                } else {
                    debug.textContent += `\n\nâŒ æ²¡æœ‰æˆåŠŸç”Ÿæˆä»»ä½•æç¤ºè¯ï¼Œè¯·æ£€æŸ¥API Keyæˆ–ç½‘ç»œè¿æ¥`;
                    alert('æç¤ºè¯ç”Ÿæˆå¤±è´¥ï¼Œè¯·æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯');
                }
                
            } catch (error) {
                debug.textContent += `\n\nâŒ å‘ç”Ÿé”™è¯¯: ${error.message}`;
                debug.textContent += `\né”™è¯¯å †æ ˆ: ${error.stack}`;
                alert(`å‘ç”Ÿé”™è¯¯ï¼š${error.message}`);
            } finally {
                generatePromptBtn.disabled = false;
                generatePromptBtn.textContent = 'æ‰¹é‡ç”Ÿæˆ Prompts';
            }
        }

        function displayPromptList() {
            const promptListGroup = document.getElementById('promptListGroup');
            const promptList = document.getElementById('promptList');

        promptListGroup.style.display = 'block';
            promptList.innerHTML = promptsData.map((item, index) => `
                <div class="prompt-item">
                    <img src="${item.refImage.data}" alt="Reference ${index + 1}">
                    <textarea id="prompt_${index}" placeholder="ç”Ÿæˆçš„æç¤ºè¯...">${item.prompt}</textarea>
                </div>
            `).join('');
        }

        // ä»Markdownæ ¼å¼çš„å­—ç¬¦ä¸²ä¸­æå–å›¾ç‰‡URL (å¢å¼ºç‰ˆ)
        function extractImageUrl(content) {
            if (!content || typeof content !== 'string') {
                return null;
            }
            
            // æ–¹æ³•1: ä¼ ç»ŸMarkdownæ ¼å¼ [å›¾ç‰‡](URL)
            let match = content.match(/\[å›¾ç‰‡\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡Markdownæ ¼å¼æå–åˆ°URL:', match[1]);
                return match[1];
            }
            
            // æ–¹æ³•2: è‹±æ–‡Markdownæ ¼å¼ [image](URL) æˆ– [Image](URL)
            match = content.match(/\[(?:image|Image)\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡è‹±æ–‡Markdownæ ¼å¼æå–åˆ°URL:', match[1]);
                return match[1];
            }
            
            // æ–¹æ³•3: å…¶ä»–Markdownæ ¼å¼ ![alt](URL)
            match = content.match(/!\[.*?\]\((.*?)\)/);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡æ ‡å‡†Markdownå›¾ç‰‡æ ¼å¼æå–åˆ°URL:', match[1]);
                return match[1];
            }
            
            // æ–¹æ³•4: ç›´æ¥çš„HTTP/HTTPS URL
            match = content.match(/(https?:\/\/[^\s<>"'\[\]{}|\\^`]+(?:\.(?:png|jpg|jpeg|gif|webp|bmp|svg))?)/i);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼æå–åˆ°ç›´æ¥URL:', match[1]);
                return match[1];
            }
            
            // æ–¹æ³•5: æŸ¥æ‰¾ä»»ä½•çœ‹èµ·æ¥åƒå›¾ç‰‡URLçš„å†…å®¹
            match = content.match(/(?:url|src|href)["']?\s*:\s*["']?(https?:\/\/[^"'\s,}]+)/i);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡å±æ€§æ ¼å¼æå–åˆ°URL:', match[1]);
                return match[1];
            }
            
            // æ–¹æ³•6: æŸ¥æ‰¾è¢«å¼•å·åŒ…å›´çš„URL
            match = content.match(/["'](https?:\/\/[^"'\s]+\.(?:png|jpg|jpeg|gif|webp|bmp|svg))["']/i);
            if (match && match[1]) {
                console.log('âœ… é€šè¿‡å¼•å·åŒ…å›´æ ¼å¼æå–åˆ°URL:', match[1]);
                return match[1];
            }
            
            console.log('âŒ æ— æ³•ä»å†…å®¹ä¸­æå–å›¾ç‰‡URL:', content);
            return null;
        }

        // APIå¹³å°é…ç½®
        function getApiConfig() {
            const platform = document.getElementById('apiPlatform').value;
            const apiUrls = {
                yunwu: 'https://yunwu.ai/v1/chat/completions',
                apicore: 'https://api.apicore.ai/v1/chat/completions'
            };
            return {
                platform: platform,
                apiUrl: apiUrls[platform],
                platformName: platform === 'yunwu' ? 'äº‘é›¾' : 'APICore'
            };
        }

        // æ›´æ–°API Keyæ ‡ç­¾
        function updateApiKeyLabel() {
            const config = getApiConfig();
            const label = document.getElementById('apiKeyLabel');
            label.textContent = `${config.platformName} API Key:`;
            
            // ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
            saveApiConfig();
        }

        // ä¿å­˜APIé…ç½®åˆ°æœ¬åœ°å­˜å‚¨
        function saveApiConfig() {
            const config = {
                platform: document.getElementById('apiPlatform').value,
                apiKey: document.getElementById('apiKey').value
            };
            localStorage.setItem('soraImageConfig', JSON.stringify(config));
        }

        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½APIé…ç½®
        function loadApiConfig() {
            const savedConfig = localStorage.getItem('soraImageConfig');
            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                document.getElementById('apiPlatform').value = config.platform || 'yunwu';
                document.getElementById('apiKey').value = config.apiKey || '';
                updateApiKeyLabel();
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–é…ç½®
        document.addEventListener('DOMContentLoaded', function() {
            loadApiConfig();
        });

        // æ‰¹é‡ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡
    async function generateAllImages() {
        const apiKey = document.getElementById('apiKey').value;
        const imageCount = parseInt(document.getElementById('imageCount').value);
        const generateBtn = document.getElementById('generateBtn');
            const result = document.getElementById('result');
        const debug = document.getElementById('debug');
        const config = getApiConfig();

            if (!apiKey || promptsData.length === 0) {
                alert(`è¯·è¾“å…¥${config.platformName} API Key å¹¶å…ˆç”Ÿæˆæç¤ºè¯`);
                return;
            }

        generateBtn.disabled = true;
        generateBtn.textContent = 'ç”Ÿæˆä¸­...';
            result.innerHTML = 'æ­£åœ¨æ‰¹é‡ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...';
            generatedImages = [];

            try {
                debug.textContent += `\n\nå¼€å§‹æ‰¹é‡ç”Ÿæˆå›¾ç‰‡...`;
                debug.textContent += `\nğŸ“Š ç”Ÿæˆé…ç½®: ${promptsData.length}ä¸ªæç¤ºè¯ x ${imageCount}å¼ å›¾ç‰‡ = ${promptsData.length * imageCount}å¼ æ€»è®¡`;
                
                // æ£€æŸ¥å«å›¾æƒ…å†µ
                let totalWithRefImages = 0;
                let totalWithoutRefImages = 0;
                
                // åˆ›å»ºæ‰€æœ‰å¹¶å‘è¯·æ±‚
                const allRequests = [];
                
                for (let i = 0; i < promptsData.length; i++) {
                    const promptText = document.getElementById(`prompt_${i}`).value;
                    const refImageData = promptsData[i].refImage.data;
                    
                    if (!promptText.trim()) {
                        debug.textContent += `\nâš ï¸ è·³è¿‡ç»„${i + 1}: æç¤ºè¯ä¸ºç©º`;
                        continue;
                    }
                    
                    debug.textContent += `\nğŸ“‹ ç»„${i + 1}: ä½¿ç”¨å«å›¾ ${promptsData[i].refImage.name} (${imageCount}å¼ )`;
                    
                    // è¯¦ç»†æ£€æŸ¥å½“å‰ç»„çš„å«å›¾æ•°æ®
                    debug.textContent += `\nğŸ” ç»„${i + 1} å«å›¾æ•°æ®æºæ£€æŸ¥:`;
                    debug.textContent += `\n   - promptsData[${i}]å­˜åœ¨: ${!!promptsData[i]}`;
                    debug.textContent += `\n   - refImageå¯¹è±¡å­˜åœ¨: ${!!promptsData[i]?.refImage}`;
                    debug.textContent += `\n   - å«å›¾æ–‡ä»¶å: ${promptsData[i]?.refImage?.name || 'æœªçŸ¥'}`;
                    debug.textContent += `\n   - dataå­—æ®µå­˜åœ¨: ${!!promptsData[i]?.refImage?.data}`;
                    debug.textContent += `\n   - dataå­—æ®µç±»å‹: ${typeof promptsData[i]?.refImage?.data}`;
                    debug.textContent += `\n   - dataå­—æ®µé•¿åº¦: ${promptsData[i]?.refImage?.data?.length || 0} å­—ç¬¦`;
                    
                    for (let j = 0; j < imageCount; j++) {
                        if (refImageData && refImageData.trim()) {
                            totalWithRefImages++;
                            debug.textContent += `\n   âœ… ç¬¬${j + 1}å¼ å°†ä½¿ç”¨å«å›¾: ${promptsData[i].refImage.name}`;
                        } else {
                            totalWithoutRefImages++;
                            debug.textContent += `\n   âŒ ç¬¬${j + 1}å¼ æ— æœ‰æ•ˆå«å›¾æ•°æ®`;
                        }
                        
                        const requestPromise = generateSingleImage(apiKey, promptText, refImageData, i, j);
                        allRequests.push(requestPromise);
                    }
                }

                debug.textContent += `\nğŸ“Š ç”Ÿæˆç»Ÿè®¡: å«å›¾ç”Ÿæˆ${totalWithRefImages}å¼ , çº¯æ–‡æœ¬ç”Ÿæˆ${totalWithoutRefImages}å¼ `;
                debug.textContent += `\nå¼€å§‹å¹¶å‘ç”Ÿæˆ ${allRequests.length} å¼ å›¾ç‰‡...`;
                
                // å¹¶å‘æ‰§è¡Œæ‰€æœ‰è¯·æ±‚
                const results = await Promise.allSettled(allRequests);
                
                // å¤„ç†ç»“æœ
                let successCount = 0;
                let failCount = 0;
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value) {
                        generatedImages.push(result.value);
                        successCount++;
                        debug.textContent += `\nâœ… ç¬¬ ${index + 1} å¼ å›¾ç‰‡ç”ŸæˆæˆåŠŸ`;
                    } else {
                        failCount++;
                        debug.textContent += `\nâŒ ç¬¬ ${index + 1} å¼ å›¾ç‰‡ç”Ÿæˆå¤±è´¥: ${result.reason || 'æœªçŸ¥é”™è¯¯'}`;
                    }
                });

                displayGeneratedImages();
                document.getElementById('downloadBtn').style.display = 'inline-block';
                
                debug.textContent += `\n\nğŸ‰ æ‰¹é‡ç”Ÿæˆå®Œæˆï¼`;
                debug.textContent += `\nğŸ“Š æœ€ç»ˆç»Ÿè®¡: æˆåŠŸ${successCount}å¼ , å¤±è´¥${failCount}å¼ `;
                debug.textContent += `\nğŸ–¼ï¸ å«å›¾ç”ŸæˆæˆåŠŸ: ${successCount}å¼  (æ‰€æœ‰å›¾ç‰‡éƒ½ä½¿ç”¨äº†å«å›¾)`;
                
            } catch (error) {
                result.innerHTML = `å‘ç”Ÿé”™è¯¯ï¼š${error.message}`;
                debug.textContent += '\n\nError:\n' + error.stack;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'æ‰¹é‡ç”Ÿæˆå›¾ç‰‡';
            }
        }

        // å•ä¸ªå›¾ç‰‡ç”Ÿæˆå‡½æ•° (å¢å¼ºç‰ˆ)
        async function generateSingleImage(apiKey, promptText, refImageData, groupIndex, imageIndex) {
            const debug = document.getElementById('debug');
            
            // è·å–å«å›¾æ–‡ä»¶åç”¨äºæ—¥å¿—
            const refImageName = promptsData[groupIndex]?.refImage?.name || 'æœªçŸ¥æ–‡ä»¶';
            const requestId = `${groupIndex + 1}-${imageIndex + 1}`;
            
            debug.textContent += `\n\nğŸ” [${requestId}] å¼€å§‹å¤„ç†å›¾ç‰‡ç”Ÿæˆè¯·æ±‚`;
            debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
            
            // è¯¦ç»†æ£€æŸ¥å«å›¾æ•°æ®çŠ¶æ€
            debug.textContent += `\nğŸ” [${requestId}] å«å›¾æ•°æ®æ£€æŸ¥:`;
            debug.textContent += `\n   - refImageDataç±»å‹: ${typeof refImageData}`;
            debug.textContent += `\n   - refImageDataæ˜¯å¦å­˜åœ¨: ${!!refImageData}`;
            debug.textContent += `\n   - refImageDataé•¿åº¦: ${refImageData ? refImageData.length : 0} å­—ç¬¦`;
            
            if (refImageData) {
                debug.textContent += `\n   - æ•°æ®å¼€å¤´: ${refImageData.substring(0, 30)}...`;
                debug.textContent += `\n   - æ˜¯å¦ä¸ºdata:imageæ ¼å¼: ${refImageData.startsWith('data:image/')}`;
                
                // æ£€æŸ¥base64éƒ¨åˆ†
                const parts = refImageData.split(',');
                if (parts.length === 2) {
                    const base64Part = parts[1];
                    debug.textContent += `\n   - base64éƒ¨åˆ†é•¿åº¦: ${base64Part.length} å­—ç¬¦`;
                    debug.textContent += `\n   - ä¼°ç®—å›¾ç‰‡å¤§å°: ${Math.round(base64Part.length * 0.75 / 1024)}KB`;
                } else {
                    debug.textContent += `\n   - âŒ base64æ ¼å¼é”™è¯¯ï¼Œåˆ†å‰²åé•¿åº¦: ${parts.length}`;
                }
            }
            
            // éªŒè¯å«å›¾æ•°æ®
            const hasValidRefImage = validateRefImageData(refImageData, `[${requestId}]`);
            
            // æ„å»ºæ¶ˆæ¯å†…å®¹
            let messageContent;
            if (hasValidRefImage) {
                // æœ‰æœ‰æ•ˆå«å›¾çš„æƒ…å†µ
                messageContent = [
                    {
                        "type": "text",
                        "text": promptText
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": refImageData
                        }
                    }
                ];
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] ä½¿ç”¨å«å›¾ç”Ÿæˆæ¨¡å¼`;
                debug.textContent += `\nğŸ“‹ [${requestId}] æ¶ˆæ¯å†…å®¹åŒ…å«: æ–‡æœ¬ + å›¾ç‰‡URL`;
                debug.textContent += `\nğŸ¯ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
            } else {
                // æ²¡æœ‰å«å›¾æˆ–å«å›¾æ— æ•ˆçš„æƒ…å†µ
                messageContent = promptText;
                debug.textContent += `\nğŸ“ [${requestId}] çº¯æ–‡æœ¬ç”Ÿæˆæ¨¡å¼ (å«å›¾æ— æ•ˆæˆ–ç¼ºå¤±)`;
                debug.textContent += `\nğŸ“‹ [${requestId}] æ¶ˆæ¯å†…å®¹: ä»…æ–‡æœ¬`;
                debug.textContent += `\nâš ï¸ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName} (æœªä½¿ç”¨)`;
            }
            
            const messages = [
                {
                    role: "system",
                    content: "You are a helpful assistant."
                },
                {
                    role: "user",
                    content: messageContent
                }
            ];

            debug.textContent += `\nğŸš€ [${requestId}] å‡†å¤‡å‘é€APIè¯·æ±‚...`;
            debug.textContent += `\nğŸ“¦ [${requestId}] è¯·æ±‚ä½“å¤§å°: ${JSON.stringify(messages).length} å­—ç¬¦`;
            
            // è®°å½•è¯·æ±‚è¯¦æƒ…ï¼ˆä¸åŒ…å«å®Œæ•´çš„base64æ•°æ®ï¼Œé¿å…æ—¥å¿—è¿‡é•¿ï¼‰
            if (hasValidRefImage) {
                debug.textContent += `\nğŸ“· [${requestId}] è¯·æ±‚åŒ…å«å›¾ç‰‡: ${refImageName}`;
                debug.textContent += `\nğŸ”— [${requestId}] å›¾ç‰‡URLç±»å‹: ${refImageData.substring(0, 20)}...`;
            }
            
            try {
                // ğŸ”§ æ·»åŠ 60ç§’è¶…æ—¶æœºåˆ¶
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('è¯·æ±‚è¶…æ—¶ (60ç§’)')), 60000);
                });
                
                const config = getApiConfig();
                const fetchPromise = fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "sora_image",
                        messages: messages
                    })
                });
                
                const response = await Promise.race([fetchPromise, timeoutPromise]);

                debug.textContent += `\nğŸ“Š [${requestId}] APIå“åº”çŠ¶æ€: ${response.status}`;

                if (!response.ok) {
                    const errorText = await response.text();
                    debug.textContent += `\nâŒ [${requestId}] APIå“åº”é”™è¯¯: ${response.status} ${response.statusText}`;
                    debug.textContent += `\nâŒ [${requestId}] é”™è¯¯è¯¦æƒ…: ${errorText}`;
                    debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${hasValidRefImage ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}`;
                    debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                debug.textContent += `\nâœ… [${requestId}] APIè°ƒç”¨æˆåŠŸ`;
                debug.textContent += `\nğŸ“„ [${requestId}] å®Œæ•´å“åº”å†…å®¹: \`\`\`json\n${JSON.stringify(data, null, 2)}\n\`\`\``;
                
                // è¿›è¡ŒAPIå“åº”æ ¼å¼è¯Šæ–­
                const responseFormat = diagnoseApiResponse(data, requestId);
                
                // é€‚åº”æ–°çš„å“åº”æ ¼å¼å¤„ç†é€»è¾‘
                let imageUrl = null;
                
                // æ–¹æ³•1ï¼šæ£€æŸ¥ä¼ ç»Ÿæ ¼å¼ (choices[0].message.content)
                const content = data.choices?.[0]?.message?.content;
                if (content) {
                    imageUrl = extractImageUrl(content);
                    if (imageUrl) {
                        debug.textContent += `\nâœ… [${requestId}] ä»ä¼ ç»Ÿæ ¼å¼æå–åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                // æ–¹æ³•2ï¼šæ£€æŸ¥æ–°æ ¼å¼ - ç›´æ¥åœ¨å“åº”ä¸­æŸ¥æ‰¾å›¾ç‰‡URL
                if (!imageUrl) {
                    // æ£€æŸ¥å“åº”ä¸­æ˜¯å¦ç›´æ¥åŒ…å«å›¾ç‰‡URLå­—æ®µ
                    if (data.image_url) {
                        imageUrl = data.image_url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(image_urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    } else if (data.url) {
                        imageUrl = data.url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    } else if (data.result && data.result.url) {
                        imageUrl = data.result.url;
                        debug.textContent += `\nâœ… [${requestId}] ä»æ–°æ ¼å¼(result.urlå­—æ®µ)æå–åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                // æ–¹æ³•3ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºå¼‚æ­¥å“åº”æ ¼å¼
                if (!imageUrl) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡IDæˆ–å…¶ä»–å¼‚æ­¥æ ‡è¯†
                    if (data.task_id || data.id || data.prompt) {
                        debug.textContent += `\nâ³ [${requestId}] æ£€æµ‹åˆ°å¼‚æ­¥å“åº”æ ¼å¼`;
                        debug.textContent += `\nğŸ“‹ [${requestId}] å“åº”å‚æ•°ç¡®è®¤: ${JSON.stringify(data)}`;
                        
                        // æ˜¾ç¤ºæ ¼å¼å˜åŒ–æç¤º
                        if (responseFormat === 'async_params') {
                            showApiFormatChangeNotice();
                        }
                        
                        // å¯¹äºå¼‚æ­¥APIï¼Œæˆ‘ä»¬éœ€è¦ç­‰å¾…å¹¶è½®è¯¢ç»“æœ
                        debug.textContent += `\nâ³ [${requestId}] æ£€æµ‹åˆ°äº‘é›¾APIå¼‚æ­¥æ¨¡å¼ï¼Œå¼€å§‹è½®è¯¢ç»“æœ`;
                        
                        // è·å–ä»»åŠ¡ID
                        const taskId = data.task_id || data.id || data.prompt;
                        debug.textContent += `\nğŸ”‘ [${requestId}] ä»»åŠ¡ID: ${taskId}`;
                        
                        // è½®è¯¢ä»»åŠ¡ç»“æœ
                        try {
                            const pollResult = await pollTaskResult(apiKey, taskId, requestId);
                            if (pollResult && pollResult.imageUrl) {
                                imageUrl = pollResult.imageUrl;
                                debug.textContent += `\nâœ… [${requestId}] å¼‚æ­¥è½®è¯¢æˆåŠŸè·å–å›¾ç‰‡URL`;
                            } else {
                                throw new Error('è½®è¯¢ä»»åŠ¡ç»“æœå¤±è´¥');
                            }
                        } catch (pollError) {
                            debug.textContent += `\nâŒ [${requestId}] è½®è¯¢ä»»åŠ¡å¤±è´¥: ${pollError.message}`;
                            throw new Error(`å¼‚æ­¥APIè½®è¯¢å¤±è´¥: ${pollError.message}`);
                        }
                    }
                }
                
                // æ–¹æ³•4ï¼šå°è¯•åœ¨å“åº”æ–‡æœ¬ä¸­æŸ¥æ‰¾ä»»ä½•HTTP URL
                if (!imageUrl) {
                    const responseText = JSON.stringify(data);
                    const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                    const urls = responseText.match(urlRegex);
                    if (urls && urls.length > 0) {
                        imageUrl = urls[0];
                        debug.textContent += `\nâœ… [${requestId}] é€šè¿‡æ­£åˆ™è¡¨è¾¾å¼åœ¨å“åº”ä¸­æ‰¾åˆ°å›¾ç‰‡URL`;
                    }
                }
                
                if (!imageUrl) {
                    debug.textContent += `\nâŒ [${requestId}] æ‰€æœ‰æ–¹æ³•éƒ½æ— æ³•æå–å›¾ç‰‡URL`;
                    debug.textContent += `\nğŸ“„ [${requestId}] å“åº”æ•°æ®ç»“æ„: ${Object.keys(data).join(', ')}`;
                    debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${hasValidRefImage ? 'å·²ä½¿ç”¨' : 'æœªä½¿ç”¨'}`;
                    debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
                    
                    // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    const errorDetails = {
                        responseStructure: Object.keys(data),
                        hasChoices: !!data.choices,
                        hasContent: !!(data.choices?.[0]?.message?.content),
                        responseData: data
                    };
                    
                    throw new Error(`æœªèƒ½ä»å“åº”ä¸­æå–å›¾ç‰‡URLã€‚å“åº”æ ¼å¼å¯èƒ½å·²å˜åŒ–ã€‚è¯¦æƒ…: ${JSON.stringify(errorDetails, null, 2)}`);
                }

                debug.textContent += `\nğŸ‰ [${requestId}] å›¾ç‰‡ç”ŸæˆæˆåŠŸ!`;
                debug.textContent += `\nğŸ”— [${requestId}] å›¾ç‰‡URL: ${imageUrl.substring(0, 50)}...`;
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${hasValidRefImage ? 'âœ… å·²ä½¿ç”¨' : 'âŒ æœªä½¿ç”¨'}`;
                debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
                
                return {
                    url: imageUrl,
                    prompt: promptText,
                    refImage: refImageName,
                    groupIndex: groupIndex,
                    imageIndex: imageIndex,
                    usedRefImage: hasValidRefImage,
                    refImageFile: refImageName
                };
            } catch (error) {
                debug.textContent += `\nğŸ’¥ [${requestId}] ç”Ÿæˆè¿‡ç¨‹å‡ºé”™: ${error.message}`;
                debug.textContent += `\nğŸ–¼ï¸ [${requestId}] å«å›¾ä½¿ç”¨çŠ¶æ€: ${hasValidRefImage ? 'å·²é…ç½®ä½†å¤±è´¥' : 'æœªä½¿ç”¨'}`;
                debug.textContent += `\nğŸ“‚ [${requestId}] å«å›¾æ–‡ä»¶: ${refImageName}`;
                throw error;
            }
        }

        function displayGeneratedImages() {
            const result = document.getElementById('result');
            const withRefImageCount = generatedImages.filter(img => img.usedRefImage).length;
            const withoutRefImageCount = generatedImages.length - withRefImageCount;
            
            result.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">ç”Ÿæˆç»“æœ (å…± ${generatedImages.length} å¼ å›¾ç‰‡)ï¼š</h3>
                    <button id="batchDownloadBtn" class="btn-download" onclick="batchDownloadAllImages()" style="padding: 8px 16px; font-size: 14px;">
                        ğŸ“¥ æ‰¹é‡ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
                    </button>
                </div>
                <div style="background-color: #f0f8ff; border: 1px solid #91d5ff; border-radius: 6px; padding: 10px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 8px 0; color: #1890ff;">ğŸ“Š å«å›¾ä½¿ç”¨ç»Ÿè®¡</h4>
                    <p style="margin: 0;">
                        ğŸ–¼ï¸ ä½¿ç”¨å«å›¾ç”Ÿæˆ: <strong>${withRefImageCount}</strong> å¼  | 
                        ğŸ“ çº¯æ–‡æœ¬ç”Ÿæˆ: <strong>${withoutRefImageCount}</strong> å¼ 
                    </p>
                </div>
                <div class="image-grid">
                    ${generatedImages.map((img, index) => `
                        <div class="image-item">
                            <img src="${img.url}" alt="Generated Image ${index + 1}">
                            <div style="background-color: ${img.usedRefImage ? '#e6f7ff' : '#fff7e6'}; border: 1px solid ${img.usedRefImage ? '#91d5ff' : '#ffd591'}; border-radius: 4px; padding: 8px; margin: 8px 0;">
                                <div style="font-size: 12px; color: ${img.usedRefImage ? '#1890ff' : '#fa8c16'}; font-weight: bold;">
                                    ${img.usedRefImage ? 'ğŸ–¼ï¸ å«å›¾ç”Ÿæˆ' : 'ğŸ“ çº¯æ–‡æœ¬ç”Ÿæˆ'}
                                </div>
                                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                    å‚è€ƒå›¾: ${img.refImage}
                                </div>
                            </div>
                            <div style="margin: 10px 0;">
                                <label style="font-weight: bold; display: block; margin-bottom: 5px;">æç¤ºè¯ (å¯ç¼–è¾‘):</label>
                                <textarea id="prompt_edit_${index}" style="width: 100%; height: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; font-size: 12px; resize: vertical;">${img.prompt}</textarea>
                            </div>
                            <div class="image-controls">
                                <button class="btn-download" onclick="downloadSingleImage(${index})">ä¸‹è½½</button>
                                <button class="btn-copy" onclick="copyImageUrl(${index})">å¤åˆ¶URL</button>
                                <button class="btn-retry" onclick="retrySingleImageWithPrompt(${index})">é‡è¯•ç”Ÿæˆ</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // ä¸‹è½½å•å¼ å›¾ç‰‡
        async function downloadSingleImage(index) {
            const img = generatedImages[index];
            const filename = `generated_${img.groupIndex + 1}_${img.imageIndex + 1}_${img.refImage.split('.')[0]}.jpg`;
            const debug = document.getElementById('debug');
            
            try {
                debug.textContent += `\næ­£åœ¨ä¸‹è½½: ${filename}`;
                const success = await downloadImageWithRetry(img.url, filename, 3);
                
                if (success) {
                    debug.textContent += ` âœ… ä¸‹è½½æˆåŠŸ`;
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    event.target.textContent = 'å·²ä¸‹è½½';
                    event.target.style.backgroundColor = '#95de64';
                    event.target.disabled = true;
                    setTimeout(() => {
                        event.target.textContent = 'ä¸‹è½½';
                        event.target.style.backgroundColor = '#52c41a';
                        event.target.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥`;
                    alert('ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–å°è¯•å¤åˆ¶URLæ‰‹åŠ¨ä¸‹è½½');
                }
            } catch (error) {
                debug.textContent += ` âŒ ä¸‹è½½é”™è¯¯: ${error.message}`;
                alert(`ä¸‹è½½å¤±è´¥ï¼š${error.message}`);
            }
        }
        
        // å¤åˆ¶å›¾ç‰‡URL
        async function copyImageUrl(index) {
            const img = generatedImages[index];
            const debug = document.getElementById('debug');
            
            try {
                await navigator.clipboard.writeText(img.url);
                debug.textContent += `\nå·²å¤åˆ¶ç¬¬ ${index + 1} å¼ å›¾ç‰‡çš„URLåˆ°å‰ªè´´æ¿`;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                event.target.textContent = 'å·²å¤åˆ¶';
                event.target.style.backgroundColor = '#95de64';
                setTimeout(() => {
                    event.target.textContent = 'å¤åˆ¶URL';
                    event.target.style.backgroundColor = '#1890ff';
                }, 1500);
                
            } catch (error) {
                // å¦‚æœclipboard APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ³•
                const textArea = document.createElement('textarea');
                textArea.value = img.url;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    debug.textContent += `\nå·²å¤åˆ¶ç¬¬ ${index + 1} å¼ å›¾ç‰‡çš„URLåˆ°å‰ªè´´æ¿`;
                    alert('URLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                } catch (err) {
                    debug.textContent += `\nå¤åˆ¶å¤±è´¥: ${err.message}`;
                    alert(`å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ï¼š${img.url}`);
                }
                document.body.removeChild(textArea);
            }
        }

        // ä½¿ç”¨ä¿®æ”¹åçš„æç¤ºè¯é‡æ–°ç”Ÿæˆå•å¼ å›¾ç‰‡
        async function retrySingleImageWithPrompt(index) {
            const img = generatedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            const config = getApiConfig();
            
            if (!apiKey) {
                alert(`è¯·è¾“å…¥${config.platformName} API Key`);
                return;
            }
            
            // è·å–ç¼–è¾‘åçš„æç¤ºè¯
            const editedPrompt = document.getElementById(`prompt_edit_${index}`).value.trim();
            if (!editedPrompt) {
                alert('æç¤ºè¯ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'é‡è¯•ä¸­...';
            button.disabled = true;
            
            try {
                debug.textContent += `\n\nğŸ”„ é‡æ–°ç”Ÿæˆç¬¬ ${index + 1} å¼ å›¾ç‰‡...`;
                debug.textContent += `\nğŸ“ ä½¿ç”¨æ–°æç¤ºè¯: ${editedPrompt.substring(0, 100)}${editedPrompt.length > 100 ? '...' : ''}`;
                
                const newImage = await generateSingleImage(
                    apiKey, 
                    editedPrompt,  // ä½¿ç”¨ç¼–è¾‘åçš„æç¤ºè¯
                    promptsData[img.groupIndex].refImage.data, 
                    img.groupIndex, 
                    img.imageIndex
                );
                
                if (newImage) {
                    // æ›´æ–°å›¾ç‰‡æ•°æ®ï¼ŒåŒ…æ‹¬æ–°çš„æç¤ºè¯
                    generatedImages[index] = {
                        ...newImage,
                        prompt: editedPrompt  // ä¿å­˜æ–°çš„æç¤ºè¯
                    };
                    
                    // æ›´æ–°æ˜¾ç¤º
                    const imageElement = button.closest('.image-item').querySelector('img');
                    imageElement.src = newImage.url;
                    
                    debug.textContent += ` âœ… é‡æ–°ç”ŸæˆæˆåŠŸ`;
                    
                    // æ˜¾ç¤ºæˆåŠŸåé¦ˆ
                    button.textContent = 'ç”ŸæˆæˆåŠŸ';
                    button.style.backgroundColor = '#52c41a';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                        button.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆå¤±è´¥`;
                    throw new Error('ç”Ÿæˆå¤±è´¥');
                }
                
            } catch (error) {
                debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆé”™è¯¯: ${error.message}`;
                alert(`é‡æ–°ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
                
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // é‡æ–°ç”Ÿæˆå•å¼ å›¾ç‰‡ (ä¿æŒåŸæœ‰åŠŸèƒ½ä»¥å…¼å®¹)
        async function retrySingleImage(index) {
            const img = generatedImages[index];
            const apiKey = document.getElementById('apiKey').value;
            const debug = document.getElementById('debug');
            
            if (!apiKey) {
                alert('è¯·è¾“å…¥äº‘é›¾ API Key');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'é‡è¯•ä¸­...';
            button.disabled = true;
            
            try {
                debug.textContent += `\né‡æ–°ç”Ÿæˆç¬¬ ${index + 1} å¼ å›¾ç‰‡...`;
                
                const newImage = await generateSingleImage(
                    apiKey, 
                    img.prompt, 
                    promptsData[img.groupIndex].refImage.data, 
                    img.groupIndex, 
                    img.imageIndex
                );
                
                if (newImage) {
                    // æ›´æ–°å›¾ç‰‡æ•°æ®
                    generatedImages[index] = newImage;
                    
                    // æ›´æ–°æ˜¾ç¤º
                    const imageElement = button.closest('.image-item').querySelector('img');
                    imageElement.src = newImage.url;
                    
                    debug.textContent += ` âœ… é‡æ–°ç”ŸæˆæˆåŠŸ`;
                    
                    button.textContent = 'ç”ŸæˆæˆåŠŸ';
                    button.style.backgroundColor = '#95de64';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#fa8c16';
                        button.disabled = false;
                    }, 2000);
                } else {
                    debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆå¤±è´¥`;
                    throw new Error('ç”Ÿæˆå¤±è´¥');
                }
                
            } catch (error) {
                debug.textContent += ` âŒ é‡æ–°ç”Ÿæˆé”™è¯¯: ${error.message}`;
                alert(`é‡æ–°ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
                
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
        async function downloadAllImages() {
            const downloadBtn = document.getElementById('downloadBtn');
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'ä¸‹è½½ä¸­...';

            let successCount = 0;
            let failedDownloads = [];

            try {
                debug.textContent += '\n\nå¼€å§‹æ‰¹é‡ä¸‹è½½æ‰€æœ‰å›¾ç‰‡...';
                debug.textContent += '\nğŸ’¡ é‡‡ç”¨åˆ†æ‰¹ä¸‹è½½æ¨¡å¼ï¼Œç¡®ä¿ç¨³å®šæ€§...';
                
                // åˆ†æ‰¹ä¸‹è½½ï¼Œæ¯æ‰¹3å¼ å›¾ç‰‡ï¼Œé¿å…æµè§ˆå™¨é™åˆ¶
                const batchSize = 3;
                const totalBatches = Math.ceil(generatedImages.length / batchSize);
                
                for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                    const startIndex = batchIndex * batchSize;
                    const endIndex = Math.min(startIndex + batchSize, generatedImages.length);
                    const currentBatch = generatedImages.slice(startIndex, endIndex);
                    
                    debug.textContent += `\n\nğŸ“¦ ç¬¬ ${batchIndex + 1}/${totalBatches} æ‰¹ä¸‹è½½ (${currentBatch.length} å¼ å›¾ç‰‡)`;
                    downloadBtn.textContent = `ä¸‹è½½ä¸­... ç¬¬${batchIndex + 1}/${totalBatches}æ‰¹`;
                    
                    // å¹¶å‘ä¸‹è½½å½“å‰æ‰¹æ¬¡
                    const batchPromises = currentBatch.map(async (img, localIndex) => {
                        const globalIndex = startIndex + localIndex;
                        const filename = `generated_${img.groupIndex + 1}_${img.imageIndex + 1}_${img.refImage.split('.')[0]}.jpg`;
                        
                        try {
                            debug.textContent += `\næ­£åœ¨ä¸‹è½½ç¬¬ ${globalIndex + 1} å¼ : ${filename}`;
                            const success = await downloadImageWithRetry(img.url, filename, 2);
                            
                            if (success) {
                                successCount++;
                                debug.textContent += ` âœ…`;
                                return { success: true, index: globalIndex + 1, filename };
                            } else {
                                failedDownloads.push({ index: globalIndex + 1, filename, url: img.url });
                                debug.textContent += ` âŒ`;
                                return { success: false, index: globalIndex + 1, filename };
                            }
        } catch (error) {
                            failedDownloads.push({ index: globalIndex + 1, filename, url: img.url, error: error.message });
                            debug.textContent += ` âŒ ${error.message}`;
                            return { success: false, index: globalIndex + 1, filename, error: error.message };
                        }
                    });
                    
                    // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                    await Promise.allSettled(batchPromises);
                    
                    // æ‰¹æ¬¡é—´å»¶è¿Ÿï¼Œç»™æµè§ˆå™¨ç¼“å†²æ—¶é—´
                    if (batchIndex < totalBatches - 1) {
                        debug.textContent += `\nâ³ ç­‰å¾… 2 ç§’åå¼€å§‹ä¸‹ä¸€æ‰¹...`;
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }
                
                // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
                debug.textContent += `\n\nğŸ“Š æ‰¹é‡ä¸‹è½½å®Œæˆç»Ÿè®¡:`;
                debug.textContent += `\nâœ… æˆåŠŸä¸‹è½½: ${successCount} å¼ `;
                debug.textContent += `\nâŒ ä¸‹è½½å¤±è´¥: ${failedDownloads.length} å¼ `;
                
                if (failedDownloads.length > 0) {
                    debug.textContent += `\n\nå¤±è´¥åˆ—è¡¨:`;
                    failedDownloads.forEach(failed => {
                        debug.textContent += `\n- ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    });
                    
                    const retryChoice = confirm(`âœ… æˆåŠŸä¸‹è½½ ${successCount} å¼ å›¾ç‰‡\nâŒ ${failedDownloads.length} å¼ å¤±è´¥\n\nğŸ’¡ æç¤ºï¼šå¤±è´¥çš„å›¾ç‰‡å¯ä»¥ç‚¹å‡»å•ç‹¬çš„"ä¸‹è½½"æŒ‰é’®é‡è¯•\næˆ–è€…ç‚¹å‡»"å¤åˆ¶URL"æ‰‹åŠ¨ä¸‹è½½\n\næ˜¯å¦ç°åœ¨é‡æ–°å°è¯•ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡ï¼Ÿ`);
                    
                    if (retryChoice) {
                        await retryFailedDownloads(failedDownloads);
                    }
                } else {
                    debug.textContent += `\n\nğŸ‰ æ‰€æœ‰å›¾ç‰‡ä¸‹è½½æˆåŠŸï¼`;
                    alert(`ğŸ‰ æ­å–œï¼æˆåŠŸä¸‹è½½æ‰€æœ‰ ${successCount} å¼ å›¾ç‰‡ï¼`);
                }
                
            } catch (error) {
                debug.textContent += `\n\nâŒ æ‰¹é‡ä¸‹è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}`;
                alert(`ä¸‹è½½å¤±è´¥ï¼š${error.message}\n\nå»ºè®®ï¼šè¯·å°è¯•å•ç‹¬ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'ä¿å­˜æ‰€æœ‰å›¾ç‰‡';
            }
        }

        // æ‰¹é‡ä¸‹è½½æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡
        async function batchDownloadAllImages() {
            if (generatedImages.length === 0) {
                alert('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡');
                return;
            }

            const downloadBtn = document.getElementById('batchDownloadBtn');
            const originalText = downloadBtn.textContent;
            const debug = document.getElementById('debug');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'æ‰¹é‡ä¸‹è½½ä¸­...';
            
            debug.textContent += `\n\nğŸ”„ å¼€å§‹æ‰¹é‡ä¸‹è½½ ${generatedImages.length} å¼ å›¾ç‰‡...`;
            
            let successCount = 0;
            let failedDownloads = [];
            
            try {
                for (let i = 0; i < generatedImages.length; i++) {
                    const img = generatedImages[i];
                    const filename = `generated_${img.groupIndex + 1}_${img.imageIndex + 1}_${img.refImage.split('.')[0]}.jpg`;
                    
                    downloadBtn.textContent = `ä¸‹è½½ä¸­... (${i + 1}/${generatedImages.length})`;
                    debug.textContent += `\nä¸‹è½½ç¬¬ ${i + 1} å¼ : ${filename}`;
                    
                    try {
                        const success = await downloadImageWithRetry(img.url, filename, 2);
                        if (success) {
                            successCount++;
                            debug.textContent += ` âœ… ä¸‹è½½æˆåŠŸ`;
                        } else {
                            failedDownloads.push({
                                index: i + 1,
                                filename: filename,
                                url: img.url
                            });
                            debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥`;
                        }
                    } catch (error) {
                        failedDownloads.push({
                            index: i + 1,
                            filename: filename,
                            url: img.url
                        });
                        debug.textContent += ` âŒ ä¸‹è½½å¤±è´¥: ${error.message}`;
                    }
                    
                    // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                debug.textContent += `\n\nğŸ“Š æ‰¹é‡ä¸‹è½½å®Œæˆ: ${successCount}/${generatedImages.length} å¼ æˆåŠŸ`;
                
                if (failedDownloads.length === 0) {
                    alert(`ğŸ‰ æ‰€æœ‰å›¾ç‰‡ä¸‹è½½å®Œæˆï¼\næˆåŠŸä¸‹è½½ ${successCount} å¼ å›¾ç‰‡`);
                } else {
                    const retryChoice = confirm(`âœ… æˆåŠŸä¸‹è½½ ${successCount} å¼ å›¾ç‰‡\nâŒ ${failedDownloads.length} å¼ å¤±è´¥\n\nğŸ’¡ æç¤ºï¼šå¤±è´¥çš„å›¾ç‰‡å¯ä»¥ç‚¹å‡»å•ç‹¬çš„"ä¸‹è½½"æŒ‰é’®é‡è¯•\næˆ–è€…ç‚¹å‡»"å¤åˆ¶URL"æ‰‹åŠ¨ä¸‹è½½\n\næ˜¯å¦ç°åœ¨é‡æ–°å°è¯•ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡ï¼Ÿ`);
                    
                    if (retryChoice) {
                        await retryFailedDownloads(failedDownloads, downloadBtn, debug);
                    }
                }
                
            } catch (error) {
                debug.textContent += `\nâŒ æ‰¹é‡ä¸‹è½½å‡ºé”™: ${error.message}`;
                alert(`æ‰¹é‡ä¸‹è½½å¤±è´¥: ${error.message}`);
            } finally {
                downloadBtn.textContent = originalText;
                downloadBtn.disabled = false;
            }
        }

        // é‡è¯•å¤±è´¥çš„ä¸‹è½½
        async function retryFailedDownloads(failedDownloads, downloadBtn, debug) {
            downloadBtn.textContent = 'é‡è¯•ä¸‹è½½ä¸­...';
            debug.textContent += `\n\nğŸ”„ å¼€å§‹é‡è¯•ä¸‹è½½ ${failedDownloads.length} å¼ å¤±è´¥çš„å›¾ç‰‡...`;
            
            let retrySuccessCount = 0;
            
            try {
                for (let i = 0; i < failedDownloads.length; i++) {
                    const failed = failedDownloads[i];
                    debug.textContent += `\né‡è¯•ä¸‹è½½ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    downloadBtn.textContent = `é‡è¯•ä¸­... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` âœ… é‡è¯•æˆåŠŸ`;
                    } else {
                        debug.textContent += ` âŒ é‡è¯•ä»ç„¶å¤±è´¥`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                debug.textContent += `\n\nğŸ”„ é‡è¯•å®Œæˆ: ${retrySuccessCount}/${failedDownloads.length} å¼ æˆåŠŸ`;
                
                if (retrySuccessCount === failedDownloads.length) {
                    alert(`ğŸ‰ é‡è¯•æˆåŠŸï¼æ‰€æœ‰å›¾ç‰‡éƒ½å·²ä¸‹è½½å®Œæˆï¼`);
                } else {
                    alert(`é‡è¯•å®Œæˆ: ${retrySuccessCount} å¼ æˆåŠŸï¼Œ${failedDownloads.length - retrySuccessCount} å¼ ä»ç„¶å¤±è´¥ã€‚\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ‰‹åŠ¨ä¿å­˜å¤±è´¥çš„å›¾ç‰‡ã€‚`);
                }
                
            } catch (error) {
                debug.textContent += `\nâŒ é‡è¯•å¤±è´¥: ${error.message}`;
            }
        }

        // å¸¦é‡è¯•çš„å›¾ç‰‡ä¸‹è½½å‡½æ•°
        async function downloadImageWithRetry(url, filename, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const blob = await response.blob();
                    
                    // æ£€æŸ¥blobæ˜¯å¦æœ‰æ•ˆ
                    if (blob.size === 0) {
                        throw new Error('ä¸‹è½½çš„æ–‡ä»¶ä¸ºç©º');
                    }
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    
                    // ç¡®ä¿é“¾æ¥è¢«æ·»åŠ åˆ°DOMä¸­
                    document.body.appendChild(link);
                    link.click();
                    
                    // æ¸…ç†
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                    
                    return true; // ä¸‹è½½æˆåŠŸ
                    
                } catch (error) {
                    console.error(`ä¸‹è½½å°è¯• ${attempt} å¤±è´¥:`, error);
                    
                    if (attempt === maxRetries) {
                        throw error; // æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
                    }
                    
                    // ç­‰å¾…åé‡è¯•
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
            return false;
        }

        // é‡æ–°ä¸‹è½½å¤±è´¥çš„å›¾ç‰‡
        async function retryFailedDownloads(failedDownloads) {
        const debug = document.getElementById('debug');
            const downloadBtn = document.getElementById('downloadBtn');
            
            downloadBtn.textContent = 'é‡è¯•ä¸‹è½½ä¸­...';
            debug.textContent += `\n\nğŸ”„ å¼€å§‹é‡è¯•ä¸‹è½½ ${failedDownloads.length} å¼ å¤±è´¥çš„å›¾ç‰‡...`;
            
            let retrySuccessCount = 0;
            
            for (let i = 0; i < failedDownloads.length; i++) {
                const failed = failedDownloads[i];
                
                try {
                    debug.textContent += `\né‡è¯•ä¸‹è½½ç¬¬ ${failed.index} å¼ : ${failed.filename}`;
                    downloadBtn.textContent = `é‡è¯•ä¸­... (${i + 1}/${failedDownloads.length})`;
                    
                    const success = await downloadImageWithRetry(failed.url, failed.filename, 2);
                    
                    if (success) {
                        retrySuccessCount++;
                        debug.textContent += ` âœ… é‡è¯•æˆåŠŸ`;
            } else {
                        debug.textContent += ` âŒ é‡è¯•ä»ç„¶å¤±è´¥`;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                } catch (error) {
                    debug.textContent += ` âŒ é‡è¯•å¤±è´¥: ${error.message}`;
                }
            }
            
            debug.textContent += `\n\nğŸ”„ é‡è¯•å®Œæˆ: ${retrySuccessCount}/${failedDownloads.length} å¼ æˆåŠŸ`;
            
            if (retrySuccessCount === failedDownloads.length) {
                alert(`ğŸ‰ é‡è¯•æˆåŠŸï¼æ‰€æœ‰å›¾ç‰‡éƒ½å·²ä¸‹è½½å®Œæˆï¼`);
        } else {
                alert(`é‡è¯•å®Œæˆ: ${retrySuccessCount} å¼ æˆåŠŸï¼Œ${failedDownloads.length - retrySuccessCount} å¼ ä»ç„¶å¤±è´¥ã€‚\nè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ‰‹åŠ¨ä¿å­˜å¤±è´¥çš„å›¾ç‰‡ã€‚`);
            }
            
            downloadBtn.textContent = 'ä¿å­˜æ‰€æœ‰å›¾ç‰‡';
        }

        // å¯¼å‡ºæ•…äº‹è„šæœ¬ä¸ºCSV
        function exportStoryToCsv() {
            if (storyScript.length === 0) {
                alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•…äº‹è„šæœ¬');
                return;
            }
            
            const debug = document.getElementById('debug');
            debug.textContent += '\næ­£åœ¨å¯¼å‡ºæ•…äº‹è„šæœ¬ä¸ºCSV...';
            
            try {
                // å‡†å¤‡CSVæ•°æ®
                const csvHeaders = ['åˆ†é•œåºå·', 'æ–‡ç”Ÿå›¾prompt', 'å‚è€ƒå›¾ç‰‡æ•°é‡', 'å‚è€ƒå›¾ç‰‡åç§°', 'ç”Ÿæˆæ•°é‡', 'åˆ›å»ºæ—¶é—´'];
                const csvRows = [csvHeaders];
                
                // æ·»åŠ æ•°æ®è¡Œ
                storyScript.forEach((item, index) => {
                    const promptText = document.getElementById(`storyPrompt_${index}`)?.value || item.prompt;
                    const refImageCount = item.refImages ? item.refImages.length : 0;
                    const refImageNames = item.refImages ? item.refImages.map(img => img.name).join(';') : '';
                    const currentTime = new Date().toLocaleString('zh-CN');
                    
                    csvRows.push([
                        item.index,
                        `"${promptText.replace(/"/g, '""')}"`, // è½¬ä¹‰å¼•å·å¹¶ç”¨å¼•å·åŒ…å›´
                        refImageCount,
                        `"${refImageNames}"`,
                        item.imageCount,
                        currentTime
                    ]);
                });
                
                // è½¬æ¢ä¸ºCSVå­—ç¬¦ä¸²
                const csvContent = csvRows.map(row => row.join(',')).join('\n');
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' }); // æ·»åŠ BOMä»¥æ”¯æŒä¸­æ–‡
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                link.setAttribute('href', url);
                link.setAttribute('download', `story_script_${timestamp}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                debug.textContent += '\nâœ… æ•…äº‹è„šæœ¬CSVå¯¼å‡ºæˆåŠŸï¼';
                debug.textContent += `\nğŸ“ æ–‡ä»¶å: story_script_${timestamp}.csv`;
                debug.textContent += `\nğŸ“Š å¯¼å‡º${storyScript.length}ä¸ªåˆ†é•œçš„è¯¦ç»†ä¿¡æ¯`;
                
                // æ˜¾ç¤ºå¯¼å‡ºæ‘˜è¦
                const totalPromptLength = storyScript.reduce((sum, item, index) => {
                    const promptText = document.getElementById(`storyPrompt_${index}`)?.value || item.prompt;
                    return sum + promptText.length;
                }, 0);
                
                const exportSummary = `
ğŸ“„ CSVå¯¼å‡ºå®Œæˆï¼
ğŸ“Š å¯¼å‡ºç»Ÿè®¡:
   - åˆ†é•œæ•°é‡: ${storyScript.length}
   - æç¤ºè¯æ€»é•¿åº¦: ${totalPromptLength} å­—ç¬¦
   - å‚è€ƒå›¾ç‰‡æ€»æ•°: ${storyScript.reduce((sum, item) => sum + (item.refImages ? item.refImages.length : 0), 0)}
   - æ–‡ä»¶å: story_script_${timestamp}.csv
                `;
                
                alert(exportSummary);
                
        } catch (error) {
                debug.textContent += `\nâŒ CSVå¯¼å‡ºå¤±è´¥: ${error.message}`;
                alert(`CSVå¯¼å‡ºå¤±è´¥ï¼š${error.message}`);
            }
        }

        // éªŒè¯å«å›¾æ•°æ®çš„æœ‰æ•ˆæ€§
        function validateRefImageData(refImageData, context = '') {
            const debug = document.getElementById('debug');
            
            debug.textContent += `\nğŸ” ${context} å«å›¾æ•°æ®éªŒè¯:`;
            
            if (!refImageData) {
                debug.textContent += `\nâŒ ${context}: æ— å«å›¾æ•°æ® (refImageDataä¸ºnull/undefined)`;
                return false;
            }
            
            if (typeof refImageData !== 'string') {
                debug.textContent += `\nâŒ ${context}: å«å›¾æ•°æ®ç±»å‹é”™è¯¯ (${typeof refImageData}ï¼Œåº”ä¸ºstring)`;
                return false;
            }
            
            if (!refImageData.trim()) {
                debug.textContent += `\nâŒ ${context}: å«å›¾æ•°æ®ä¸ºç©ºå­—ç¬¦ä¸²`;
                return false;
            }
            
            debug.textContent += `\n   - æ•°æ®é•¿åº¦: ${refImageData.length} å­—ç¬¦`;
            debug.textContent += `\n   - æ•°æ®å‰ç¼€: ${refImageData.substring(0, 50)}...`;
            
            if (!refImageData.startsWith('data:image/')) {
                debug.textContent += `\nâŒ ${context}: å«å›¾æ•°æ®æ ¼å¼é”™è¯¯ (ä¸æ˜¯æœ‰æ•ˆçš„data:image/ URL)`;
                debug.textContent += `\n   å®é™…å¼€å¤´: ${refImageData.substring(0, 50)}...`;
                return false;
            }
            
            // æ£€æŸ¥base64æ•°æ®çš„å®Œæ•´æ€§
            const parts = refImageData.split(',');
            if (parts.length !== 2) {
                debug.textContent += `\nâŒ ${context}: base64æ•°æ®æ ¼å¼é”™è¯¯ï¼Œåˆ†å‰²åéƒ¨åˆ†æ•°: ${parts.length} (åº”ä¸º2)`;
                return false;
            }
            
            const [header, base64Part] = parts;
            debug.textContent += `\n   - MIMEç±»å‹: ${header}`;
            debug.textContent += `\n   - base64é•¿åº¦: ${base64Part.length} å­—ç¬¦`;
            
            if (!base64Part || base64Part.length < 100) {
                debug.textContent += `\nâŒ ${context}: base64æ•°æ®è¿‡çŸ­æˆ–æ— æ•ˆ (é•¿åº¦: ${base64Part ? base64Part.length : 0})`;
                return false;
            }
            
            // æ£€æŸ¥base64å­—ç¬¦çš„æœ‰æ•ˆæ€§
            const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
            if (!base64Regex.test(base64Part)) {
                debug.textContent += `\nâŒ ${context}: base64æ•°æ®åŒ…å«æ— æ•ˆå­—ç¬¦`;
                return false;
            }
            
            // è®¡ç®—å›¾ç‰‡å¤§å°
            const imageSizeKB = Math.round(base64Part.length * 0.75 / 1024);
            debug.textContent += `\n   - ä¼°ç®—å›¾ç‰‡å¤§å°: ${imageSizeKB}KB`;
            
            // æ£€æŸ¥å›¾ç‰‡å¤§å°æ˜¯å¦åˆç†
            if (imageSizeKB > 10240) { // 10MB
                debug.textContent += `\nâš ï¸ ${context}: å«å›¾è¿‡å¤§ (${imageSizeKB}KB)ï¼Œå¯èƒ½å¯¼è‡´APIè°ƒç”¨å¤±è´¥`;
            } else if (imageSizeKB < 1) {
                debug.textContent += `\nâš ï¸ ${context}: å«å›¾è¿‡å° (${imageSizeKB}KB)ï¼Œå¯èƒ½è´¨é‡ä¸ä½³`;
            }
            
            debug.textContent += `\nâœ… ${context}: å«å›¾æ•°æ®éªŒè¯é€šè¿‡ (${imageSizeKB}KB)`;
            return true;
        }

        // ğŸ” è°ƒè¯•æ•…äº‹æ•°æ®çŠ¶æ€çš„å‡½æ•°
        function debugStoryDataState() {
            const debug = document.getElementById('debug');
            debug.textContent += `\n\nğŸ” === æ•…äº‹æ•°æ®çŠ¶æ€è°ƒè¯• ===`;
            storyScript.forEach((item, index) => {
                debug.textContent += `\nğŸ“‹ åˆ†é•œ${item.index} (ç´¢å¼•${index}):`;
                debug.textContent += `\n   - refImagesæ•°ç»„é•¿åº¦: ${item.refImages ? item.refImages.length : 'null'}`;
                if (item.refImages && item.refImages.length > 0) {
                    debug.textContent += `\n   - refImagesè¯¦æƒ…: ${item.refImages.map((img, i) => `[${i}]${img.name}(${img.data ? 'æœ‰æ•°æ®' : 'æ— æ•°æ®'})`).join(', ')}`;
                }
                debug.textContent += `\n   - imageCount: ${item.imageCount}`;
            });
            debug.textContent += `\nğŸ” === è°ƒè¯•ç»“æŸ ===\n`;
        }

        // æ¸…ç©ºæ•…äº‹å†å²å›¾ç‰‡
        function clearStoryHistory() {
            const debug = document.getElementById('debug');
            
            // ç¡®è®¤æ“ä½œ
            if (storyGeneratedImages.length === 0) {
                alert('å½“å‰æ²¡æœ‰å†å²å›¾ç‰‡å¯ä»¥æ¸…ç©º');
                return;
            }
            
            const confirmMessage = `ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²å›¾ç‰‡å—ï¼Ÿ\n\nå½“å‰å…±æœ‰ ${storyGeneratedImages.length} å¼ å›¾ç‰‡å°†è¢«æ¸…ç©ºï¼š\n- æ‰€æœ‰æ‰¹æ¬¡çš„ç”Ÿæˆè®°å½•\n- æ‰€æœ‰ä¸‹è½½å’Œé‡è¯•å†å²\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`;
            
            if (!confirm(confirmMessage)) {
                debug.textContent += '\nâ¹ï¸ ç”¨æˆ·å–æ¶ˆäº†æ¸…ç©ºå†å²æ“ä½œ';
                return;
            }
            
            // è®°å½•æ¸…ç©ºå‰çš„çŠ¶æ€
            const clearedCount = storyGeneratedImages.length;
            const groupedByBatch = {};
            storyGeneratedImages.forEach(img => {
                const batchKey = img.batchIndex || 1;
                groupedByBatch[batchKey] = (groupedByBatch[batchKey] || 0) + 1;
            });
            
            // æ¸…ç©ºæ•°æ®
            storyGeneratedImages = [];
            
            // æ›´æ–°UI
            updateStoryResult();
            
            // éšè—ä¸‹è½½æŒ‰é’®
            document.getElementById('downloadAllStoryBtn').style.display = 'none';
            
            // è®°å½•æ“ä½œæ—¥å¿—
            debug.textContent += `\n\nğŸ—‘ï¸ === å†å²å›¾ç‰‡æ¸…ç©ºæ“ä½œ ===`;
            debug.textContent += `\nğŸ§¹ æ¸…ç©ºæ—¶é—´: ${new Date().toLocaleString()}`;
            debug.textContent += `\nğŸ“Š æ¸…ç©ºç»Ÿè®¡: å…±æ¸…ç©º ${clearedCount} å¼ å›¾ç‰‡`;
            debug.textContent += `\nğŸ“¦ æ¶‰åŠæ‰¹æ¬¡: ${Object.keys(groupedByBatch).map(batch => `æ‰¹æ¬¡${batch}(${groupedByBatch[batch]}å¼ )`).join(', ')}`;
            debug.textContent += `\nâœ… å†å²æ•°æ®å·²å®Œå…¨æ¸…ç©ºï¼Œå¯ä»¥é‡æ–°å¼€å§‹ç”Ÿæˆ`;
            debug.textContent += `\nğŸ” === æ¸…ç©ºæ“ä½œå®Œæˆ ===\n`;
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            alert(`ğŸ—‘ï¸ å†å²å›¾ç‰‡æ¸…ç©ºå®Œæˆï¼\n\nå·²æ¸…ç©º ${clearedCount} å¼ å›¾ç‰‡\nç°åœ¨å¯ä»¥é‡æ–°å¼€å§‹ç”Ÿæˆæ•…äº‹å›¾ç‰‡äº†`);
        }

        // ä½¿ç”¨GBKç¼–ç è¯»å–æ–‡ä»¶ï¼ˆANSIä¸­æ–‡å¸¸ç”¨ç¼–ç ï¼‰
        function tryReadWithGBK(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                try {
                    // ä½¿ç”¨TextDecoderå°è¯•GBKè§£ç 
                    const decoder = new TextDecoder('gbk');
                    const csvText = decoder.decode(arrayBuffer);
                    
                    console.log('GBKè§£ç ç»“æœå‰100å­—ç¬¦:', csvText.substring(0, 100));
                    
                    if (csvText && csvText.trim() && isValidText(csvText)) {
                        console.log('ä½¿ç”¨GBKç¼–ç æˆåŠŸè¯»å–CSVæ–‡ä»¶');
                        parseCsvAndDisplayPreview(csvText);
                    } else {
                        console.log('GBKè§£ç ç»“æœæ— æ•ˆï¼Œå°è¯•å…¶ä»–ç¼–ç ');
                        // GBKä¹Ÿå¤±è´¥ï¼Œå°è¯•å…¶ä»–ç¼–ç 
                        tryReadWithOtherEncodings(file);
                    }
                } catch (error) {
                    console.log('GBKè§£ç å¤±è´¥:', error);
                    // GBKè§£ç å¤±è´¥ï¼Œå°è¯•å…¶ä»–ç¼–ç 
                    tryReadWithOtherEncodings(file);
                }
            };
            reader.onerror = function() {
                console.log('ArrayBufferè¯»å–å¤±è´¥ï¼Œå°è¯•å…¶ä»–ç¼–ç ...');
                tryReadWithOtherEncodings(file);
            };
            reader.readAsArrayBuffer(file); // ä¿®å¤ï¼šä½¿ç”¨readAsArrayBufferè€Œä¸æ˜¯readAsText
        }
        
        // å°è¯•å…¶ä»–ç¼–ç 
        function tryReadWithOtherEncodings(file) {
            const encodings = ['gb2312', 'big5', 'windows-1252'];
            let encodingIndex = 0;
            
            function tryNextEncoding() {
                if (encodingIndex >= encodings.length) {
                    // æ‰€æœ‰ç¼–ç éƒ½å¤±è´¥ï¼Œä½¿ç”¨UTF-8ä½œä¸ºæœ€åå°è¯•å¹¶æç¤ºç”¨æˆ·
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const csvText = e.target.result;
                        console.warn('æ‰€æœ‰ç¼–ç å°è¯•å®Œæ¯•ï¼Œä½¿ç”¨UTF-8ç¼–ç è¯»å–ï¼Œå¯èƒ½å­˜åœ¨ä¹±ç ');
                        alert('æ–‡ä»¶ç¼–ç æ£€æµ‹å¤±è´¥ï¼Œå·²ä½¿ç”¨UTF-8è¯»å–ã€‚\n\nå¦‚æœå‡ºç°ä¹±ç ï¼Œè¯·å°è¯•ï¼š\n1. å°†CSVæ–‡ä»¶å¦å­˜ä¸ºUTF-8ç¼–ç \n2. æˆ–ä½¿ç”¨æˆ‘ä»¬æä¾›çš„ä¿®å¤ç‰ˆæœ¬æ–‡ä»¶ prompt_fixed.csv');
                        parseCsvAndDisplayPreview(csvText);
                    };
                    reader.readAsText(file, 'UTF-8');
                    return;
                }
                
                const encoding = encodings[encodingIndex];
                console.log(`å°è¯•ä½¿ç”¨${encoding}ç¼–ç ...`);
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const arrayBuffer = e.target.result;
                        const decoder = new TextDecoder(encoding);
                        const csvText = decoder.decode(arrayBuffer);
                        
                        console.log(`${encoding}è§£ç ç»“æœå‰100å­—ç¬¦:`, csvText.substring(0, 100));
                        
                        if (csvText && csvText.trim() && isValidText(csvText)) {
                            console.log(`æˆåŠŸä½¿ç”¨${encoding}ç¼–ç è¯»å–æ–‡ä»¶`);
                            parseCsvAndDisplayPreview(csvText);
                        } else {
                            console.log(`${encoding}è§£ç ç»“æœæ— æ•ˆï¼Œå°è¯•ä¸‹ä¸€ä¸ªç¼–ç `);
                            encodingIndex++;
                            tryNextEncoding();
                        }
                    } catch (error) {
                        console.log(`${encoding}è§£ç å¤±è´¥:`, error);
                        encodingIndex++;
                        tryNextEncoding();
                    }
                };
                reader.readAsArrayBuffer(file);
            }
            
            tryNextEncoding();
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8
        function isValidUTF8Text(text) {
            console.log('éªŒè¯UTF-8æ–‡æœ¬ï¼Œå‰100å­—ç¬¦:', text.substring(0, 100));
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å¸¸è§çš„ä¹±ç å­—ç¬¦æˆ–å¼‚å¸¸å­—ç¬¦
            const invalidChars = /[\uFFFD\u0000-\u0008\u000E-\u001F\u007F-\u009F]/;
            
            // å¦‚æœåŒ…å«æ›¿æ¢å­—ç¬¦()æˆ–æ§åˆ¶å­—ç¬¦ï¼Œå¯èƒ½æ˜¯ç¼–ç é—®é¢˜
            if (invalidChars.test(text)) {
                console.log('æ£€æµ‹åˆ°æ— æ•ˆå­—ç¬¦ï¼Œå¯èƒ½æ˜¯ç¼–ç é—®é¢˜');
                return false;
            }
            
            // æ£€æŸ¥ä¸­æ–‡å­—ç¬¦æ˜¯å¦æ­£å¸¸æ˜¾ç¤º
            const chineseChars = text.match(/[\u4e00-\u9fff]/g);
            if (chineseChars) {
                console.log('æ£€æµ‹åˆ°ä¸­æ–‡å­—ç¬¦æ•°é‡:', chineseChars.length);
                // å¦‚æœæœ‰ä¸­æ–‡å­—ç¬¦ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¿ç»­çš„å¼‚å¸¸å­—ç¬¦æ¨¡å¼
                const suspiciousPattern = /[Ã€-Ã¿]{3,}/g; // å¯èƒ½æ˜¯GBKé”™è¯¯è§£ç ä¸ºUTF-8çš„æ¨¡å¼
                if (suspiciousPattern.test(text)) {
                    console.log('æ£€æµ‹åˆ°å¯ç–‘çš„å­—ç¬¦æ¨¡å¼ï¼Œå¯èƒ½æ˜¯GBKç¼–ç ');
                    return false;
                }
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å¸¸è§çš„CSVå¤´éƒ¨å…³é”®å­—
            const csvHeaders = /åˆ†é•œåºå·|æ–‡ç”Ÿå›¾|prompt|å›¾è½¬è§†é¢‘/;
            if (!csvHeaders.test(text.substring(0, 200))) {
                console.log('æœªæ£€æµ‹åˆ°é¢„æœŸçš„CSVå¤´éƒ¨ä¿¡æ¯');
                return false;
            }
            
            console.log('UTF-8æ–‡æœ¬éªŒè¯é€šè¿‡');
            return true;
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦æœ‰æ•ˆï¼ˆç”¨äºå…¶ä»–ç¼–ç ï¼‰
        function isValidText(text) {
            console.log('éªŒè¯æ–‡æœ¬æœ‰æ•ˆæ€§ï¼Œå‰100å­—ç¬¦:', text.substring(0, 100));
            
            // åŸºæœ¬æ£€æŸ¥ï¼šæ–‡æœ¬ä¸ä¸ºç©ºä¸”åŒ…å«å¯è¯»å­—ç¬¦
            if (!text || !text.trim()) {
                console.log('æ–‡æœ¬ä¸ºç©ºæˆ–åªæœ‰ç©ºç™½å­—ç¬¦');
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«è¿‡å¤šçš„å¼‚å¸¸å­—ç¬¦
            const totalChars = text.length;
            const invalidChars = (text.match(/[\uFFFD\u0000-\u0008\u000E-\u001F\u007F-\u009F]/g) || []).length;
            
            // å¦‚æœå¼‚å¸¸å­—ç¬¦è¶…è¿‡5%ï¼Œè®¤ä¸ºç¼–ç å¯èƒ½æœ‰é—®é¢˜
            if ((invalidChars / totalChars) >= 0.05) {
                console.log(`å¼‚å¸¸å­—ç¬¦è¿‡å¤š: ${invalidChars}/${totalChars} (${((invalidChars/totalChars)*100).toFixed(1)}%)`);
                return false;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å¸¸è§çš„CSVå¤´éƒ¨å…³é”®å­—ï¼ˆä¸­æ–‡ï¼‰
            const csvHeaders = /åˆ†é•œåºå·|æ–‡ç”Ÿå›¾|prompt|å›¾è½¬è§†é¢‘|åºå·/;
            if (csvHeaders.test(text.substring(0, 200))) {
                console.log('æ£€æµ‹åˆ°æœ‰æ•ˆçš„CSVå¤´éƒ¨ä¿¡æ¯');
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰åŸºæœ¬çš„CSVç»“æ„ï¼ˆè‡³å°‘åŒ…å«é€—å·ï¼‰
            const hasCSVStructure = text.includes(',') && text.includes('\n');
            if (hasCSVStructure) {
                console.log('æ£€æµ‹åˆ°åŸºæœ¬çš„CSVç»“æ„');
                return true;
            }
            
            console.log('æ–‡æœ¬æ ¼å¼éªŒè¯å¤±è´¥');
            return false;
        }

        // APIçŠ¶æ€è¯Šæ–­å’Œå»ºè®®
        function diagnoseApiResponse(data, requestId) {
            const debug = document.getElementById('debug');
            
            debug.textContent += `\n\nğŸ”§ [${requestId}] APIå“åº”æ ¼å¼è¯Šæ–­:`;
            
            // æ£€æŸ¥å“åº”ç»“æ„
            const responseKeys = Object.keys(data);
            debug.textContent += `\n   ğŸ“‹ å“åº”å­—æ®µ: ${responseKeys.join(', ')}`;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¼ ç»Ÿæ ¼å¼
            if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                debug.textContent += `\n   âœ… æ£€æµ‹åˆ°ä¼ ç»ŸChatGPTæ ¼å¼`;
                return 'traditional';
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°çš„å¼‚æ­¥æ ¼å¼
            if (data.prompt && data.ratio && data.n) {
                debug.textContent += `\n   âš ï¸ æ£€æµ‹åˆ°æ–°çš„å¼‚æ­¥æ ¼å¼ (ä»…è¿”å›å‚æ•°ç¡®è®¤)`;
                debug.textContent += `\n   ğŸ’¡ å»ºè®®è§£å†³æ–¹æ¡ˆ:`;
                debug.textContent += `\n      1. æ£€æŸ¥äº‘é›¾AIå®˜æ–¹æ–‡æ¡£æ˜¯å¦æœ‰APIæ›´æ–°è¯´æ˜`;
                debug.textContent += `\n      2. æŸ¥çœ‹æ˜¯å¦éœ€è¦ä½¿ç”¨æ–°çš„ç«¯ç‚¹æˆ–å‚æ•°`;
                debug.textContent += `\n      3. ç¡®è®¤æ˜¯å¦éœ€è¦å¼‚æ­¥è½®è¯¢ç»“æœ`;
                debug.textContent += `\n      4. è”ç³»äº‘é›¾AIæŠ€æœ¯æ”¯æŒè·å–æœ€æ–°APIæ–‡æ¡£`;
                return 'async_params';
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡ID
            if (data.task_id || data.id || data.job_id) {
                debug.textContent += `\n   â³ æ£€æµ‹åˆ°å¼‚æ­¥ä»»åŠ¡æ ¼å¼`;
                debug.textContent += `\n   ğŸ’¡ è¿™ç§æ ¼å¼é€šå¸¸éœ€è¦è½®è¯¢ä»»åŠ¡çŠ¶æ€`;
                return 'async_task';
            }
            
            // æ£€æŸ¥æ˜¯å¦ç›´æ¥åŒ…å«å›¾ç‰‡URL
            if (data.image_url || data.url || (data.result && data.result.url)) {
                debug.textContent += `\n   âœ… æ£€æµ‹åˆ°ç›´æ¥URLæ ¼å¼`;
                return 'direct_url';
            }
            
            debug.textContent += `\n   â“ æœªçŸ¥çš„å“åº”æ ¼å¼`;
            return 'unknown';
        }

        // æ˜¾ç¤ºAPIæ ¼å¼å˜åŒ–çš„ç”¨æˆ·æç¤º
        // è½®è¯¢ä»»åŠ¡ç»“æœå‡½æ•°
        async function pollTaskResult(apiKey, taskId, requestId) {
            const debug = document.getElementById('debug');
            const maxAttempts = 30; // æœ€å¤šè½®è¯¢30æ¬¡
            const pollInterval = 2000; // æ¯2ç§’è½®è¯¢ä¸€æ¬¡
            
            debug.textContent += `\nğŸ”„ [${requestId}] å¼€å§‹è½®è¯¢ä»»åŠ¡ç»“æœï¼Œä»»åŠ¡ID: ${taskId}`;
            debug.textContent += `\nâ±ï¸ [${requestId}] è½®è¯¢è®¾ç½®: é—´éš”${pollInterval/1000}ç§’ï¼Œæœ€å¤š${maxAttempts}æ¬¡`;
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                debug.textContent += `\nğŸ”„ [${requestId}] è½®è¯¢ç¬¬${attempt}æ¬¡...`;
                
                try {
                    // ç­‰å¾…æŒ‡å®šæ—¶é—´
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                    
                    // å‘é€è½®è¯¢è¯·æ±‚
                    const config = getApiConfig();
                    const response = await fetch(`${config.apiUrl}/${taskId}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        debug.textContent += `\nâŒ [${requestId}] è½®è¯¢è¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`;
                        debug.textContent += `\nâŒ [${requestId}] é”™è¯¯è¯¦æƒ…: ${errorText}`;
                        
                        // å¦‚æœæ˜¯404ï¼Œå¯èƒ½æ˜¯ä»»åŠ¡IDæ ¼å¼ä¸å¯¹ï¼Œå°è¯•å¤‡ç”¨ç«¯ç‚¹
                        if (response.status === 404 && attempt === 1) {
                            debug.textContent += `\nğŸ”„ [${requestId}] å°è¯•å¤‡ç”¨è½®è¯¢ç«¯ç‚¹...`;
                            return await pollTaskResultAlternative(apiKey, taskId, requestId);
                        }
                        
                        continue; // ç»§ç»­ä¸‹ä¸€æ¬¡è½®è¯¢
                    }
                    
                    const data = await response.json();
                    debug.textContent += `\nğŸ“‹ [${requestId}] è½®è¯¢å“åº”: ${JSON.stringify(data)}`;
                    
                    // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å®Œæˆ
                    if (data.status === 'completed' || data.status === 'succeeded') {
                        // å°è¯•ä»ä¸åŒçš„å“åº”æ ¼å¼ä¸­æå–å›¾ç‰‡URL
                        let imageUrl = null;
                        
                        if (data.output && data.output.length > 0) {
                            imageUrl = data.output[0];
                        } else if (data.result && data.result.url) {
                            imageUrl = data.result.url;
                        } else if (data.url) {
                            imageUrl = data.url;
                        } else if (data.image_url) {
                            imageUrl = data.image_url;
                        } else if (data.data && data.data.length > 0 && data.data[0].url) {
                            imageUrl = data.data[0].url;
                        }
                        
                        // å¦‚æœæ‰¾åˆ°å›¾ç‰‡URLï¼Œè¿”å›æˆåŠŸ
                        if (imageUrl) {
                            debug.textContent += `\nâœ… [${requestId}] ä»»åŠ¡å®Œæˆï¼ŒæˆåŠŸè·å–å›¾ç‰‡URL`;
                            return { success: true, imageUrl };
                        } else {
                            debug.textContent += `\nâš ï¸ [${requestId}] ä»»åŠ¡å®Œæˆä½†æœªæ‰¾åˆ°å›¾ç‰‡URL`;
                        }
                    } else if (data.status === 'failed' || data.status === 'error') {
                        // ä»»åŠ¡å¤±è´¥
                        const errorMessage = data.error || 'ä»»åŠ¡æ‰§è¡Œå¤±è´¥';
                        debug.textContent += `\nâŒ [${requestId}] ä»»åŠ¡å¤±è´¥: ${errorMessage}`;
                        throw new Error(`ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ${errorMessage}`);
                    } else {
                        // ä»»åŠ¡ä»åœ¨è¿›è¡Œä¸­
                        const progress = data.progress || 'æœªçŸ¥';
                        debug.textContent += `\nâ³ [${requestId}] ä»»åŠ¡è¿›è¡Œä¸­ï¼Œè¿›åº¦: ${progress}`;
                    }
                    
                } catch (error) {
                    debug.textContent += `\nâŒ [${requestId}] è½®è¯¢è¿‡ç¨‹å‡ºé”™: ${error.message}`;
                    // ç»§ç»­è½®è¯¢ï¼Œä¸ä¸­æ–­
                }
            }
            
            // è¶…è¿‡æœ€å¤§è½®è¯¢æ¬¡æ•°
            debug.textContent += `\nâš ï¸ [${requestId}] è¾¾åˆ°æœ€å¤§è½®è¯¢æ¬¡æ•°(${maxAttempts})ï¼Œä»»åŠ¡å¯èƒ½ä»åœ¨å¤„ç†ä¸­`;
            throw new Error(`è½®è¯¢è¶…æ—¶ï¼Œè¯·ç¨ååœ¨å†å²è®°å½•ä¸­æŸ¥çœ‹ç»“æœ`);
        }
        
        // å¤‡ç”¨è½®è¯¢æ–¹æ³•ï¼ˆä½¿ç”¨ä¸åŒçš„APIç«¯ç‚¹æ ¼å¼ï¼‰
        async function pollTaskResultAlternative(apiKey, taskId, requestId) {
            const debug = document.getElementById('debug');
            const maxAttempts = 30;
            const pollInterval = 2000;
            
            debug.textContent += `\nğŸ”„ [${requestId}] ä½¿ç”¨å¤‡ç”¨ç«¯ç‚¹è½®è¯¢ä»»åŠ¡ç»“æœ`;
            
            // å°è¯•å‡ ç§å¯èƒ½çš„APIç«¯ç‚¹æ ¼å¼
            const config = getApiConfig();
            const baseUrl = config.apiUrl.replace('/v1/chat/completions', '');
            const endpoints = [
                `${baseUrl}/v1/${taskId}`,
                `${baseUrl}/${taskId}`,
                `${config.apiUrl}/${taskId}`
            ];
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                debug.textContent += `\nğŸ”„ [${requestId}] å¤‡ç”¨è½®è¯¢ç¬¬${attempt}æ¬¡...`;
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                
                // å°è¯•æ‰€æœ‰å¯èƒ½çš„ç«¯ç‚¹
                for (const endpoint of endpoints) {
                    try {
                        debug.textContent += `\nğŸ” [${requestId}] å°è¯•ç«¯ç‚¹: ${endpoint}`;
                        
                        const response = await fetch(endpoint, {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            continue; // å°è¯•ä¸‹ä¸€ä¸ªç«¯ç‚¹
                        }
                        
                        const data = await response.json();
                        debug.textContent += `\nğŸ“‹ [${requestId}] å¤‡ç”¨è½®è¯¢å“åº”: ${JSON.stringify(data)}`;
                        
                        // å°è¯•ä»å“åº”ä¸­æå–å›¾ç‰‡URL
                        let imageUrl = null;
                        const responseText = JSON.stringify(data);
                        const urlRegex = /https?:\/\/[^\s"'\],}]+(?:\.png|\.jpg|\.jpeg|\.gif|\.webp)/gi;
                        const urls = responseText.match(urlRegex);
                        
                        if (urls && urls.length > 0) {
                            imageUrl = urls[0];
                            debug.textContent += `\nâœ… [${requestId}] ä»å¤‡ç”¨è½®è¯¢ä¸­æ‰¾åˆ°å›¾ç‰‡URL`;
                            return { success: true, imageUrl };
                        }
                        
                    } catch (error) {
                        debug.textContent += `\nâŒ [${requestId}] å¤‡ç”¨ç«¯ç‚¹è¯·æ±‚å¤±è´¥: ${error.message}`;
                    }
                }
            }
            
            debug.textContent += `\nâš ï¸ [${requestId}] å¤‡ç”¨è½®è¯¢è¾¾åˆ°æœ€å¤§æ¬¡æ•°ï¼Œæœªèƒ½è·å–ç»“æœ`;
            throw new Error('å¤‡ç”¨è½®è¯¢å¤±è´¥ï¼Œæœªèƒ½è·å–ä»»åŠ¡ç»“æœ');
        }
        
        function showApiFormatChangeNotice() {
            const notice = document.createElement('div');
            notice.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                width: 400px;
                padding: 20px;
                background: linear-gradient(135deg, #4caf50, #8bc34a);
                color: white;
                border-radius: 10px;
                box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                z-index: 10000;
                font-family: Arial, sans-serif;
                font-size: 14px;
                line-height: 1.5;
            `;
            
            notice.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 24px; margin-right: 10px;">âœ…</span>
                    <strong style="font-size: 16px;">äº‘é›¾APIå¼‚æ­¥æ¨¡å¼å·²é€‚é…</strong>
                </div>
                <p style="margin: 0 0 15px 0;">
                    æ£€æµ‹åˆ°äº‘é›¾APIå·²æ›´æ–°ä¸ºå¼‚æ­¥æ¨¡å¼ï¼Œç³»ç»Ÿå·²è‡ªåŠ¨é€‚é…å¹¶æ”¯æŒè½®è¯¢ç»“æœã€‚
                </p>
                <ul style="margin: 0; padding-left: 20px;">
                    <li>å›¾ç‰‡ç”Ÿæˆå¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…</li>
                    <li>ç³»ç»Ÿä¼šè‡ªåŠ¨è½®è¯¢ä»»åŠ¡çŠ¶æ€ç›´åˆ°å®Œæˆ</li>
                    <li>ç”Ÿæˆè¿‡ç¨‹ä¸­å¯æŸ¥çœ‹è°ƒè¯•ä¿¡æ¯äº†è§£è¿›åº¦</li>
                </ul>
                <button onclick="this.parentElement.remove()" style="
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(255,255,255,0.3);
                    border: none;
                    color: white;
                    width: 25px;
                    height: 25px;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 16px;
                ">Ã—</button>
            `;
            
            document.body.appendChild(notice);
            
            // 5ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                if (notice.parentElement) {
                    notice.remove();
                }
            }, 8000);
        }
</script>
</body>
</html>